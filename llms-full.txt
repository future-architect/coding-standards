---
url: /coding-standards/documents/forAWSResource/AWSインフラリソース命名規約.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# 免責事項

::: warning 有志で作成したドキュメントである

* フューチャーアーキテクトには多様なプロジェクトが存在し、それぞれの状況に合わせた開発手法が採用されている。本規約はフューチャーアーキテクトの全ての部署／プロジェクトで利用されているわけではなく、有志が観点を持ち寄って新たに整理したものである。相容れない部分があればその領域を書き換えて利用することを想定している

:::

# 前提条件

* 開発チームが 3 ～ 30 名程度で構築する規模での利用を想定している
* 本規約をそのままプロジェクトに導入することを推奨する
  * そのままの導入ができない場合は、一部を抜粋、拡張して用いられることを想定している
* AWS の構成はマネージドサービスを活用するベストプラクティスに従うものとする
  * 例えば、1 台の EC2 上で DB とアプリのように複数のサービスを稼働させるといった構成は考慮しない
* 一部のリージョンでのみ利用可能な機能は想定していない
  * 例えば、[AWS Local Zones](https://aws.amazon.com/jp/about-aws/global-infrastructure/localzones/) は考慮しない

# 名前の構成要素

各リソースの名前に用いる要素を次の一覧に示す。

| Category     | Item           | Name                     | Usage                                                                                             |
| ------------ | -------------- | ------------------------ | ------------------------------------------------------------------------------------------------- |
| Common       | `{env}`        | 環境                     | 環境の区別                                                                                        |
|              | `{product}`    | 製品名                   | 構築する製品名またはシステム名。稼働するマイクロサービス名もこれに当たる                          |
|              | `{role}`       | 役割                     | 役割を示す。場合によっては具体的な製品名 postgres, jenkins などを指定する                         |
|              | `{usage}`      | 用途                     | 利用目的やリソースの動作 (action) を示す。user\_master, fileupload など識別したい値を指定する      |
|              | `{target}`     | 対象                     | 操作の対象。usage が複数の対象があり区別したいときに利用する。                                    |
| Network      | `{region}`     | リージョン               | [リージョンコード](https://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html) の略称を用いる |
|              | `{az}`         | アベイラビリティーゾーン | マルチ AZ 構成などで、明示的に AZ を意識する場合に用いる                                          |
|              | `{access}`     | アクセス修飾子           | access modifier. ネットワークでの public, private を区別したいときに利用する                      |
|              | `{permission}` | 権限                     | allow または deny を指定する。Security Group での利用を想定                                       |
| Organization | `{company}`    | 会社名                   | 会社の特定に利用。複数の会社による構築や、運用に複数社関わる場合などに必要となる                  |
|              | `{project}`    | プロジェクト             | プロジェクト制でプロダクトを開発する際のプロジェクト名または、プロジェクトコード                  |

## 環境 (`{env}`)

ソフトウェア開発では複数の環境を用意し、dev, stg, prod などの名前をつけて互いに完全に分離・区別する運用を行うことが多い。そういった環境分離のために AWS インフラは次のいずれか、もしくは組み合わせで設計される。

1. 環境単位で AWS アカウントを作成する
2. 環境単位で AWS リージョンを分ける
3. 命名で分ける

いずれの方法でも、 **各リソース名に環境名を付与することを推奨** する。冗長な命名となる場合もあるが、以下が理由である。

* 同一 AWS アカウントかつ同一リージョン内には、同じ名前のリソースを作成できない
* AWS リソース名のみで環境を特定できるようにする事で、誤った環境のリソースを操作してしまうミスを低減する
* メンバー間の認識齟齬を無くし生産性を高める
  * チームメンバーなどの問い合わせやトラブルシュートの際に、リソース名のみでどの環境にあるか素早く判断できるようにする
  * メンバーの役割によっては AWS アカウント構成を完全には理解できていない可能性がある

### 環境識別子

主要な環境名と識別子 (Identifier) は以下である。AWS リソースの命名には識別子を用いる。

| Name                 | Identifier | Memo                                                         |
| -------------------- | ---------- | ------------------------------------------------------------ |
| Production           | prod       | エンドユーザーが使う環境、本番運用環境                       |
| Staging              | stg        | 本番と同じ構成でテストするための環境                         |
| User Acceptance Test | uat        | ユーザーがシステムのレビュー、または操作を学習するための環境 |
| Performance Test     | perf       | 性能検証を行うための環境                                     |
| Development          | dev        | 開発チームが開発するための環境                               |
| Local                | local      | ローカル環境                                                 |

prod についてはよく用いる dev, stg と見間違えを防ぐため 4 文字にしている。

[デプロイメント環境](https://ja.wikipedia.org/wiki/%E5%B1%95%E9%96%8B%E7%92%B0%E5%A2%83) の考え方では、User Acceptance Test 環境を単にテスト環境 (Test) 呼ぶが、テストという単語は汎用的であるため複数の環境にあてはまる。したがって容易に認識齟齬が生じるため本規約では非推奨とする。

名前には必ず識別子を用いる。環境名をそのまま利用しない (例: `production-example-s3bucket` とは命名しない)。

理由:

* AWS リソースによっては名前の文字数の制限が厳しい (例: ELB は最大 32 文字である)
* AWS コンソールや設計ドキュメントなどで一覧化した場合に見切れる可能性を減らして可読性を高める
* 識別子に採用した単語は一般的に用いられている略称である
* その他の環境についても、環境識別子の数は通常そこまで多くならないず、またよく用いられるため、利用者にとっての認識負荷は少なく覚えるコストも低い

### 同一目的の複数環境

同一目的の環境が複数必要な場合は、識別子の末尾に連番をつける。

例:

* dev1, dev2, dev3
* stg1, stg2

## 役割 (`{role}`)

アプリケーションを構成する要素には役割がある。それを AWS リソース名に含めることで、開発者の理解を助け、操作ミスを低減する。

主要なロール名と識別子は以下である。

| Name            | Identifier | Memo                                                                           |
| --------------- | ---------- | ------------------------------------------------------------------------------ |
| Web Server      | web        | apache や nginx などの Web サーバとしての役割                                  |
| Web Application | app        | Web アプリケーションとしての役割                                               |
| Web API         | api        | HTTP(s) API を提供する                                                         |
| Job             | job        | 時間やある特定のイベントをもとにバックグラウンドの処理（バッチ処理など）を行う |
| I/F             | if         | ファイル入出力を行う                                                           |
| DB              | db         | データベース                                                                   |
| Cache           | cache      | キャッシュ                                                                     |
| CI/CD           | ci         | CI/CD サーバ                                                                   |

名前を一般化せず、プロダクト名をそのまま利用しても問題ない。例えば、Web アプリサーバに `tomcat`、CI/CD サーバに `jenkins` といった名称を使っても良い。

## 用途 (`{usage}`)

利用目的やリソースの動作 (action) を示す。user\_master, fileupload といった形式や、認証(auth)や BFF（Backend For Frontend）など。

役割 (`{role}`) と合わせてリソースが一意に特定できる名称を設定する。

## リージョン (`{region}`)

マルチリージョン構成を取り、リージョンを意識する必要のある場合に利用する。[リージョンコード](https://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html) そのものではなく略称を識別子として用いる。

| Name                              | Region Code    | Identifier |
| --------------------------------- | -------------- | ---------- |
| 米国東部 (バージニア北部)         | us-east-1      | ue1        |
| 米国東部 (オハイオ)               | us-east-2      | ue2        |
| 米国西部 (北カリフォルニア)       | us-west-1      | uw1        |
| 米国西部 (オレゴン)               | us-west-2      | uw2        |
| アジアパシフィック (東京)         | ap-northeast-1 | an1        |
| アジアパシフィック (ソウル)       | ap-northeast-2 | an2        |
| アジアパシフィック (大阪)         | ap-northeast-3 | an3        |
| アジアパシフィック (シンガポール) | ap-southeast-1 | as1        |

シングルリージョン構成または、リージョン間のリソースの関係が疎である場合はリージョン識別子を付与しない。

## アベイラビリティゾーン (`{az}`)

AZ 名にはリージョンコードを含めず、末尾のアルファベットだけとする。

| AZ ID           | Identifier |
| --------------- | ---------- |
| ap-northeast-1a | a          |
| ap-northeast-1c | c          |
| ap-northeast-1d | d          |

* 利用可能な文字: `[a-d]{1}`

## アクセス修飾子 (`{access}`)

VPC のサブネットは、パブリックサブネットの場合インターネットに直接アクセスできる。パブリックサブネットを区別したい場合はリソース名にアクセス修飾子を付与する。

| Name                   | Identifier |
| ---------------------- | ---------- |
| パブリックサブネット   | public     |
| プライベートサブネット | private    |

# 全体ポリシー

## 命名規約

次のように各要素を使ってケバブケース (`kebab-case`) で命名する。パスカルケース (`PascalCase`) やスネークケース (`snake_case`) は利用しない。なお、サービス名自体にパスカルケースを用いることは許容する

```properties
# 命名規約の基本形
{env}-{product}-{role}-{usage}
```

理由:

* ほぼ全ての AWS サービスではリソース名にハイフンを許容する。一方で、アンダースコアを許容しない WebACL のようなサービスがある
* 環境名、サービス名などの単位で区切りを明確にできる

## 利用可能な文字

利用する文字は、半角英数字とハイフンに限定する。また、 **小文字を推奨** する。

* 推奨: `[a-z0-9\-]+`

また、先頭文字には半角英字を用い (ハイフン、数値を先頭にしない)、ハイフンは 2 文字以上連続させないこととする。

## AWS サービス名を含めない

リソース名に AWS サービス名を含めない。

良い例：

```properties
stg-fuga-web-fileupload
stg-fuga-web-fileupload
```

悪い例：

```properties
stg-fuga-web-fileupload-s3
stg-fuga-web-fileupload-bucket
```

理由:

* AWS コンソールで見たときにどの AWS サービスのリソースを見ているか自明である
* [Terraform の命名規則](https://www.terraform-best-practices.com/naming#resource-and-data-source-arguments) にリソース名を繰り返さないという記載があり、整合性を持たせるため

> **Resource and data source arguments**
> Do not repeat resource type in resource name (not partially, nor completely):

ただし、VPC エンドポイントやセキュリティグループのように、どの AWS サービスの何で利用されているかを示す場合には利用することがある。

## プロジェクト名を含めない

プロジェクト制を取っている場合、その開発チームの持ち物であることを示すためプロジェクト名をリソース名に含めたくなるが非推奨である。

理由:

* 必ずしも開発しているプロダクトと、プロジェクトの粒度・ライフサイクルは一致しない
* プロジェクトが解散すると管理主管が曖昧になる

プロジェクト名の替わりにプロダクト名を含めることとする。

## マルチクラウドを考慮し、aws 識別子を追加するかどうか

AWS だけではなく、Azure や GCP などを組み合わせたマルチクラウド運用を行っている、あるいは行う予定がある場合を考慮し、リソース名に `aws` といったプレフィックス/サフィックスを付与する考えもある。

本規約では、`aws` キーワードをリソース名に含めることは非推奨とする。

理由:

* 同一 product を異なるクラウドサービスで運用することは稀
* 一部のサービス (例えば DWH のみ Google BigQuery を利用するようなケース) だけの使用であれば、`{usage}` で区別すれば十分である

# サービス別の命名規約

サービスによって異なる命名規約と例を記載する。

以下ではプロダクト名を `fuga` とした場合の例をあげる。

## VPC

VPC に関わるリソースの命名について記載する。

| Resource Name    | Naming Convention                       | Example              | Note                                                    |
| ---------------- | --------------------------------------- | -------------------- | ------------------------------------------------------- |
| VPC              | `{env}-{product}`                       | stg-fuga             |                                                         |
| Subnet           | `{env}-{product}-{access}-{az}`         | stg-fuga-public-a    | AZ: どこのゾーンかを識別するため                        |
| EIP              | `{env}-{product}-{usage}`               | stg-fuga-nat         |                                                         |
| Route Table      | `{env}-{product}-{access}`              | stg-fuga-public      |                                                         |
| Internet Gateway | `{env}-{product}`                       | stg-fuga             |                                                         |
| NAT Gateway      | `{env}-{product}`                       | stg-fuga             |                                                         |
| Endpoint         | `{env}-{product}-{aws_service}`         | stg-fuga-s3          | 様々なサービスが利用するため AWS サービス名を含めている |
| Security Group   | `{env}-{product}-{aws_service}-{usage}` | stg-fuga-ec2-bastion | 様々なサービスが利用するため AWS サービス名を含めている |

## API Gateway

* ドキュメントは確認できなかったら、リソース名は 1024 文字まで指定可能。システム上は一意である必要はない

API Gateway は [全体ポリシーの命名規約](#命名規約) に則る。管理上、一意となるように命名する

```properties
# 命名規約の基本形
{env}-{product}-{role}-{usage}-{access}

# 例
stg-fuga-web-portal-private
stg-fuga-web-fileupload-public
```

* API Gateway には複数の機能種別 (REST, HTTP) が存在するが、命名には含めない
* private/public を名前に含めることで、public は認証が入っているかなどをチェックできる

## EC2

インスタンス名の制限=タグの制限のため、名前は [Amazon EC2 リソースのタグ付け](https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/Using_Tags.html) に従う必要がある。

```properties
# 命名規約の基本形
{env}-{product}-{role}

# 例
stg-fuga-web
```

オートスケーリング、オートヒーリング構成をする場合にどこの AZ に配置するかを意識させないため、リソース名に AZ は基本的に含めない。そのような構成をしないという方針は、アンチパターンのため構成を見直すべきと考える。

## LB

* 最大文字数: 32
* 英数字とハイフンが利用可能 (先頭、末尾にハイフン不可)
* ALB と NLB のセット内で一意である必要がある
* 参考: [Application Load Balancer にタグを付ける](https://docs.aws.amazon.com/ja_jp/elasticloadbalancing/latest/application/load-balancer-tags.html)

LB には ALB/NLB/CLB などの種類があるが、いずれも以下の命名規約に従う。また、Internal LB に関しては、`{usage}` 部に含める。

```properties
# 命名規約
{env}-{product}-{role}-{usage}-{access}

# 例
stg-fuga-web-api-public
```

ターゲットグループ名は、基本的には LB と同じである。

ただし、Blue/Green デプロイを行う場合は、ターゲットグループ名をユニークにし、どちら (Blue/Green) に所属しているかをわかるようにする。

```properties
# Target group name (Blue/Green) の命名規約
{env}-{product}-{role}-{usage}-{access}-blue

# 例
stg-fuga-web-public-blue
```

## ECS

* クラスター
  * 最大文字数: 255
  * 利用可能文字種: `A-z`, `0-9`, `-`, `_`
  * その他制約: 先頭の文字は `A-z` のみ利用可能
* サービス、タスク定義
  * 最大文字数: 255
  * 利用可能文字種: `A-z`, `0-9`, `-`, `_`

ECS の命名規約は以下のとおりである

```properties
# クラスターの命名規約
{env}-{product}

# 例
stg-fuga

# サービスの命名規約
{env}-{product}-{role}-{usage}

# 例
stg-fuga-api-auth
stg-fuga-web-frontend

# タスク定義の命名規約
{env}-{product}-{role}-{usage}

# 例
stg-fuga-batch-import-address
```

## Lambda

### Lambda Function

[CreateFunction](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/API_CreateFunction.html) によると以下の制約である。

* 1 ～ 64 文字
* 利用可能文字: `[a-zA-Z0-9-_]+`

Lambda は運用を経てリソース数が増えやすいサービスの一つである。そのため個別の機能名の前に `{role}` を含めてグルーピングしやすい名前にする。

```properties
# 命名規約
{env}-{product}-{role}-{usage}

# 例
stg-fuga-import-userprofile
stg-fuga-job-checkconsistency
stg-fuga-report-successrate
```

もし、Scatter-Gather パターンを用いる場合は次のようにサフィックスに追加して区別する。

```properties
# 命名規約
{env}-{product}-{role}-{usage}-scatter
{env}-{product}-{role}-{usage}-segment
{env}-{product}-{role}-{usage}-gather
```

### Lambda Layer

* 1 ～ 64 文字
* 利用可能文字: `[a-zA-Z0-9-_]+`

Lambda Layers は実行環境が重要であるため、 `{runtime}` で言語バージョンを指定する。

```properties
# 命名規約
{env}-{product}-{runtime}-{usage}

# 例
stg-fuga-python310-auth
stg-fuga-nodejs18-frontend
```

## RDS/Aurora

[Amazon RDS の命名に関する制約](https://docs.aws.amazon.com/ja_jp/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints) によると以下の制約である。

* 1 ～ 63 個の英数字またはハイフンを使用する必要があります
* 1 字目は文字である必要があります
* 文字列の最後にハイフンを使用したり、ハイフンを 2 つ続けて使用したりすることはできません
* 1 つの AWS アカウント、1 つの AWS リージョンにつき、すべての DB インスタンスにおいて一意である必要があります

```properties
# クラスターの命名規約
{env}-{product}-{role}

# 例
stg-fuga-auth

# インスタンスの命名規約
{env}-{product}-{role}-{serial}

# 例
stg-fuga-auth-01

# DBパラメータグループの命名規約
{env}-{product}-{role}
{env}-{product}

# 手動スナップショットの命名規約
{env}-{product}-{role}-{yyyy}-{mm}-{dd}
```

AZ は含めない。

理由:

* RDS はマルチ AZ 構成をとることが推奨のため
* Aurora は自動でマルチ AZ 構成をとっているため

DB パラメータグループは、role 単位での設定を推奨する。product を跨いでの設定は行わない。

* 設定値の変更はパラメータグループを適用している全ての DB に変更が反映される。同じパラメータグループを複数の DB で共有し過ぎることにより意図しない DB にまで設定変更が反映されるリスクを避けるため

クラスター/インスタンスに適用する IAM ロール

* [IAM ロール](#iam-ロール) を参照

DB サブネット

* [VPC](#vpc) のサブネットを参照

## DynamoDB

[Amazon DynamoDB でサポートされるデータ型と命名規則](https://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html) によると以下の制約である。

* すべての名前は UTF-8 を使用してエンコードする必要があり、大文字と小文字が区別される
* 3 ～ 255 文字
* 利用可能な文字: `[a-zA-Z0-9_.-]+`

DynamoDB のテーブル名には、環境、プロダクト名、用途を用いる。データは長く残り、かつ変更しにくいため会社名などの変化しやすい項目は含めない。

```properties
# DynamoDB の命名規約
{env}-{product}-{usage}

# 例
stg-fuga-user
stg-fuga-user-accesslog
```

なお、インデックス名は `idx-1`, `idx-2` のような連番での管理を推奨する。RDB とは異なりアカウント単位での一意性は不要なため、テーブル名は含めなくても良いため、 `idx_{テーブル名}_{連番}` としなくても良い。DynamoDB は 最大で 20 のグローバルセカンダリインデックス を持つことができるが、インデックスの数は最小限に抑えることが鉄則であるため、0 埋めしない。ただし、要件上どうしても多用が避けられないことが判明している場合は `idx-01`, `idx-02` と 0 埋めする。

## S3 Bucket

[Amazon S3 バケットの命名要件](https://docs.aws.amazon.com/ja_jp/awscloudtrail/latest/userguide/cloudtrail-s3-bucket-naming-requirements.html) によると以下の制約である。

* 1 ～ 63 文字
* 半角英数字、ピリオド、ダッシュのみを使用可能
* バケット名の各ラベルは、小文字または数字で始まっている必要がある
* バケット名では、アンダースコア、末尾のダッシュ、連続するピリオド、隣接するピリオドとダッシュは使用できない
* バケット名を IP アドレス (198.51.100.24) として書式設定することはできない

S3 は非常に多くの用途で用いることがあるため、利用形態に応じて規則を変えて対応する。

```properties
# 通常の命名規約
{env}-{product}-{use}

# 例
stg-fuga-fileupload

# ログを保管するバケットの命名規約
{env}-{product}-{service}-logs

# 例
stg-fuga-alb-logs

# データ授受で利用する場合の命名規約
{env}-{product}-{use}-{dest}-if

# 例
stg-fuga-userinfo-fis-if
```

## Kinesis Data Streams

[CreateStream](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_CreateStream.html#API_CreateStream_RequestSyntax) によると以下の制約である。

* 異なる AWS アカウントであれば同名が許容
* 異なるリージョンであれば同名が許容
* 1 ～ 128 文字
* `[a-zA-Z0-9_.-]+`

IoT のセンシングを始めとしたイベントデータの場合は、次の命名規約を用いる。`{role}` には import や export など、どのような処理を行うかを規定する。

設計によっては、データ種別 (スキーマ) 毎に分離することもあるため、デバイス名やセンサー名などの発生源の名前を持たせる。

```properties
# 命名規約
{env}-{product}-{role}-{usage}-{schema}

# 例
stg-fuga-import-iotsensor-devicetype
stg-fuga-import-iotsensor-toggle
```

ジョブキューとして用いる場合は、どのジョブを利用するかが重要であるため、呼び出し用であることが明確になるように命名する。

```properties
# 命名規約
{env}-{product}-call-{呼び出したいジョブ名}

# 例
stg-fuga-call-job-arrival-check
```

## SQS

[Amazon SQS キューとメッセージの識別子](https://docs.aws.amazon.com/ja_jp/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-queue-message-identifiers.html) によると以下の制約である。

* 最大 80 文字
* `[a-zA-Z0-9_-]`
* FIFO キューの場合には `.fifo` のサフィックスで終わる必要がある
* 1 つの AWS アカウント、1 つの AWS リージョンにつき一意である必要がある

1 つのキューに対し、複数のプロデューサー、コンシューマーを取りうるため、プロデューサー、コンシューマーを名前に含めることは推奨しない。

```properties
# 標準キューの命名規約
{env}-{company}-{product}-{usage}

# 例
stg-future-fuga-processresult

# FIFOキューの命名規約
{env}-{company}-{product}-{usage}.fifo

# 例
stg-future-fuga-processresult.fifo
```

## Event Bridge Rule

* 最大 64 文字
* 数字、小文字/大文字、 `.` (ピリオド)、 `-` (ハイフン)、 `_` (アンダーバー) が使用可能
* 同じリージョン内および同じイベントバス上の別のルールと同じ名前を付けることは不可

```properties
# 命名規約
{env}-{product}-{usage}-{source}-{target}

# 例
stg-fuga-deploy-s3-codepipeline
stg-fuga-archive-auth0-s3
stg-fuga-polling-schedule-lambda
```

※スケジュールタイプのルールの場合は `{source}` に `schedule` と記載する。

## IAM

IAM に関わるリソースの命名について記載する。IAM グループ、IAM ユーザー、IAM ロール、IAM ポリシーの 4 点について述べる。

### IAM ユーザー

IAM ユーザーについては、誰 (人またはシステム) が利用するのかを識別することを目的とする。同じユーザーを複数の人やシステムで使いまわすと、誰が操作したのかといった証跡を追えなくなってしまうため、個別に発行することを推奨する。
また、役割や権限といった情報は名前に含めない。そのような名前はユーザーに紐づけるロールが増えた際などに名前と役割や権限の実態が乖離してしまうためである。

IAM ユーザー名については全体ポリシーから外れ、アンダースコア区切りを推奨する。

理由:

* 多くのサービスでユーザー名には慣習的にアンダースコアを用いることが多いため

人が利用する IAM ユーザー：

```properties
# 命名規約
{company}_{username}

# 例
future_taro_mirai
```

※AWS アカウントに関与する人が単一の会社に属する人だけである場合は `{company}_` を省略しても良い。

システムが利用する IAM ユーザー：

```properties
# 命名規約
{product}_{usage}

# 例
fuga_api
fuga_auth0
```

AWS サービスに権限付与する場合は IAM ロールで付与することを想定している。システムが利用する IAM ユーザーは、別のクラウドや SaaS 等への権限付与に使うことを想定している。

[全体ポリシーの命名規約](#命名規約) とは異なり、環境名 `{env}` を Prefix につけない理由は次である。

* ある AWS アカウントに対して、Switch Role などで別の環境にアクセスする際に混乱が生じる
* ブラウザのパスワード管理などのために ID 名を分けたいという考えもあるかもしれないが、パスワード管理アプリなどの利用を推奨する

### IAM グループ

IAM グループに IAM ユーザーを追加することで複数ユーザーの権限を一括管理できる。IAM ユーザーは複数の IAM グループに追加可能だが、所属可能なグループ数は最大で 10 という制約があるため注意が必要である。

この制約を踏まえ、各役職ごとに基本となるグループを作成し、基本グループで対応できない例外的な権限の付与を個別のグループで対応することを想定した命名としている。

また、グループ数をむやみに増やさないためにグループ名に環境名 `{env}` はつけない。仮に `future-developer` というグループが dev 環境のみにアクセスできるといったような制御をする場合でも、グループ名には dev をつけず、dev 環境にアクセス可能なポリシーをグループにアタッチする方針としている。

基本となるグループ:

```properties
# 命名規約
{company}-{role}

# 例
future-developer
future-maintainer
```

ここでの `{role}` はユーザーが担う役割を表す。

個別のグループ:

```properties
# 命名規約
{target}-{usage}

# 例
bastion-access
```

個別のグループは Session Manager で EC2 にアクセスするグループといった使い方を想定している。

例外的に特定のユーザーにのみ権限を付与する、会社を超えて共通のグループを付与するといったユースケースも考えられる。

### IAM ロール

IAM ロールは、AWS サービスに権限を付与する目的で利用する。IAM ロールに複数の IAM ポリシーをアタッチできるため、IAM ロールの命名では細かい権限を表現することは避け、IAM ロールを誰が使うのかを明確にすることを主目的とする。

```properties
# 命名規約
{env}-{product}-{aws_service}-{usage}

# 例
stg-fuga-ec2-bastion
stg-fuga-lambda-api
```

※場合によっては `{usage}` 部に詳細情報を追加しても良い

### IAM ポリシー

IAM ポリシーの命名に入る前に、ポリシーの設計方針について記載する。
ここでは、ポリシー設計方針の代表例として、以下の 2 パターンについて説明する。

* 細かく設定し再利用するパターン
* 特定のリソースに付与するポリシーを書き出すパターン

それぞれの設計方針にはメリット・デメリットがあり開発規模などで使い分けが想定されるため、それぞれの場合の命名方法について記載する。

細かく設定する場合:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Action": "s3:*",
      "Effect": "Allow",
      "Resource": "*"
    }
  ]
}
```

```properties
# 命名規約
{env}-{product}-{permission}-{aws_service}-{usage}

# 例
stg-fuga-allow-s3-full
stg-fuga-allow-ses-send
```

特定のリソースに付与するポリシーを書き出す場合:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Action": "s3:*",
      "Effect": "Allow",
      "Resource": "*"
    },
    {
      "Action": ["ses:SendEmail", "ses:SendRawEmail"],
      "Effect": "Allow",
      "Resource": "*"
    },
    {
      "Action": "sqs:*",
      "Effect": "Allow",
      "Resource": "*"
    }
  ]
}
```

```properties
# 命名規約
{env}-{product}-{aws_service}-{usage}

# 例
stg-fuga-ec2-bastion
stg-fuga-iam-group-future-develop
```

IAM グループ用のポリシーを作成する例では、company を含めた `future-develop` といった名前を `{usage}` としている。

この場合は命名粒度が IAM ロールと等しくなるため、命名規約も同じ方針にしている。

予め用意されているポリシーの名前は `PascalCase` 形式であるが (例: AmazonS3FullAccess)、ユーザーが作成したことを明確にするため `snake_case` で命名する。

# タグの命名

[Tag naming and usage conventions](https://docs.aws.amazon.com/mediaconnect/latest/ug/tagging-restrictions.html) によれば以下の制約である。

* 最大 50 個のタグを設定できる
* タグキーは一意でなければならない
* タグキーは最長 128 Unicode 文字、タグ値は最長 256 Unicode 文字
* 使用可能文字
  * UTF-8 で表現できる文字、数字、スペース、`.` `:` `+` `=` `@` `_` `/` `-`
* タグのキーと値では大文字と小文字が区別されます
* タグに `aws:` プレフィックスは禁止

[AWS リソースのタグ付け](https://docs.aws.amazon.com/ja_jp/general/latest/gr/aws_tagging.html#tag-best-practices) によれば、タグ付けのベストプラクティスは以下である。

* 個人情報 (PII) などの機密情報や秘匿性の高い情報をタグに設定しない
* すべてのリソースタイプに一貫して適用する
* リソースアクセスコントロールの管理、コスト追跡、オートメーション、整理など、複数の目的に対応したタグガイドラインを考慮する
* 自動化ツールを使用してリソースタグを管理する
* タグは、多めに使用する
* 将来の変更の影響を考慮する
* AWS Organizations のタグポリシーを利用することで、組織が採用するタグ付け標準を自動的に適用する

より詳しいタグ付けのベストプラクティスも存在するが、本紙の範囲を超えるため紹介のみに留める。 <https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html>

## タグキー

* 使用する文字は英数字に限定する。基本的には **パスカルケース (PascalCase)** 形式を推奨する
  * リソース作成時に自動生成される `Name` タグと平仄を合わせるため
* 以下の観点でタグを使い分ける
  * リソース整理
  * コスト管理
    * AWS Billing にてコスト配分タグの設定が必要
  * オートメーション
    * EC2 の自動起動停止の管理など
  * アクセス制御
    * タグ値を利用した IAM ポリシーのアクセス制御など

主要なタグ項目

| Category     | Tag Key | Required | Note                                                                     |
| ------------ | ------- | -------- | ------------------------------------------------------------------------ |
| Common       | Env     | ✅       | 環境識別子                                                               |
|              | System  | ✅       | システム名                                                               |
|              | Name    | ✅       | リソースの識別子として機能名などを設定                                   |
| 費用按分     | Owner   | ✅       | リソースの管理主管部署。費用の負担先を想定                               |
|              | Project | ✅       | 開発担当チーム。どのチームがどれくらい利用したかをトレースするために設定 |
| ツールで利用 | StartAt |          | 起動時刻。自動化ツールなどで必要があれば設定                             |
|              | EndAt   |          | 停止時刻                                                                 |

## タグ値

* 各タグキーごとに原則、タグ値の元となる命名規約に従う
* 元となる命名規約がない場合、以下を推奨する
  * リソースの命名規約に従う
  * 頭文字のみの略語の場合は大文字のみ
* 値の取りうるパターンが決まっている場合には、タグポリシーで値を設定する

## タグポリシー

AWS Organizations を利用している場合、タグの標準化を促進するタグポリシーの設定が可能となる。
タグポリシーにより実現できることは以下。

* タグキーの大文字小文字の組み合わせを強制する
  * 例: `Name` を指定した場合、 `name`, `NAME`, `nAME` などはタグキーとして設定できなくなる
* 任意のタグキーに対して、設定可能なタグ値を指定する
  * `Env` など、予め取りうるタグ値のパターンが決まっている場合に利用
* タグポリシーを適用するリソースタイプを指定

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)

---

---
url: /coding-standards/documents/forJava/Javaコーディング規約.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。\
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。\
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# はじめに

一般に利用・参照されている Java コーディング規約やガイドラインを以下に示す。本規約の作成においても、下記規約類を参照・抜粋している。

| 規約                                                   | 著作者               | URL                                                                                                                                 |
| ------------------------------------------------------ | -------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| Code Conventions for the Java Programming Language     | Sun Microsystems     | <http://www.oracle.com/technetwork/java/codeconvtoc-136057.html>                                                                    |
| Writing Robust Java Code                               | Scott W. Ambler      | <http://www.ambysoft.com/downloads/javaCodingStandards.pdf>                                                                         |
| オブジェクト倶楽部版 Java コーディング標準             | オブジェクト倶楽部   | <http://objectclub.jp/community/codingstandard/CodingStd.pdf>                                                                       |
| 電通国際情報際サービス版 Java コーディング規約 2004    | 電通国際情報サービス | <http://objectclub.jp/community/codingstandard/JavaCodingStandard2004.pdf>                                                          |
| JJGuideline （Java - J2EE Conventions and Guidelines） | Stephan.J & JCS Team | <http://www.fedict.belgium.be/sites/default/files/downloads/Java_J2EE_conventions_and_guidelines_EN.pdf>※現在は削除されています |
| Google Java Style (非公式和訳)                         | Google               | <https://kazurof.github.io/GoogleJavaStyle-ja/>                                                                                     |
| Acroquest Technology Java コーディング規約             | Acroquest Technology | <https://www.acroquest.co.jp/webworkshop/javacordingrule/Acroquest_JavaCodingStandard_6_7.pdf>※現在は削除されています           |

※ Sun Microsystems の規約は Java 草創期から一応の標準という位置づけだったが、オブジェクト指向、及び、その開発環境の普及・発展によって、設計やコーディングにおいて、直接的に有用な知識や豊富な指針を含むような優れた規約や、ツールなどによる機械的な準拠チェックと連携する規約が普及してきている。

# 規約の重要性

標準としての規約を定義し、遵守することの重要性を以下に示す。

* ソフトウェアメンテナンスにおける、可読性・保守性・拡張性の向上
* 問題を起こしやすい実装を未然に回避することによる、品質・生産性の向上
* 標準規約を通して得られる一般的な実装知識やノウハウ（＝学習効果）

## コーディングの心得

長いプログラムを記述すること（ステップ数）によって生産性が評価されたのは、過去の時代の出来事である。現在は、クラスやメソッドの役割が明確で、ロジックが読みやすく、保守性に優れたプログラムを記述することが評価される。コーディング規約は、コードの書き方に関する一種のパターンと考えることもでき、コードの保守性を向上させる具体的な方法を示している。したがって、規約の一つ一つの意図を理解し、守ることが重要になる。しかし、保守性に優れたコードを作成するためには、コーディング規約を守ることに加えて、良いコードを記述するための基本的な心構えをしっかり心に留めておく必要がある。以下では、その心得について述べる。

【コーディングの心得 5 か条】

1. 見やすさを重視せよ
2. ネーミングはわかりやすく
3. サンプルを鵜呑みにしない
4. 同じコードを二度書かない
5. 役割は一つに

### 見やすさを重視せよ

「良いコード」の基本は、「他の人が読んでもわかりやすいと感じられるコード」。コードの見やすさは、フォーマットはもちろん、ロジックの簡潔さや API の常識的な使い方などから生まれる。コーディングにあたっては、常に他の人の視点を意識しながら、見やすさに気を配って記述する必要がある。例えば、自分で記述したコードであっても、しばらくたってから読み返してみると理解に時間がかかった経験は誰にもあるはず。「3 日前に書いたコードは他人のコードと同じ」ということもよく言われる。見やすさを重視することは、他の人のためだけでなく自分のためにもなる。コードを読んでもすぐに理解できないような実装は、再考（リファクタリング）の必要がある。

### ネーミングはわかりやすく

コーディングでは、様々な変数やメソッドなどにネーミング（名前付け）する必要がある。ネーミングとは、本来、その対象の本質を表すような名前を考える作業である。大変難易度の高い作業だが、一方で適当に行ってもコードの動作は変わらないため、人によっては手を抜きがちとなる。しかし、ネーミングの良し悪しは、コードの可読性に非常に大きな影響を及ぼす。例えば、「C0001」というクラス名があるとする。これでは、何を表すクラスなのかすぐにはわからないだろう。また、「int p = 5000;」という記述があるとする。プログラマに聞くと、変数名 p は価格(Price)の略だと言うのだが、それならば略さずに、「int price = 5000;」としたほうが分かりやすいはずである。「ネーミングはわかりやすく」の背景には、読んで内容が理解できるという意味で、文章のようなプログラミングを行う、という考え方に基づく。

### サンプルを鵜呑みにしない

サンプルコードを活用すること自体は、著作権等を侵害しなければ問題ない。問題なのは、その内容や背景を理解しないまま、サンプルコードだけを鵜呑みにして、「おまじない」として表面的に適用してしまうことである。コードを「おまじない」ととらえていては、サンプルコードの間違いを気づかないまま適用してしまうこともある。例えば、ストリームのクローズ処理を行っていないサンプルコードであっても、それに気づかずに自分のコードに適用してしまい、後で思わぬ障害を引き起こすという可能性がある。サンプルコードは、そこで説明する内容に絞ったコードが多いため、このような例はよく見られる。また、サンプルコードをそのまま適用した結果、自分が記述すべきコードには必要のないコードが含まれてしまう場合もある。その場合、コードの可読性を下げる原因となる。自分のコードは、自分で深く理解して記述すべきである。

### 同じコードは二度書かない

コードをコピー・ペーストしていませんか？コピー・ペーストしてしまうと、何らかの修正をする際に、全ての個所に同じ修正をする羽目になる。同じコードが現れるようならまとめて一つにし、外に出してコールするような書き方にすべきである。同じコードをまとめる作業は、どちらかといえば、コーディング時よりリファクタリング（ソフトウェアの外部的振る舞いを変更せずに内部構造を改善する作業）で行われることが多い。しかし、コーディング時からできるだけ気をつけておきたいことでもある。

### 役割は一つに

メソッドの役割が明確で、かつ 1 つであれば単体テストが行いやすくなる。つまり、コードの「試験性」が高まる。また、役割が一つであれば、後でコードを変更する際に修正箇所がわかりやすいため、障害修正に要する時間が短くなる。つまり、コードの「保守性」があがることになる。例えば、「チェックをして実行する」機能を実現するために、checkAndDo()メソッドが存在したとする。この場合、このメソッドは check()メソッドと do()メソッドに分割すべきである。なぜなら、checkAndDo()メソッドの check()ロジックに誤りがあった場合、do()メソッドに書かれる内容まで把握する必要が生じるためである。分割してあれば、check()メソッドだけの変更で済む。このことはクラスの設計にもあてはまる。

# ネーミング規約

## 全般

* 大文字・小文字の違いで名前を区別しない。

  良い例：

  ```java
  private int carNumber;
  private int trainNumber;
  ```

  悪い例：

  ```java
  private int num;
  private int Num;
  ```

## パッケージ

* パッケージ名はすべて小文字にする
* パッケージ名は意味のある名前にする
* サブパッケージ名の重複は可能

## クラス

* クラス名は単語の先頭を大文字にする\
  良い例：

  ```java
  public class Entry {
  ```

  悪い例：

  ```java
  public class entry {
  ```

* インターフェース名、Enum 名、Record 名はクラス名に準ずる

## メソッド

* コンストラクタと同じ名前のメソッドはつくらない

* メソッド名は区切りのみ大文字にする\
  良い例：

  ```java
  public String getName() {
      //・・・
  }
  ```

  悪い例：

  ```java
  public String getname() {
      //・・・
  }
  public String GETNAME() {
      //・・・
  }
  ```

* 変換メソッド名は「"`to`"+オブジェクト名」にする\
  良い例：

  ```java
  public String toString() {
  ```

  悪い例：

  ```java
  public String string() {
  ```

* ゲッターメソッド名は「"`get`"+属性名」にする\
  型が`boolean`の場合は「"`is`"+属性名」にする

* セッターメソッド名は「"`set`"+属性名」にする

* `boolean`変数を返すメソッド名は`true`/`false`の状態がわかるようにする

  良い例：

  ```java
  public boolean isAsleep() {
  }
  public boolean exists() {
  }
  public boolean hasExpired() {
  }
  ```

## 引数

* メソッドのパラメータ名とインスタンス変数名を一緒にしない\
  ただし、アクセサメソッドやコンストラクタなど、統合開発環境の機能により自動生成するものに関しては可とする。\
  アンダースコア　`_`　をつけての区別は原則禁止とする。

  良い例：

  ```java
  public double calc(double rate) {
      return this.value * rate;
  }
  ```

  悪い例：

  ```java
  public double calc(double value) {
      return this.value * value;
  }

  public double calc(double _value) {
      return this.value * _value;
  }
  ```

## 変数全般

* `boolean`変数は`true`/`false` の状態がわかるようにする

  良い例：

  ```java
  private boolean isOpen;
  ```

  悪い例：

  ```java
  private boolean flag;
  ```

* 定数は全て`static final`とし、すべて大文字、区切りは"`_`"

  良い例：

  ```java
  private static final String SYSTEM_NAME = "販売管理システム";
  ```

* 変数名は小文字とし、単語の区切りのみ大文字にする

  良い例：

  ```java
  private String thisIsString;
  ```

  変数名に固有名詞が含まれる場合、先頭をのぞき、単語の区切り以外に大文字を使用してもよい

  良い例：

  ```java
  private String thisIsIPAddress;
  ```

## ローカル変数

* スコープが狭い変数名は省略した名前でもよい\
  良い例：

  ```java
  if (・・・) {
      String s = "・・・・";
     //変数sを利用した処理 数行
  }
  ```

  悪い例：

  ```java
  String s = "・・・・";
  if (・・・) {
     //変数sを利用した処理
  }
  ・・・
  if (・・・) {
     //変数sを利用した処理
  }
  ```

  変数`s`の利用範囲が広いので役割が明確になる変数名に変更する。

* for 文のループカウンタは、ネストごとに"`i`","`j`","`k`"・・・を使う

## Enum

* Enum 名はクラス名と同じく、単語の先頭を大文字にする
* 列挙定数は定数と同じく、すべて大文字、区切りは"`_`"

  良い例：

  ```java
  enum Season {
      WINTER,
      SPRING,
      SUMMER,
      FALL
  }
  ```

  悪い例：

  ```java
  enum Season {
      winter,
      spring,
      summer,
      fall
  }
  ```

# コーディング規約

## 全般

* 原則としてオブジェクトの参照にはインターフェースを利用する\
  オブジェクトを参照する際は、そのオブジェクトの実装クラスを用いて宣言できるが、実装クラスに適切なインターフェースが存在している場合は、必ずインターフェースを用いて宣言すること。

  良い例：

  ```java
  List<Entry> list = new ArrayList<>();
  Map<String, String> map = new HashMap<>();
  ```

  悪い例：

  ```java
  ArrayList<Entry> list = new ArrayList<>();
  HashMap<String, String> map = new HashMap<>();
  ```

* 推奨されない API を使用しない\
  アノテーション`@Deprecated`で指定されたメソッドは利用しないこと。

* 使われないコードは書かない

* 宣言は適切な権限で行うこと（`public`, `protected`, `private`）

* `final` を適切に利用する\
  継承されないクラス、オーバーライドされないメソッド、値の変わらない変数（つまり定数）等、変化のないもの/変化させたくないものについては`final` で宣言する。

  良い例：

  ```java
  //継承されないクラス
  public final class CalculateUtils {
      //・・・
  }

  //値の変わらない変数（定数）
  private static final String MESSAGE = "・・・";

  //オーバーライドされないメソッド
  public final int sum(/*変化させたくない値*/final int... values) {
      int sumValue = 0;
      for (/*変化させたくない値*/final int value : values) {
          sumValue += value;
      }
      return sumValue;
  }
  ```

## フォーマット

* インデントは空白文字 4 文字分の Tab を使用する

* 長すぎる行は避ける

* `{` の後にステートメントを記述しない\
  良い例：

  ```java
  if (s == null) {
      return 0;
  }
  ```

  悪い例：

  ```java
  if (s == null) {return 0;}
  ```

* 1 行に 2 つ以上のステートメントを記述しない\
  悪い例：

  ```java
  } catch (Exception e) {
      log.error("Error", e);return null;
  }
  ```

* カンマの後には空白文字を\
  良い例：

  ```java
  process(x, y, z);
  ```

  悪い例：

  ```java
  process(x,y,z);
  ```

* 代入演算子（ `=` , `+=` , `-=` , …）の前後には空白文字を挿入する\
  良い例：

  ```java
  int a = x;
  a += 10;
  ```

  悪い例：

  ```java
  int a=x;
  a+= 10;
  ```

* for 文内のセミコロンの後には空白文字を挿入する\
  良い例：

  ```java
  for (int i = 0; i < array.length; i++) {
      //・・・
  }
  ```

  悪い例：

  ```java
  for (int i = 0;i < array.length ;i++) {
      //・・・
  }
  ```

* `++` や `--` とオペランドの間には空白文字を入れない\
  良い例：

  ```java
  i++;
  ```

  悪い例：

  ```java
  i ++;
  ```

* ビット演算子（ `|` 、 `&` 、 `^` 、 `<<` 、 `>>` ）の前後には空白文字を挿入する

* 論理演算子（ `||` 、`&&`）の前後には空白文字を挿入する

* 関係演算子（ `<` 、 `>` 、 `>=` 、 `<=`、`==`、 `!=` ）の前後には空白文字を挿入する

* 算術演算子（ `＋` 、 `－` 、 `＊` 、 `/` 、 `%` ）の前後には空白文字を挿入する

* return 文ではカッコを使わない\
  良い例：

  ```java
  int answer = (a + b + c) * d;
  return answer;
  ```

  悪い例：

  ```java
  return ((a + b + c) * d);
  ```

* if などの条件式で boolean の変数を比較しない

  良い例：

  ```java
  if (hasStock)
  ```

  悪い例：

  ```java
  if (hasStock == true)
  ```

* 不等号の向きは左向き（ `<` 、 `<=` ）にする\
  良い例：

  ```java
  if (from <= x && x <= to) {
  ```

  悪い例：

  ```java
  if (x >= from && x <= to) {
  ```

## コメント

* ファイルの先頭への Copyright の表記について\
  ソースのファイルヘッダにコピーライト標記は法的拘束力がないため、不要とする。\
  ただし、顧客からの要求があった場合を除く。

* Javadoc コメントには、少なくとも author と version(クラス)、param と return と exception(メソッド)を記述する
  * 今後もバージョンアップのリリースが予定されているソースでは、上記に加えて since（バージョン）を記述する
  * `@Override`のあるメソッドでは、上記に加えて`{@Inherit}`を記述する

* Javadoc 　クラスヘッダコメントのフォーマットは以下の通り

  良い例：

  ```java
  /**
   * Action（or Bean）クラス　メニュー名称
   *
   * @author 姓 名
   * @version バージョン YYYY/MM/DD 説明
   */
  ```

* コメントは必要なものだけを簡潔に\
  悪い例：

  ```java
  /**
   * 文字列に変換
   */
  @Override
  public String toString() {

  /**
   * コピー
   *
   * @return コピーしたインスタンス
   */
  public Entry copy() {
  ```

* 不要なコメントは記載しない
  * コードからすぐわかること・冗長なコメント
  * 名前の説明\
    コメントではなくわかりやすい名前を付ける。
  * 別システムで管理している内容\
    ソースコード管理システム、バグトラッキングシステムで管理している内容はソースコードにコメントで記載する必要はない。
    * コメントアウトされたコード\
      ソースコード管理システムで管理されている

* サンプルコードを記載する場合は、`{@snippet}`タグを利用する。

  外部ファイルから引用する例：

  ```java
  /**
   * ユーザー登録処理の例
   * {@snippet file="UserRegistrationExample.java" region="registration"}
   */
  ```

  インラインでサンプルコードを記載する例：

  ```java
  /**
   * ユーザー登録処理の例
   * {@snippet :
   * User user = new User();
   * user.setName("田中太郎");
   * user.setEmail("tanaka@example.com");
   * userRepository.save(user);
   * }
   */
  ```

## インポート

* `java.lang`パッケージはインポートしない

  悪い例：

  ```java
  import java.lang.String;//必要のない記述
  ```

* 原則として static インポートしない\
  JUnit の作成やフレームワークとして static インポートが推奨されるような場合は利用してもよい

* 原則としてオンデマンドのインポート宣言(type-import-on-demand declaration)（アスタリスク`*`によるインポート） は行わない

  悪い例：

  ```java
  import java.util.*;
  ```

## コンストラクタ

* public 宣言していないクラスには`public`権限のコンストラクタを作らない\
  良い例：

  ```java
  class Entry {
      //・・・
      Entry(int id) {
          //・・・
      }
  ```

  悪い例：

  ```java
  class Entry {
      //・・・
      public Entry(int id) {
          //・・・
      }
  ```

* インスタンスメンバを持たない（static メンバのみの）クラスは、`private`権限のコンストラクタを作成する

## メソッド

* オーバーライドさせたくないメソッドは`final`を利用する

* 戻り値が配列のメソッドで、戻る配列のサイズが 0 の場合、メソッドを使用するクライアントの余計な null チェックのロジックを回避するため、null ではなく長さゼロの配列を戻すようにする。
  良い例：

  ```java
  public String[] toArray(String s) {
      if (s == null || s.isEmpty()) {
          return ArrayUtils.EMPTY_STRING_ARRAY;
      }
      return new String[] { s };
  }

  public List<String> toList(String s) {
      if (s == null || s.isEmpty()) {
          return Collections.emptyList();
      }
      return List.of(s);
  }
  ```

  悪い例：

  ```java
  public String[] toArray(String s) {
      if (s == null || s.isEmpty()) {
          return null;
      }
      return new String[] { s };
  }

  public List<String> toList(String s) {
      if (s == null || s.isEmpty()) {
          return null;
      }
      return List.of(s);
  }
  ```

* メソッドは 1 つの役割にする

## クラスメソッド

* クラスメソッドを利用するときは、クラス名を使って呼び出す\
  良い例：

  ```java
  int comp = Integer.compare(x, y);
  ```

  悪い例：

  ```java
  Integer a = //
  int comp = a.compare(x, y);
  ```

## 変数全般

* 1 つのステートメントには 1 つの変数宣言\
  良い例：

  ```java
  /** 科目コード */
  private String code;
  /** 科目名 */
  private String name;
  /** 科目略名 */
  private String shortName;
  ```

  悪い例：

  ```java
  private String code, name, shortName;
  ```

* リテラルは使用しない\
  リテラルとは、コード中に、表現が定数として直接現れており、記号やリストで表現することができないものを指す（数値、文字列両方含む　通称マジックナンバー）。コードの可読性・保守性の低下を防ぐために、リテラル定数（`static final` フィールド）を使用すること。\
  例外：`-1`,`0`,`1` 等をカウント値としてループ処理等で使用するような場合

  良い例：

  ```java
  private static final double ONE_MILE_METRE = 1609.344;

  public double mileToMetre(double mi) {
      return mi * ONE_MILE_METRE;
  }
  ```

  悪い例：

  ```java
  public double mileToMetre(double mi) {
      return mi * 1609.344;
  }
  ```

  * リテラル定数の名前はその値の意味を正しく表現したものにする

    悪い例：

    ```java
    private static final int ZERO = 0;
    ```

* 配列宣言は「`型名[]`」にする

  良い例：

  ```java
  private int[] sampleArray = new int[10];
  ```

  悪い例：

  ```java
  private int sampleArray[] = new int[10];
  ```

* できるだけローカル変数を利用する\
  ローカル変数で事足りるものをインスタンス変数として利用するなど、必要のないインスタンス変数を定義すると、パフォーマンスや可読性の低下やの大きな要因となる上、マルチスレッドを意識した際に不整合がおきる可能性があるので、インスタンス変数は必要性を充分に考慮してから使用すること。

* 定数は`final`で宣言する

* ローカル変数とインスタンス変数を使いわける

## 定数

* `public` で宣言するクラス変数とインスタンス変数は、定数のみとし、 `static final` で定義する\
  `final` ではない `static` な定数は作成しない。

  良い例：

  ```java
  public static final String PROTOCOL_HTTP = "http";
  ```

* 定数（ `static` フィールド）に、 `static` ではないメソッドから書き込まない

* 定数は、プリミティブ型もしくは、不変（Immutable）オブジェクトで参照する
  * 不変`List`の生成には`List.of()`を利用する

    良い例：

    ```java
    public static final List<Integer> VALUES = List.of(1, 2, 3, 4, 5);
    ```

    悪い例：

    ```java
    public static final List<Integer> VALUES = Arrays.asList(1, 2, 3, 4, 5);
    ```

  * 不変`Set`の生成には`Set.of()`を利用する

  * 不変`Map`の生成には`Map.of()`を利用する

    良い例：

    ```java
    public static final Map<Integer, String> VALUES_MAP = Map.of(1, "A", 2, "B", 3, "C");
    ```

    悪い例：

    ```java
    public static final Map<Integer, String> VALUES_MAP = new HashMap<>() {
        {
            put(1, "A");
            put(2, "B");
            put(3, "C");
        }
    };
    ```

  * 不変な配列インスタンスは長さ 0 の配列以外は生成不可能なため、外部から参照される（`public`）定数では利用せず、`List`等への置き換えをすること

    良い例：

    ```java
    public static final List<Integer> VALUES = List.of(1, 2, 3, 4, 5);
    ```

    悪い例：

    ```java
    public static final int[] VALUES = { 1, 2, 3, 4, 5 };
    ```

## インスタンス変数

* インスタンス変数は`private`にする

  良い例：

  ```java
  public class Employee {
      private long id;

      //・・・
      //getter/setter
  }
  ```

  悪い例：

  ```java
  public class Employee {
      public long id;

      //・・・
      //getter/setter
  }
  ```

## クラス変数

* `public static final` 宣言した配列を利用しない\
  ※「定数」を参照

* クラス変数にはクラス名を使用してアクセスすること

  良い例：

  ```java
  BigDecimal b = BigDecimal.ZERO;
  ```

  悪い例：

  ```java
  BigDecimal a = //
  BigDecimal b = a.ZERO;
  ```

## ローカル変数

* ローカル変数は利用する直前で宣言する\
  行間の程度にもよるが、ある程度まとめて宣言するのは OK とする。

  良い例：

  ```java
  for (int i = 0; i < lines.length; i++) {
      String line = lines[i];
      //lineの処理
  }
  ```

  悪い例：

  ```java
  String line;
  for (int i = 0; i < lines.length; i++) {
      line = lines[i];
      //lineの処理
  }
  ```

* ローカル変数は安易に再利用しない\
  一度宣言したローカル変数を、複数の目的で安易に使いまわさないこと。ローカル変数は、役割ごとに新しいものを宣言して初期化することにより、コードの可読性・保守性の向上、及びコンパイラの最適化の促進をはかる。

## 引数

* メソッド引数への代入は行わない\
  原則として`final`で宣言する。

  良い例：

  ```java
  public void add(final int value) {
      //・・・
  }
  ```

## 継承

* スーパークラスのインスタンス変数をサブクラスでオーバーライドしない\
  スーパークラスと同じ名前のフィールドをサブクラスで宣言しないこと。 同じ名前のフィールドを宣言すると、スーパークラスのフィールドはサブクラスで宣言されたフィールドによって隠ぺいされてしまうので、他の人の混乱を招くことを防ぐため重複する名前は付けないこと。

  悪い例：

  ```java
  public class Abs {
      protected String name;
  }

  public class Sub extends Abs {
      protected String name;//Abs#nameは隠ぺいされる
  }
  ```

* スーパークラスのメソッドをオーバーライドするときは@Override アノテーションを指定する。

  良い例：

  ```java
  public class Abs {
      protected void process() {

      }
  }

  public class Sub extends Abs {
      @Override
      protected void process() {

      }
  }
  ```

  悪い例：

  ```java
  public class Abs {
      protected void process() {

      }
  }

  public class Sub extends Abs {
      //@Overrideアノテーションの指定がない
      protected void process() {

      }
  }
  ```

* スーパークラスで private 宣言されているメソッドと同じ名前のメソッドをサブクラスで定義しない\
  スーパークラスにある private メソッドと同じ名前のメソッドをサブクラスで定義しないこと。private メソッドはオーバーライドされず全く別のメソッドとして扱われ、他の人の混乱を招き、バグにつながる恐れがある。

## インナークラス

* 原則としてインナークラスは利用しない\
  一つの java ファイルに複数のクラスを記載するのは NG とする。また無名クラスを利用するのも原則として NG とする。\
  Enum の定数固有メソッド実装(constant-specific method implementation)、Java8 のラムダ式は内部的にインナークラスとされるがこれらは許可する。

## メンバー順序

* 以下の順で記述する
  1. static フィールド
  2. static イニシャライザー
  3. static メソッド
  4. フィールド
  5. イニシャライザー
  6. コンストラクター
  7. メソッド

* 同一カテゴリー内では以下の可視性の順で記述する
  1. public
  2. protected
  3. パッケージ private
  4. private

## インスタンス

* オブジェクト同士は`equals()`メソッドで比較する

  良い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1.equals(s2)) {
      //・・・
  }
  ```

  悪い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1 == s2) {
      //・・・
  }
  ```

  ただし Enum の場合は`==`演算子を利用して比較する

  `equals()`メソッドで比較する際、左辺のオブジェクトが null にならないように制御すること。

* Class 名を利用した比較をおこなわない

  良い例：

  ```java
  if (o instanceof Foo f) {
      // ...
  }
  ```

  悪い例：

  ```java
  if ("my.Foo".equals(o.getClass().getName())) {
      Foo f = (Foo)o;
      // ...
  }
  ```

* インスタンスの型キャスト（Class キャスト）が必要な場合はパターンマッチングを使用する

  良い例：

  ```java
  if (o instanceof String s) {
      // ...
  }

  var str = (o instanceof BigDecimal b) ? b.toPlainString() : String.valueOf(o);

  var empty = o == null ||
    (o instanceof String s && s.isEmpty()) ||
    (o instanceof Collection c && c.isEmpty());
  ```

  悪い例：

  ```java
  if (o instanceof String) {
      String s = (String)o;
      // ...
  }

  var str = (o instanceof BigDecimal) ? ((BigDecimal)o).toPlainString() : String.valueOf(o);

  var empty = o == null ||
    (o instanceof String && ((String)o).isEmpty()) ||
    (o instanceof Collection && ((Collection)o).isEmpty());
  ```

* パターンマッチングについては[switch文・式で使用する](#switchでのパターンマッチング)ことも可能。

## 制御構造

* 制御文（ `if` , `else` , `while` , `for` , `do while` ）の `{ }` は省略しない

  良い例：

  ```java
  if (s == null) {
      return;
  }
  ```

  悪い例：

  ```java
  if (s == null)
      return;
  ```

* ステートメントが無い `{}` ブロックを利用しない\
  悪い例：

  ```java
  //{}内の記述が無い
  if (s == null) {
  }
  ```

* `if` / `while` の条件式で `=` は利用しない\
  良い例：

  ```java
  boolean a =//
  if (!a) {
      //・・・
  }
  ```

  悪い例：

  ```java
  boolean a =//
  if (a = false) {//コーディングミス
      //・・・
  }


  boolean a =//
  boolean b =//
  if (a = b) {//おそらくコーディングミス
      //・・・
  }
  ```

* `for` と `while` の使い分けを意識する

* for 文を利用した繰り返し処理中でループ変数の値を変更しない\
  悪い例：

  ```java
  String[] array = { /*・・・*/ };
  for (int i = 0; i < array.length; i++) {
      //・・・
      i += 2;//NG
  }

  for (String s : array) {
      //・・・
      s = "string";//NG
  }
  ```

* for 文のカウンタは特別な事情がない限り、0 から始める

* 配列やリストなどの全要素に対するループ処理は拡張 for 文を使用する。\
  良い例：

  ```java
  for (int value : array) {
      //・・・
  }

  for (String value : list) {
      //・・・
  }
  ```

* 配列をコピーするときは`Arrays.copyOf()`メソッドを利用する

  良い例：

  ```java
  int[] newArray = Arrays.copyOf(array, array.length);
  ```

  悪い例：

  ```java
  int[] newArray = new int[array.length];
  System.arraycopy(array, 0, newArray, 0, array.length);
  ```

* 繰り返し処理中のオブジェクトの生成は最小限にする

* if 文と else 文の繰り返しや switch 文の利用はなるべく避け、オブジェクト指向の手法を利用する\
  良い例：

  ```java
  CodingKind codingKind = toCodingKind(kind);
  d = codingKind.encode(s);

  //---

  CodingKind codingKind = toCodingKind(kind);
  s = codingKind.decode(d);
  ```

  悪い例：

  ```java
  switch (kind) {
  case 1 ->
      d = encode1(s);
  case 2 ->
      d = encode2(s);
  }

  //---

  switch (kind) {
  case 1 ->
      s = decode1(d);
  case 2 ->
      s = decode2(d);
  }
  ```

* 繰り返し処理の内部で `try` ブロックを利用しない\
  特に理由がない場合は繰り返し処理の外に`try`ブロックを記載する。\
  ただし、繰り返し処理内部で例外をキャッチし処理を行いたい場合は繰り返し処理の内部で`try`ブロックを利用してもよい。

  良い例：

  ```java
  for (String s : array) {
      BigDecimal num;
      try {
          num = new BigDecimal(s);
      } catch (NumberFormatException e) {
          num = BigDecimal.ZERO;
      }
      //・・・
  }
  ```

## 文字列操作

* 文字列同士が同じ値かを比較するときは、`equals()`メソッドを利用する\
  良い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1.equals(s2)) {
      //・・・
  }
  ```

  悪い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1 == s2) {
      //・・・
  }
  ```

* 文字列リテラルは`new` しない\
  良い例：

  ```java
  String s = "";
  ```

  悪い例：

  ```java
  String s = new String();
  ```

* 更新される文字列には`StringBuilder` クラスを利用する\
  良い例：

  ```java
  StringBuilder builder = new StringBuilder();
  for (String s : array) {
      builder.append(s);
  }
  System.out.println(builder.toString());
  ```

  悪い例：

  ```java
  String string = "";
  for (String s : array) {
      string += s;
  }
  System.out.println(string);
  ```

  [※パフォーマンスについても記載しているので参考にしてください](#文字列連結)

* １ステートメントのみで行われる文字列の連結には`+`演算子を利用する

  良い例：

  ```java
  String s = s1 + s2;

  return s1 + s2 + s3 + s4 + s5;
  ```

  悪い例：

  ```java
  String s = new StringBuilder(s1).append(s2).toString();

  return new StringBuilder(s1).append(s2).append(s3).append(s4).append(s5).toString();
  ```

* 更新されない文字列には`String` クラスを利用する

* 文字列リテラルと定数を比較するときは、文字列リテラルの`equals()`メソッドを利用する\
  良い例：

  ```java
  private static final String PROTOCOL_HTTP = "http";

  if (PROTOCOL_HTTP.equals(url.getProtocol())) {

  }
  ```

  悪い例：

  ```java
  private static final String PROTOCOL_HTTP = "http";

  if (url.getProtocol().equals(PROTOCOL_HTTP)) {

  }
  ```

* プリミティブ型と`String` オブジェクトの変換には、変換用のメソッドを利用する\
  良い例：

  ```java
  int i = 1000;
  String s = String.valueOf(i);// "1000"
  s = NumberFormat.getNumberInstance().format(i);// 3桁区切り "1,000"

  boolean b = true;
  s = String.valueOf(b);// true/false
  s = BooleanUtils.toStringOnOff(b);// on/off
  ```

* 文字列の中に、ある文字が含まれているか調べるには、`contains()`メソッドを利用する

* システム依存記号（ `\n` 、 `\r` など）は使用しない。\
  悪い例：

  ```java
  String text = Arrays.stream(array)
      .collect(Collectors.joining("\n"));
  ```

## 数値

* 誤差の無い計算をするときは、`BigDecimal` クラスを使う\
  浮動小数点演算は科学技術計算に利用するもので、誤差が発生する。これに対して、クラス「`BigDecimal`」は、文字列で数値の計算を行うので、金額などの正確な計算に適している。`BigDecimal` ではインスタンス生成時に指定された桁数での精度が保証される。

* 数値の比較は精度に気をつける\
  良い例：

  ```java
  BigDecimal a = new BigDecimal("1");
  BigDecimal b = new BigDecimal("1.0");
  if (a.compareTo(b) == 0) {
      System.out.println("一致");
  }
  ```

  悪い例：

  ```java
  BigDecimal a = new BigDecimal("1");
  BigDecimal b = new BigDecimal("1.0");

  if (a.equals(b)) {
      System.out.println("精度が違うためこの分岐には入らない");
  }
  ```

* 低精度なプリミティブ型にキャストしない

* `BigDecimal`を`String`変換する際は`toString()`ではなく`toPlainString()`を利用すること\
  `toString()`を利用した場合、指数表記になることがあります。

## 日付

* 日付の文字列のフォーマットには、`SimpleDateFormat`または`DateTimeFormatter`を使う\
  良い例：

  ```java
  Date date = new Date();
  SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
  String s = dateFormat.format(date);
  ```

## 三項演算子

* 入れ子の三項演算子の利用は禁止\
  可読性が悪くなるので三項演算子を入れ子で行うのは禁止。

## switch 式

* 一つの値を変数に代入するための if-else 文は代わりに switch 式の使用を推奨する\
  switch 式の値を使用することで変数を不変（実質的 final）にでき、代入箇所が分散することによる可読性の低下を防げます。

  良い例：

  ```java
  var value = switch (op) {
      case "add" -> a + b;
      default -> a - b;
  };
  ```

  悪い例：

  ```java
  int value;
  if (op.equals("add")) {
      value = a + b;
  } else {
      value = a - b;
  }
  ```

* case 句はなるべく一つの式での記述を推奨する\
  複雑な式や複雑なステートメントを記述しなければならない場合は、メソッドに分割することを検討してください。

* switch 式は、コーディングミスによるフォールスルーを避けるため、常にアロー構文を使用する\
  <https://docs.oracle.com/javase/jp/16/language/switch-expressions.html>からの引用：

  > ノート:`case L ->`ラベルの使用をお薦めします。`case L:`ラベルの使用時は、`break`文または`yield`文の挿入を忘れがちです。これを忘れると、コード内で思いがけないフォール・スルーが発生する場合があります。
  > `case L ->`ラベルで、複数の文または式でないコード、あるいは`throw`文を指定するには、それらをブロック内に囲みます。`case`ラベルが生成する値を`yield`文で指定します。

  良い例：

  ```java
  var date = LocalDate.now();
  var off = switch (date.getDayOfWeek()) {
      case MONDAY -> {
          if (myCalendar.isOff(date) || localCalendar.isHoliday(date)) {
              yield true;
          }
          yield localCalendar.isHoliday(date.minusDays(1));
      }
      case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY ->
          myCalendar.isOff(date) || localCalendar.isHoliday(date);
      case SUNDAY, SATURDAY -> true;
  };
  ```

  悪い例：

  ```java
  var date = LocalDate.now();
  var off = switch (date.getDayOfWeek()) {
      case MONDAY:
          if (myCalendar.isOff(date) || localCalendar.isHoliday(date)) {
              yield true;
          }
          yield localCalendar.isHoliday(date.minusDays(1));
      case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY:
          yield myCalendar.isOff(date) || localCalendar.isHoliday(date);
      case SUNDAY, SATURDAY:
          yield true;
  };
  ```

* アロー構文の、中カッコ、`yield`を省略できる場合は必ず省略する\
  良い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  var shortDay = switch (day) {
      case MONDAY -> "M";
      case WEDNESDAY -> "W";
      case FRIDAY -> "F";
      case TUESDAY, THURSDAY -> "T";
      case SUNDAY, SATURDAY -> "S";
  };
  ```

  悪い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  var shortDay = switch (day) {
      case MONDAY -> {
          yield "M";
      }
      case WEDNESDAY -> {
          yield "W";
      }
      case FRIDAY -> {
          yield "F";
      }
      case TUESDAY, THURSDAY -> {
          yield "T";
      }
      case SUNDAY, SATURDAY -> {
          yield "S";
      }
  };
  ```

* Enum 値の switch 式で case 句が全ての Enum 値をカバーする場合は default 句はデッドコードとなるため記述しない\
  良い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  var off = switch (day) {
      case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> false;
      case SUNDAY, SATURDAY -> true;
  };

  var day = DayOfWeek.SUNDAY;
  var off = switch (day) {
      case SUNDAY, SATURDAY -> true;
      default -> false;
  };
  ```

  悪い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  var off = switch (day) {
      case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> false;
      case SUNDAY, SATURDAY -> true;
      default -> false;
  };
  ```

## switch 文

* 代わりに switch 式が使用できる箇所は switch 式を使用する
  * case 句で`return`を記述する場合は switch 文を使用して良い

* case 句はなるべく 1 行のステートメントでの記述を推奨する\
  複雑なステートメントを記述しなければならない場合は、メソッドに分割することを検討してください。

* switch 文は、コーディングミスによるフォールスルーを避けるため、なるべくアロー構文を使用することを推奨する\
  <https://docs.oracle.com/javase/jp/16/language/switch-expressions.html>からの引用：

  > ノート:`case L ->`ラベルの使用をお薦めします。`case L:`ラベルの使用時は、`break`文または`yield`文の挿入を忘れがちです。これを忘れると、コード内で思いがけないフォール・スルーが発生する場合があります。
  > `case L ->`ラベルで、複数の文または式でないコード、あるいは`throw`文を指定するには、それらをブロック内に囲みます。`case`ラベルが生成する値を`yield`文で指定します。

  良い例：

  ```java
  var date = LocalDate.now();
  switch (date.getDayOfWeek()) {
      case MONDAY -> {
          if (
              !myCalendar.isOff(date) && !localCalendar.isHoliday(date) &&
              !localCalendar.isHoliday(date.minusDays(1))
          ) {
              work();
          }
      }
      case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> {
          if (!myCalendar.isOff(date) && !localCalendar.isHoliday(date)) {
              work();
          }
      }
  }
  ```

  悪い例：

  ```java
  var date = LocalDate.now();
  switch (date.getDayOfWeek()) {
      case MONDAY:
          if (
              !myCalendar.isOff(date) && !localCalendar.isHoliday(date) &&
              !localCalendar.isHoliday(date.minusDays(1))
          ) {
              work();
          }
          break;
      case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY:
          if (!myCalendar.isOff(date) && !localCalendar.isHoliday(date)) {
              work();
          }
          break;
  }
  ```

* アロー構文を使用しない（コロンを使用する）場合、複数の値をマッチさせるときの case 句はカンマを使用して列挙する\
  良い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  boolean off = false;
  switch (day) {
      case SUNDAY, SATURDAY:
          off = true;
          break;
  };
  ```

  悪い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  boolean off = false;
  switch (day) {
      case SUNDAY:
      case SATURDAY:
          off = true;
          break;
  };
  ```

## switchでのパターンマッチング

* `instanceof`ではなく`switch`文や式に拡張されたパターンマッチングで記載する。

  良い例：

  ```java
  static String formatterPatternSwitch(Object obj) {
      return switch (obj) {
          case Integer i -> String.format("int %d", i);
          case Long l    -> String.format("long %d", l);
          case Double d  -> String.format("double %f", d);
          case String s  -> String.format("String %s", s);
          default        -> Objects.toString(obj);
      };
  }
  ```

  悪い例：

  ```java
  static String formatter(Object obj) {
      String formatted = "unknown";
      if (obj instanceof Integer i) {
          formatted = String.format("int %d", i);
      } else if (obj instanceof Long l) {
          formatted = String.format("long %d", l);
      } else if (obj instanceof Double d) {
          formatted = String.format("double %f", d);
      } else if (obj instanceof String s) {
          formatted = String.format("String %s", s);
      }
      return formatted;
  }
  ```

## コレクション

* Java2 以降のコレクションクラスを利用する\
  `Vector` クラス、`Hashtable` クラス、`Enumeration` 等は、特にこれらを利用する理由がなければ、インターフェースを統一する目的で、これらの代わりに`List`(`ArrayList` クラス)、`Map`(`HashMap` クラス)、`Iterator` を使用すること。`List` などのインターフェースを利用することで JDK1.2 で整理されたわかりやすいメソッドを利用でき、また、インターフェースの特性から呼び出し元を変更せずに実装クラスを変更することができる。

* 特定の型のオブジェクトだけを受け入れるコレクションクラスを利用する

  良い例：

  ```java
  List<Map<String, String>> list = new ArrayList<>();
  ```

* `List`のソートは`List.sort()`を利用する\
  `List`クラスの要素をソートする際は Java8 で追加された`List.sort()`を利用すること。\
  Java 7 以前で利用されていた`Collections.sort()`は利用しないこと。

* `Collection.forEach()`は利用しない。拡張 for 文の利用を検討する\
  Java8 で追加されたメソッド。\
  拡張 for 文を利用したほうが多くの場合でデバッグに有利であり、可読性においても`forEach`の優位性は少ないため、`forEach`は原則利用しない。拡張 for 文を利用する。\
  具体的には下記のメソッドを利用しないこと。

  * `Collection#forEach`
  * `Set#forEach`
  * `List#forEach`

  ※ `Map#forEach`はこの限りではない

  良い例：

  ```java
  for (String s : List.of("A", "B")) {
      //処理
  }
  ```

  悪い例：

  ```java
  List.of("A", "B").forEach(s -> {
      //処理
  });
  ```

  ただし、メソッド参照で処理できる場合は`forEach`を利用する。\
  （デバッグのデメリットがほとんどなく、他と比較して処理効率が良いため）

  良い例：

  ```java
  List.of("A", "B").forEach(this::process);
  ```

  悪い例：

  ```java
  for (String s : List.of("A", "B")) {
      this.process(s);
  }
  ```

* `Arrays.asList()`は利用せず、`List.of()`を利用する\
  Java9 で追加されたメソッド。\
  配列を`List`に置き換える場合や、単純な固定の`List`を生成する際には`List.of()`を利用する。
  * `Arrays.asList()`と`List.of()`の違い\
    `List.of()`で生成した`List`は、完全に不変（Immutable）な`List`で、\
    `Arrays.asList()`で生成した`List`は、サイズのみ不変で、`set`等による値の操作が可能な`List`です。\
    また、`set`を行った場合、`Arrays.asList()`に与えられた配列インスタンスにも影響します。

## 順序を保持するコレクション

* 要素の順序に関する操作（最初の要素や最後の要素へのアクセス、追加、削除、逆順処理など）には、`SequencedCollection`、`SequencedSet`、`SequencedMap` インターフェースで定義された**専用のメソッド**（`getFirst()`、`getLast()`、`addFirst()`、`addLast()`、`removeFirst()`、`removeLast()`、`reversed()`、`putFirst()`、`putLast()`、`firstEntry()`、`lastEntry()` ）の使用を推奨する。従来の記述と専用メソッドで性能面の違いはないので、どちらを使用するか各プロジェクトで揺れがないように統一する。

  良い例：

  ```java
  import java.util.SequencedCollection;
  import java.util.ArrayList;

  SequencedCollection<String> items = new ArrayList<>();
  items.addFirst("A");
  items.addLast("B");
  String firstItem = items.getFirst();
  String lastItem = items.getLast();
  SequencedCollection<String> reversedItems = items.reversed();
  ```

  悪い例：

  ```java
  import java.util.List;
  import java.util.ArrayList;
  import java.util.Collections;

  List<String> items = new ArrayList<>();
  items.add(0, "A");
  items.add("B");
  String firstItem = items.get(0);
  String lastItem = items.get(items.size() - 1);
  List<String> reversedItems = new ArrayList<>(items);
  Collections.reverse(reversedItems);
  ```

  ※ `reversed()`で取得されるのは元のインスタンスの参照であるため、要素を変更すると元のインスタンスに反映されることに注意。

* 大量の要素に対する先頭や末尾への頻繁な追加・削除操作は、`ArrayList` のような実装では要素のシフトが発生するため、パフォーマンスに影響を与える可能性があります。このような場合は、`LinkedList` や `ArrayDeque` など、**両端の操作が効率的な実装**を選択することを検討してください。

## ラムダ式・メソッド参照・コンストラクタ参照

* ラムダ式が利用できる箇所はラムダ式を利用してよい\
  [※パフォーマンスについても記載しているので参考にしてください](#ラムダ式メソッド参照コンストラクタ参照-1)

* ただし、メソッド参照・コンストラクタ参照が利用できる場合はメソッド参照・コンストラクタ参照を利用する

  良い例：

  ```java
  String::compareToIgnoreCase
  ```

  悪い例：

  ```java
  (s1, s2) -> s1.compareToIgnoreCase(s2)
  ```

  良い例：

  ```java
  BigDecimal::add
  ```

  悪い例：

  ```java
  (b1, b2) -> b1.add(b2)
  ```

* ラムダ式記述の際、型宣言は省略記法で記述する

  良い例：

  ```java
  (s1, s2) -> s1 + "=" + s2
  ```

  悪い例：

  ```java
  (String s1, String s2) -> s1 + "=" + s2
  ```

* 原則ラムダ式内の行数は 1 行とする\
  複数行で利用したい場合は、`private`メソッドを作成しメソッド参照を利用する

  良い例：

  ```java
  this::getMax

  private int getMax(int i1, int i2) {
      if (i1 > i2) {
          return i1;
      } else {
          return i2;
      }
  }
  ```

  悪い例：

  ```java
  (i1, i2) -> {
      if (i1 > i2) {
          return i1;
      } else {
          return i2;
      }
  }
  ```

* 原則ラムダ式は 1 行記述に限定するので、中カッコ、`return`は必ず省略する

  良い例：

  ```java
  (s1, s2) -> s1 + "=" + s2
  ```

  悪い例：

  ```java
  (s1, s2) -> {
      return s1 + "=" + s2;
  }
  ```

## 実質的 final（effectively final）

* 実質的 final を利用する\
  変数宣言に`final`を記載しなくてよい。

## Stream API

* 利用してよい\
  [※パフォーマンスについても記載しているので参考にしてください](#stream-api-2)

* 並列ストリームは利用しないこと\
  悪い例：

  ```java
  Stream<?> s = list.parallelStream();
  Stream<?> s = list.stream().parallel();
  ```

* StreamAPI 記述の際の改行位置は、各中間処理・末端処理前のピリオドの前で改行する

  良い例：

  ```java
  List<Character> alphabetLower = list.stream()
      .filter(Character::isAlphabetic)
      .map(Character::toLowerCase)
      .toList();
  ```

  悪い例：

  ```java
  List<Character> alphabetLower = list.stream().filter(Character::isAlphabetic)
      .map(Character::toLowerCase).toList();

  List<Character> alphabetLower = list
      .stream()
      .filter(Character::isAlphabetic)
      .map(Character::toLowerCase)
      .toList();
  ```

* インデントは統合開発環境の提供するフォーマッタに合わせる

* 中間処理の数は 3 つ（3 行）程度までを推奨する\
  中間処理の記述が多くなると可読性も悪くなり、デバッグも難しくなるため、3 行程度を目安にロジックを検討すること。

* コメントは、原則として処理中には記載しない\
  難解になってしまった場合のみ処理中の記載を認める

  良い例：

  ```java
  // クラスFooのフィールドStrの値で昇順にソートし、フィールドStrの要素を取得して処理する。
  fooList.stream()
      .sorted(Comparator.comparing(Foo::getStr))
      .map(Foo::getStr)
      .forEach(this::proc);
  ```

  悪い例：

  ```java
  fooList.stream()
      .sorted(Comparator.comparing(Foo::getStr)) //クラスFooのフィールドStrの値で昇順にソート
      .map (Foo::getStr) //フィールドStrの要素を取得
      .forEach(this::proc); //処理


  fooList.stream()
      //クラスFooのフィールドStrの値で昇順にソート
      .sorted(Comparator.comparing(Foo::getStr))
      //フィールドStrの要素を取得
      .map (Foo::getStr)
      //処理
      .forEach(this::proc);
  ```

* Stream は極力変数代入しないこと\
  Stream は中間処理、末端処理を行うと使用済みとなり、以降同じインスタンスは利用できない。\
  変数代入はほとんどの場合意味をなさず、むしろミスの元となるため極力変数代入はしないこと。

  良い例：

  ```java
  List<String> list1 = Stream.of("A", "B", "C")
          .map(String::toLowerCase)
          .toList();

  List<String> list2 = Stream.of("A", "B", "C")
          .map(s -> s + s)
          .toList();
  ```

  悪い例：

  ```java
  Stream<String> stream = Stream.of("A", "B", "C");
  Stream<String> stream1 = stream.map(String::toLowerCase);
  List<String> list1 = stream1.toList();

  Stream<String> stream2 = stream.map(s -> s + s);//コーディングミス streamは使用済のためエラーになる
  List<String> list2 = stream2.toList();
  ```

## Optional

* Optional は同メソッド内で値を取り出す場合は極力変数代入しないこと\
  Optional とその値の変数は同じものを示す名前となり、同じ意味の変数名が複数現れることで可読性が下がるため、Optional の変数代入は行わないこととする。

  良い例：

  ```java
  Employee employee = findEmployee(employeeId)
          .orElseThrow(IllegalArgumentException::new);
  ```

  悪い例：

  ```java
  Optional<Employee> employeeOpt = findEmployee(employeeId);
  Employee employee = employeeOpt.orElseThrow(IllegalArgumentException::new);
  ```

  良い例：

  ```java
  Optional<Employee> employee = findEmployee(employeeId);

  Dept dept = employee.map(Employee::getDivision)
          .map(Division::getDept)
          .orElse(null);

  Role role = employee.map(Employee::getRole)
          .orElse(null);

  //-----

  Optional<Employee> employee = findEmployee(employeeId);
  //・・・処理
  return employee;
  ```

## var (Local-Variable Type Inference)

次のリンクも参考にしてください。\
[Style Guidelines for Local Variable Type Inference in Java](https://openjdk.java.net/projects/amber/LVTIstyle.html)

* 明確な方針で、利用する・利用しないを統一すること\
  方針無く、`var`を混在させるとソースコードの見通しと保守性が悪くなります。\
  各プロジェクトで、例えば以下ののような方針で統一してください。

  1. `var`を利用しない
  2. 原則`var`を利用する
  3. 右辺で、明確に型がわかる場合は`var`を利用する

  以下で`2`、`3`について例を示します。

  * 原則`var`を利用する

    利用できる箇所は全て`var`を利用します。

    良い例：

    ```java
    var a = "";
    var b = 123;
    var c = new ArrayList<String>();
    ```

    悪い例：

    ```java
    var a = "";
    int b = 123;
    List<String> c = new ArrayList<>();
    ```

    ```java
    void methodA() {
        var a = "";
    }
    void methodB() {
        String a = "";
    }
    ```

  * 右辺で、明確に型がわかる場合は`var`を利用する

    右辺をみて型がわかる場合は、全て`var`を利用します。
    それ以外は`var`を利用してはいけません。

    良い例：

    ```java
    var s = ""; // リテラルによって型が明確に判断できます
    var list1 = new ArrayList<String>(); // newによって型が明確に判断できます
    var list2 = (List<String>) map.get("p"); // キャストによって型が明確に判断できます
    var list3 = List.of("A", "B", "C"); // ファクトリーによって型が明確に判断できます
    ```

    プロジェクトで観点を決めるべき例：

    ```java
    var b1 = s.isEmpty(); // `is`で始まるメソッドは通例としてbooleanを返します
    var b2 = Objects.equals(s1, s2); // `equals`メソッドは通例としてbooleanを返します
    var i1 = Objects.hash(s); // `hash`、`hashCode`メソッドは通例としてintを返します
    var i2 = Objects.compare(s1, s2); // `compare`、`compareTo`メソッドは通例としてintを返します
    ```

    悪い例：

    ```java
    var a = e.getData(); // `e`の型と、メソッド定義がわからなければ型が判断できません
    ```

## レコード

* 明確な方針で、利用する・利用しないを統一すること\
  方針無く、`record`とクラスと JavaBeans 形式のクラスや Lombok の @Data の使用を混在させるとソースコードの見通しと保守性が悪くなります。\
  各プロジェクトで、`record`を利用しないか、`record`の使用しても良い箇所について方針を決めた上で使用するようにしてください。
  また、`record`は JavaBeans とは互換性がないため使用している各種ライブラリの対応状況にも注意する必要があります。

  方針例： クラス内で処理する一時的なデータを表現するためだけに`record`を使用しても良い。

  ```java
  // parentId と id をキーとして、重複を排除した uniqueItems を作成します。
  record Key(int parentId, int id) {
  }
  var map = new HashMap<Key, Item>();
  for (Item item : items) {
    var key = new Key(item.getParenId(), item.getId());
    map.putIfAbsent(key, item);
  }
  var uniqueItems = map.values();
  ```

* 次の記述スタイルを標準とする\
  ただし、フォーマッタを導入している場合はフォーマッタに合わせます。

  良い例：

  ```java
  /**
   * 矩形を表すクラス
   *
   * @param x      矩形の左上隅の x 座標
   * @param y      矩形の左上隅の y 座標
   * @param width  矩形の幅
   * @param height 矩形の高さ
   */
  public record Rect(
      /* 矩形の左上隅の x 座標 */
      double x,
      /* 矩形の左上隅の y 座標 */
      double y,
      /* 矩形の幅 */
      double width,
      /* 矩形の高さ */
      double height) {
  }
  ```

  次にポイントを説明します。

  * `{`の後、`}`の前に改行する

  * レコードコンポーネント（パラメータ）のカンマの後に改行することを推奨する\
    レコードコンポーネントが少なく、レコードコンポーネント名からでも意味が理解でき、改行がなくても可読性が低下しない場合は、改行を必要としません。\
    改行を推奨する理由は以下です。
    * アノテーションを付与したときでも比較的読みやすい（アノテーション引数との混在による可読性の低下の回避）
    * レコードコンポーネントが多い場合も比較的読みやすい

  * レコードコンポーネントが多い場合、レコードコンポーネントへ直接コメントをつけることを検討する\
    レコードコンポーネントの JavaDoc としては`@param`形式でレコード名の上部に記述しますが、このソースコードをテキストとしてみた場合、レコードコンポーネントの定義と`@param`の説明とで距離が空いてしまう場合があり、型と説明を読むのに時間がかかってしまう可能性があります。\
    また、使用する IDE によっては、アクセサから宣言へのジャンプを使用すると、レコードコンポーネント（パラメータ）の定義へジャンプするものがあります。レコードコンポーネントにコメントがあればすぐに説明を読むことができますが、JavaDoc しか記述しない場合は、ファイル上部へ移動して対応するレコードコンポーネントの説明を探さなければなりません。

    ```java
    public record Rect(
        /* 矩形の左上隅の x 座標 */
        double x,
        /* 矩形の左上隅の y 座標 */
        double y,
        /* 矩形の幅 */
        double width,
        /* 矩形の高さ */
        double height) {
    }
    ```

* レコードのアクセサを上書きしない

  悪い例：

  ```java
  public record Rect(
      double x,
      double y,
      double width,
      double height) {

      public double x() {
          return x;
      }
  }
  ```

## レコードパターン

* レコードパターンは、データの分解と型チェックを同時に行えるため、冗長なコードの削減、型安全性の向上、IDEによる補完やリファクタリング支援などのメリットがあります。\
  これにより、コードの可読性・保守性・安全性が高まるため、レコードを使用する場合はレコードパターンを用いて記述することを推奨します。

  良い例：

  ```java
  static void execute(Object obj) {
      if (obj instanceof Point(int x, int y)) {
          System.out.println(x + y);
      }
  }
  ```

  悪い例：

  ```java
  if (obj instanceof Point p) {
          int x = p.x();
          int y = p.y();
          System.out.println(x+y);
      }
  ```

## シールクラス

* 明確な方針で、利用する・利用しないを統一すること\
  方針無く、`sealed`を利用するとコードの保守性や柔軟性が悪くなります。\
  各プロジェクトで、`sealed`を利用しないか、`sealed`を利用しても良い箇所について方針を決めた上で使用するようにしてください。

  方針例：

  * プロジェクト内で使用する共通機能ライブラリに限定して使用する
  * 外部公開APIでは禁止し、内部ユーティリティやドメイン層のみ許可する
  * サードパーティ連携部分では利用しない
  * 全体で利用しない
    など、用途や公開範囲に応じて具体的な方針を決めてください。

  **【補足：シールクラス（sealed classes）とは】**\
  Javaのsealedクラスは、継承できるサブクラスを明示的に制限する仕組みです。\
  これにより、ドメインモデルの制約強化やパターンマッチングの網羅性チェックが可能となり、意図しない拡張や誤用を防ぐことができます。\
  典型的な利用例としては、状態や種類が限定されるドメイン（例：イベント種別、計算式のノード型など）の表現や、パターンマッチング（switch文・式）で全ケースを網羅的に扱いたい場合などが挙げられます。\
  メリットは安全性・可読性の向上ですが、柔軟な拡張が難しくなるデメリットもあるため、利用方針を明確に定めてください。

## テキストブロック

次のリンクも参考にしてください。\
[Programmer's Guide To Text Blocks > Style Guidelines For Text Blocks](https://docs.oracle.com/en/java/javase/17/text-blocks/index.html#style-guidelines-for-text-blocks)

* 複数行の文字列を定義する際、文字列連結よりもテキストブロックを使用する

  良い例：

  ```java
  String message = """
          複数行の文字列はテキストブロックを使用しましょう。
          文字列連結と違い、プラス記号や改行コードのエスケープシーケンスのような無駄を排除でき、
          より読みやすいソースコードで書くことができます。
          """;
  ```

  悪い例：

  ```java
  String message =
          "複数行の文字列はテキストブロックを使用しましょう。\n" +
          "文字列連結と違い、プラス記号や改行コードのエスケープシーケンスのような無駄を排除でき、\n" +
          "より読みやすいソースコードで書くことができます。\n";
  ```

* 単一行の文字列を定義する際、テキストブロックは使用せず文字列リテラルを使用する\
  ただし、二重引用符(`"`)のエスケープを避ける目的ではテキストブロックを使用しても良い。

  良い例：

  ```java
  String singleLine = "単一行の文字列です。";

  String message = """
          テキストブロックでは単一の二重引用符「"」にエスケープを使用する必要がありません。""";
  ```

  悪い例：

  ```java
  String singleLine = """
          単一行の文字列です。""";
  ```

* テキストブロック内では基本的に改行コードのエスケープシーケンス(`\n`)を使用しないが、読みやすさ向上の目的で改行コードのエスケープシーケンス(`\n`)を使用しても良い

  良い例：

  ```java
  String multiLine = """
          複数行の、
          文字列です。
          """;

  String csv = """
          名前,説明,MIMEタイプ
          CSV,"Comma-Separated Valuesの略\nCharacter-Separated Valuesの意味で使用されることもある","text/csv"
          TSV,"Tab-Separated Valuesの略","text/tab-separated-values"
          """;
  ```

  悪い例：

  ```java
  String multiLine = """
          複数行の、\n文字列です。
          """;
  ```

* テキストブロックで定義した文字列を処理する場合は、テキストブロックをローカル変数やフィールドへ代入してから使用することを推奨する

  良い例：

  ```java
  String selectX = """
          SELECT
              ID,
              NAME
          FROM
              TABLE_X
          """;
  String selectY = """
          SELECT
              ID,
              NAME
          FROM
              TABLE_Y
          """;
  processValues(fetch(selectX, Entity1.class), fetch(selectY, Entity2.class));
  ```

  悪い例：

  ```java
  processValues(fetch("""
          SELECT
              ID,
              NAME
          FROM
              TABLE_X
          """, Entity1.class), fetch("""
          SELECT
              ID,
              NAME
          FROM
              TABLE_Y
          """, Entity2.class));
  ```

  複雑な処理に直接テキストブロックを使用すると可読性を下げる可能性があります。

* 3 つ以上続く二重引用符(`"`)をエスケープする際は、最初の二重引用符にエスケープシーケンスを使用する

  良い例：

  ```java
  String javaCode = """
          String message = \"""
                  テキストブロックです。
                  \""";
          System.out.println(message);
          """;
  ```

  悪い例：

  ```java
  String javaCode = """
          String message = \"\"\"
                  テキストブロックです。
                  \"\"\";
          System.out.println(message);
          """;

  String javaCode = """
          String message = ""\"
                  テキストブロックです。
                  ""\";
          System.out.println(message);
          """;
  ```

* テキストブロックの開始引用符(`"""`)は前の行の右端に記述する

  良い例：

  ```java
  String message = """
          テキストブロックです。
          """;
  ```

  悪い例：

  ```java
  String message =
          """
          テキストブロックです。
          """;
  ```

* テキストブロックのインデントは開始引用符(`"""`)に合わせる必要はない

  良い例：

  ```java
  String message = """
          テキストブロックです。
          """;
  ```

  悪い例：

  ```java
  String message = """
                   テキストブロックです。
                   """;
  ```

  一見すると、読みやすく見えるかもしれませんが、変数名の変更によって簡単に崩れてしまい、修正するために多くの行の変更を強制することになるため、メンテナンス性が低下します。

* テキストブロックで定義する文字列のインデントは基本的に周辺の Java コードに合わせてインデントする\
  ただし、横に長い文字列などの可読性向上の目的で左端に揃えるのは良い。

  良い例：

  ```java
  public class Foo {
      public void process() {
          String message = """
                  テキストブロックです。
                  """;
      }
  }
  ```

  悪い例：

  ```java
  public class Foo {
      public void process() {
          String message = """
      テキストブロックです。
      """;
      }
  }
  ```

  良い例：

  ```java
  public class Foo {
      public void process() {
          if (foo) {
              String message = """
  それはもう長い長いテキストブロックのためインデントするとエディタ上でテキストを見るためには横スクロールが必要になるかもしれません。
  """;
          }
      }
  }
  ```

  悪い例：

  ```java
  public class Foo {
      public void process() {
          if (foo) {
              String message = """
                      それはもう長い長いテキストブロックのためインデントするとエディタ上でテキストを見るためには横スクロールが必要になるかもしれません。
                      """;
          }
      }
  }
  ```

* テキストブロックのインデントにスペース文字とタブ文字を混在させない

* 文字列の最後に改行コードを入れずに、意図的にインデントした文字列を定義するとき終了引用符(`"""`)の前の行の右端に`\`を使用する

  良い例：

  ```java
  String text = """
              ABC
              DEF
              GHI\
          """;
  ```

  悪い例：

  ```java
  String text = """
          ABC
          DEF
          GHI""".indent(4);
  ```

## ストリーム（InputStream OutputStream）

* ストリームを扱う API を利用するときは、try-with-resources 文で後処理をする

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //inputStreamに対する処理を記載
  }
  ```

* `ObjectOutputStream` では`reset()`を利用する

## リソースの解放

* リソース解放を必要とするクラスを利用するときは、try-with-resources 文で後処理をする

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //inputStreamに対する処理を記載
  }
  ```

* リソース解放を必要とするクラスを作成する場合は`AutoCloseable`を`implements`する\
  `AutoCloseable`を`implements`することで try-with-resources 文が利用できるようになります。

## 例外

* catch 文で受け取る例外は、詳細な例外クラスで受け取る

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //・・・
  } catch (IOException e) {
      log.error("Error", e);
      throw e;
  }
  ```

  悪い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //・・・
  } catch (Exception e) {//範囲が広すぎる例外クラスの利用はNG
      log.error("Error", e);
      throw e;
  }
  ```

* `Exception` クラスのオブジェクトを生成してスローしない

* `catch` ブロックでは基本、例外処理をする。ただし処理を書いてはいけない部分もあるので、その部分については、"`// ignore`" というコメントを記述すること。

* 例外クラスは無駄に定義しない

## ガベージコレクション

* 原則`finalize()`のオーバーライド実装は禁止
* もし`finalize()`をオーバーライドした場合は`super.finalize()` を呼び出す
* アプリケーションから`finalize()`を呼び出さない

# コメント規約

## よいコメントの鉄則

* コードを明確化するコメントを書く\
  コードにコメントを書く理由は、自分自身、一緒に仕事をしている人、後に関わる開発者にとってコードをより理解しやすいものにするためである。

* コメント化する価値がないプログラムならば、実行するに値しない\
  有用な格言。コメントは必須。

* 過剰な装飾は使わない （例：見出し状のコメント）\
  1960 年代から 1970 年代の典型的な COBOL プログラマにはアスタリスク( `*` )でコメントを囲った箱を書く習慣があった。彼らの芸術的な主張を表わしているのかもしれないが、率直に言えばそれは製品に加わるちょっとした価値に比べれば大きな時間の無駄である。かわいいコードではなくきれいなコードを書くはずである。さらに、コードを表示するディスプレイや印刷するプリントに使われるフォントはプロポーショナルだったりそうでなかったりして、箱をきれいに整列させることは難しい。

* コメントはシンプルに\
  かつて見たもっとも最良のコメントは、シンプルな要点をまとめた注釈であった。なにも本を書く必要はなく、他の人がコードを理解するに十分な情報を提供するだけでよいのである。

* コードを書く前に先にコメントを記述する\
  コードをコメント化する最良の方法は、コードを書く前にコメントを書くことである。それが、コードを書く前にコードがどのように動作するかについて考えるよい機会となり、コメントの存在を保障することにもつながる。少なくともコードを書いた時にコメントすべきである。コメントによってコードが理解しやすくなることで、コードの開発中にアドバンテージを得ることができる。コードにコメントを書く時間を費やせば、それによって得られるものがある。

* コメントには、なぜそうなのかを書く。コードを読めば分かることを書かない\
  基本的に、コードの一部分を見ればそれが何かを理解することはできる。例えば、以下のコードを見て、$1000 以上の注文については 5%ディスカウントされることは理解できる。なぜそうなのか？大きな注文ではディスカウントがつきものだというビジネスルールがあるのだろうか？大きな注文に時間限定サービスがあるのか、それともずっとサービスがあるのか？これを書いたプログラマの気前がよかったのか？\
  どこかソースコード中か別な文書にコメントされていない限り、それがなぜなのかを知ることはできない。

  ```java
  if (grandTotal >= 1000.00) {
      grandTotal = grandTotal * 0.95;
  }
  ```

  なお、メソッドコメントには、適切な javadoc コメント（タグ）のほかに、以下の内容も可能な限り明記すること。

  * 副作用のある処理の場合は、その内容　（→ メソッドの引数オブジェクトがメソッド内で変更されるケースなど）
  * 既知のバグ　（→ 判明しているが修正しないことにした場合など）
  * 影響のある事前条件、事後条件　（→ メソッドが正しく動作するための前提について）
  * 並行性　（→ 　マルチスレッドでアクセスされた場合の動作について）
  * 該当メソッドの使用例やサンプルコード

* TODO コメント\
  設計者確認待ち、共通処理の作成待ちなどの理由により、実装時に TODO がある場合、下記のようにコメントを記述する。\
  （Eclipse の TODO コメント形式を採用）\
  例）

  ```java
  //TODO：ワークフローの仕様決定待ち　関連チケット#12345
  ```

## Java コメント（3 種類）の使い分け

Java では 3 種類のコメントが使える。javadoc コメントは`/**`で開始され、`*/`で終わる。C 風コメントは`/*`で開始され`*/`で終わる。単一行コメントは`//`で開始され、そのソースコード行が終わるまで続く。以下の表ではコメントの使い方とその例を示す。（コメントのスタイルに関しては、前述の「標準規約に準拠したコーディング例」を参照）

| コメント種類                         | 使用方法                                                                                                                                                                                              | 例                                                                                                                                                                                               |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| javadoc コメント`/** comment */` | interface、class、メソッド、フィールドの直前に書く。コメントは javadoc によって処理され、外部ドキュメント(HTML)として生成される。（この形式以外のコメントはドキュメントとして出力されないことに注意） | /\*\* \* 顧客（Customer）- \* 顧客はわれわれがサービスまたは製品を売った人物 \* もしくは組織のいずれかである。 \* @author 開発太郎 \*/     |
| C 風コメント`/* comment */`      | 特定のコードを無効化したいが、後で使用するかもしれないので残しておくためにコメント化する時や、デバッグ時に一時的に無効化するときに使用する。                                                          | /\* このコードは J.T.Kirk によって 1997.12.9 に前述のコードと置き換えたためコメント化した。2 年間不要であるならば削除せよ。 ... (ソースコード) \*/ |
| 単一行コメント`// comment`       | メソッド内にて、ビジネスロジック、コードの概要、一時変数の定義内容などを記述する。                                                                                                                    | // 1995 年 2 月に開始された X 氏の寛大なキャンペーンで// 定められた通り 1000$を超える請求には、全て 5%割引を// 適用する。                              |

※ ロジック中に、頻繁に C 風コメントでコメントを書くとまとめてコメントアウトする場合に不便なため、基本的にロジック中では単一行コメントを利用すること。

# パフォーマンス

パフォーマンスを考慮した Java のコーディングについて以下に示す。

※ パフォーマンスは jre のバージョンやスペックによって変化します。本内容は jre1.8.0\_74 での検証結果を元にした内容です。

※ 性能計測結果についての記載がありますが、あくまでも参考値です。性能を保証するものではありません。

## Stream API

Java8 で追加された Stream API での記述は、可読性も高く、簡潔に書けますが、パフォーマンス・性能面で注意が必要な場合があります。

List の処理を行う際、拡張 for 文で処理する場合は Iterator インスタンスが 1 つだけ生成されますが、Stream API で処理する場合、最初の Stream インスタンスに加え、各中間処理ごとにも Stream インスタンスが生成され、その分の性能劣化が懸念されます。\
以下に処理例と計測結果を記載します。

* 拡張 for 文

  ```java
  List<String> list = //数値文字列のList
  List<String> resultList = new ArrayList<>();
  for (String string : list) {
      if (string.endsWith("0")) {
          resultList.add(string);
      }
  }
  return resultList;
  ```

* Stream API

  ```java
  List<String> list = //数値文字列のList
  List<String> resultList = list.stream()
      .filter(s -> s.endsWith("0"))
      .toList();
  return resultList;
  ```

* 計測結果

  | 処理する List の件数 | 拡張 for 文 (ms) | StreamAPI (ms) |
  | -------------------: | ---------------: | -------------: |
  |             100 万件 |                7 |              9 |
  |           1,000 万件 |               88 |            114 |
  |               1 億件 |              949 |          1,026 |
  |               2 億件 |            1,822 |          2,081 |

小中規模の処理量であれば考慮するほどの性能差はありませんが、大量の処理が見込まれる場合は考慮が必要です。\
また、Stream API は並列処理（スレッド処理）の機能をサポートしていますので、利用できる場合は並列処理も含めての検証が必要です。

## ラムダ式・メソッド参照・コンストラクタ参照

Java8 で追加されたラムダ式・メソッド参照・コンストラクタ参照は、匿名クラスを利用するよりも効率的です。\
積極的な利用を推奨します。

以下に Comparator を生成した場合の計測結果を記載します。

* 匿名クラス

  ```java
  Comparator<String> c = new Comparator<String>() {
      @Override
      public int compare(String o1, String o2) {
          return o1.compareToIgnoreCase(o2);
      }
  };
  ```

* ラムダ式

  ```java
  Comparator<String> c = (o1, o2) -> o1.compareToIgnoreCase(o2);
  ```

* メソッド参照

  ```java
  Comparator<String> c = String::compareToIgnoreCase;
  ```

* 計測結果

  | 処理件数 | 匿名クラス (ms) | ラムダ式 (ms) | メソッド参照 (ms) |
  | -------: | --------------: | ------------: | ----------------: |
  |  10 億回 |             380 |   0(計測不能) |       0(計測不能) |
  | 100 億回 |           6,374 |   0(計測不能) |       0(計測不能) |
  |   1 京回 |     (30 秒以上) |            14 |                10 |

ラムダ式は外部の変数を利用する場合、匿名クラスとほぼ同じ動作をします。

* 匿名クラス

  ```java
  new Comparator<String>() {
          @Override
          public int compare(String o1, String o2) {
              return arg.equals("DESC") ? o2.compareToIgnoreCase(o1)
                                              : o1.compareToIgnoreCase(o2);
          }
      }
  ```

* ラムダ式

  ```java
  Comparator<String> c = (o1, o2) -> arg.equals("DESC") ? o2.compareToIgnoreCase(o1)
                                      : o1.compareToIgnoreCase(o2);
  ```

* 計測結果

  |                   処理件数 | 匿名クラス (ms) | ラムダ式 (ms) |
  | -------------------------: | --------------: | ------------: |
  |  10 億回（パラメータあり） |             571 |           572 |
  | 100 億回（パラメータあり） |           9,900 |         9,864 |

## 文字列連結

### 文字列連結（繰り返し）

文字列連結を繰り返し処理中で行う際、`+`演算子で処理することはアンチパターンとして知られています。\
繰り返し処理中の文字列連結は、 `StringBuilder`、 `StringJoiner`、 `StringBuffer` を利用します。\
また、コレクション要素の結合であれば`String#join`が利用できます。

以下に処理例と計測結果を記載します。

* `+`演算子

  ```java
  String s = "";
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          s += ",";
      }
      s += string;
  }
  return s;
  ```

* StringBuilder

  ```java
  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          sb.append(",");
      }
      sb.append(string);
  }
  return sb.toString();
  ```

* StringBuffer

  ```java
  StringBuffer sb = new StringBuffer();
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          sb.append(",");
      }
      sb.append(string);
  }
  return sb.toString();
  ```

* String#join

  ```java
  return String.join(",", list);
  ```

* 計測結果

  | 処理する List の件数 | `+`演算子 (ms) | StringBuilder (ms) | StringBuffer (ms) | String#join (ms) |
  | -------------------: | -------------: | -----------------: | ----------------: | ---------------: |
  |             1,000 件 |              5 |        0(計測不能) |       0(計測不能) |      0(計測不能) |
  |               1 万件 |          1,016 |                  1 |                 1 |                1 |
  |              10 万件 |    (30 秒以上) |                  2 |                 5 |                5 |
  |             100 万件 |    (30 秒以上) |                 29 |                42 |               51 |

### 文字列連結（定数）

基本的に処理中の文字列連結では`+`演算子は使わないで処理するほうがパフォーマンスが高くなりますが、定数の場合は`+`演算子で定義するほうがパフォーマンスが高いです。

たとえば以下のように、処理したい場合、

```java
private static final String CONST_A = "A";
private static final String CONST_B = "B";
private static final String CONST_AB = CONST_A + CONST_B;
```

StringBuilder で処理しようとすると以下のようになります。

```java
private static final String CONST_AB = new StringBuilder(CONST_A).append(CONST_B).toString();
```

しかし、これらをバイトコード上で確認するとそれぞれ以下のようになります。

* `+`演算子

  ```java
  private static final java.lang.String CONST_AB = "AB";
  ```

* StringBuilder

  ```java
  private static final java.lang.String CONST_AB;

  static {};
     0  new java.lang.StringBuilder [20]
     3  dup
     4  ldc <String "A"> [8]
     6  invokespecial java.lang.StringBuilder(java.lang.String) [22]
     9  ldc <String "B"> [11]
    11  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [26]
    14  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [30]
    17  putstatic jp.co.packagename.ClassName.CONST_AB : java.lang.String [34]
    20  return
  ```

`+`演算子を利用した場合コンパイル時に最適化され、文字列`"A"`と`"B"`をあらかじめ結合して class が作成されます。\
`StringBuilder`を利用した場合は最適化はされず、記述した通りの処理が行われます。

計測した場合、下記のようになります。

* 計測結果

  |   処理回数 | StringBuilder (ms) | `+`演算子 (ms) |
  | ---------: | -----------------: | -------------: |
  | 5,000 万回 |                559 |    0(計測不能) |
  |     1 億回 |              1,059 |    0(計測不能) |

通常、定数処理を大量に処理することは考えられないので性能問題になることはありませんが、`+`演算子を利用したほうがパフォーマンスが高いこともあるということを理解してください。

## List の種類

`List`には`ArrayList`のような`RandomAccess`を implements した、ランダムアクセスをサポートしているクラスと、\
`LinkedList`のようなランダムアクセスをサポートしていない（シーケンシャルアクセス）クラスが存在します。\
`RandomAccess`ではない`List`は、`List#get`などインデックスを利用するような操作のパフォーマンスが低いので注意してください。

以下に処理例と計測結果を記載します。

* for 文(List#get(int)によるループ)

  ```java
  int size = list.size();
  for (int i = 0; i < size; i++) {
      String s = list.get(i);
      //処理
  }
  ```

* 拡張 for 文

  ```java
  for (String s : list) {
      //処理
  }
  ```

* forEach

  ```java
  list.forEach(this::処理);
  ```

* 計測結果

  | 処理する List の件数 | `ArrayList`for 文(List#get(int)によるループ) (ms) | `LinkedList`for 文(List#get(int)によるループ) (ms) | `ArrayList`拡張 for 文 (ms) | `LinkedList`拡張 for 文 (ms) | `ArrayList`forEach (ms) | `LinkedList`forEach (ms) |
  | -------------------- | ----------------------------------------------------: | -----------------------------------------------------: | ------------------------------: | -------------------------------: | --------------------------: | ---------------------------: |
  | 1 万件               |                                           0(計測不能) |                                                     73 |                     0(計測不能) |                      0(計測不能) |                 0(計測不能) |                  0(計測不能) |
  | 10 万件              |                                           0(計測不能) |                                                  7,576 |                     0(計測不能) |                      0(計測不能) |                           1 |                            2 |
  | 20 万件              |                                           0(計測不能) |                                                 17,740 |                     0(計測不能) |                      0(計測不能) |                 0(計測不能) |                  0(計測不能) |
  | 50 万件              |                                           0(計測不能) |                                            (30 秒以上) |                     0(計測不能) |                                2 |                 0(計測不能) |                            2 |
  | 100 万件             |                                                     1 |                                            (30 秒以上) |                     0(計測不能) |                                4 |                 0(計測不能) |                            4 |
  | 1,000 万件           |                                                    16 |                                            (30 秒以上) |                               8 |                               45 |                           6 |                           44 |

ランダムアクセスをサポートしている`List`がシーケンシャルアクセス（iterator を利用した処理など）で遅いということはないので、\
ループの処理は拡張 for 文等、Iterator によるループで記述するのが無難です。\
`List#get`での処理をすべて禁止することはできませんが、高いパフォーマンスが求められる場合は`List`の種類にも注目してみてください。

## BigDecimal の ZERO との比較

BigDecimal の正・負・ZERO の判定は`BigDecimal#signum`を利用します。\
`compareTo`を利用して`BigDecimal.ZERO`と比較しても同じことができますが、`signum`を利用したほうが効率的です。

以下に処理例と計測結果を記載します。

* compareTo 利用

  ```java
  BigDecimal value = new BigDecimal("0.0");
  if (value.compareTo(BigDecimal.ZERO) == 0) {
  ```

* signum 利用

  ```java
  BigDecimal value = new BigDecimal("0.0");
  if (value.signum() == 0) {
  ```

* 計測結果

  （単位：マイクロ秒）

  | 処理回数 | compareTo 利用 (マイクロ秒) |   signum 利用 (マイクロ秒) |
  | -------: | --------------------------: | -------------------------: |
  |   1 京回 |  527max:26,367min:0 | 424max:21,213min:0 |

性能差が少ないので、必ずしも signum を利用する必要はありませんが、大量に処理する場合など、高いパフォーマンスが求められる場合は意識してください。

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)

---

---
url: /coding-standards/documents/forJava/Javaコーディング規約_for_11.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。\
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。\
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# はじめに

一般に利用・参照されている Java コーディング規約やガイドラインを以下に示す。本規約の作成においても、下記規約類を参照・抜粋している。

| 規約                                                   | 著作者               | URL                                                                                                                                 |
| ------------------------------------------------------ | -------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| Code Conventions for the Java Programming Language     | Sun Microsystems     | <http://www.oracle.com/technetwork/java/codeconvtoc-136057.html>                                                                    |
| Writing Robust Java Code                               | Scott W. Ambler      | <http://www.ambysoft.com/downloads/javaCodingStandards.pdf>                                                                         |
| オブジェクト倶楽部版 Java コーディング標準             | オブジェクト倶楽部   | <http://objectclub.jp/community/codingstandard/CodingStd.pdf>                                                                       |
| 電通国際情報際サービス版 Java コーディング規約 2004    | 電通国際情報サービス | <http://objectclub.jp/community/codingstandard/JavaCodingStandard2004.pdf>                                                          |
| JJGuideline （Java - J2EE Conventions and Guidelines） | Stephan.J & JCS Team | <http://www.fedict.belgium.be/sites/default/files/downloads/Java_J2EE_conventions_and_guidelines_EN.pdf>※現在は削除されています |
| Google Java Style (非公式和訳)                         | Google               | <https://kazurof.github.io/GoogleJavaStyle-ja/>                                                                                     |
| Acroquest Technology Java コーディング規約             | Acroquest Technology | <https://www.acroquest.co.jp/webworkshop/javacordingrule/Acroquest_JavaCodingStandard_6_7.pdf>※現在は削除されています           |

※ Sun Microsystems の規約は Java 草創期から一応の標準という位置づけだったが、オブジェクト指向、及び、その開発環境の普及・発展によって、設計やコーディングにおいて、直接的に有用な知識や豊富な指針を含むような優れた規約や、ツールなどによる機械的な準拠チェックと連携する規約が普及してきている。

# 規約の重要性

標準としての規約を定義し、遵守することの重要性を以下に示す。

* ソフトウェアメンテナンスにおける、可読性・保守性・拡張性の向上
* 問題を起こしやすい実装を未然に回避することによる、品質・生産性の向上
* 標準規約を通して得られる一般的な実装知識やノウハウ（＝学習効果）

## コーディングの心得

長いプログラムを記述すること（ステップ数）によって生産性が評価されたのは、過去の時代の出来事である。現在は、クラスやメソッドの役割が明確で、ロジックが読みやすく、保守性に優れたプログラムを記述することが評価される。コーディング規約は、コードの書き方に関する一種のパターンと考えることもでき、コードの保守性を向上させる具体的な方法を示している。したがって、規約の一つ一つの意図を理解し、守ることが重要になる。しかし、保守性に優れたコードを作成するためには、コーディング規約を守ることに加えて、良いコードを記述するための基本的な心構えをしっかり心に留めておく必要がある。以下では、その心得について述べる。

【コーディングの心得 5 か条】

1. 見やすさを重視せよ
2. ネーミングはわかりやすく
3. サンプルを鵜呑みにしない
4. 同じコードを二度書かない
5. 役割は一つに

### 見やすさを重視せよ

「良いコード」の基本は、「他の人が読んでもわかりやすいと感じられるコード」。コードの見やすさは、フォーマットはもちろん、ロジックの簡潔さや API の常識的な使い方などから生まれる。コーディングにあたっては、常に他の人の視点を意識しながら、見やすさに気を配って記述する必要がある。例えば、自分で記述したコードであっても、しばらくたってから読み返してみると理解に時間がかかった経験は誰にもあるはず。「3 日前に書いたコードは他人のコードと同じ」ということもよく言われる。見やすさを重視することは、他の人のためだけでなく自分のためにもなる。コードを読んでもすぐに理解できないような実装は、再考（リファクタリング）の必要がある。

### ネーミングはわかりやすく

コーディングでは、様々な変数やメソッドなどにネーミング（名前付け）する必要がある。ネーミングとは、本来、その対象の本質を表すような名前を考える作業である。大変難易度の高い作業だが、一方で適当に行ってもコードの動作は変わらないため、人によっては手を抜きがちとなる。しかし、ネーミングの良し悪しは、コードの可読性に非常に大きな影響を及ぼす。例えば、「C0001」というクラス名があるとする。これでは、何を表すクラスなのかすぐにはわからないだろう。また、「int p = 5000;」という記述があるとする。プログラマに聞くと、変数名 p は価格(Price)の略だと言うのだが、それならば略さずに、「int price = 5000;」としたほうが分かりやすいはずである。「ネーミングはわかりやすく」の背景には、読んで内容が理解できるという意味で、文章のようなプログラミングを行う、という考え方に基づく。

### サンプルを鵜呑みにしない

サンプルコードを活用すること自体は、著作権等を侵害しなければ問題ない。問題なのは、その内容や背景を理解しないまま、サンプルコードだけを鵜呑みにして、「おまじない」として表面的に適用してしまうことである。コードを「おまじない」ととらえていては、サンプルコードの間違いを気づかないまま適用してしまうこともある。例えば、ストリームのクローズ処理を行っていないサンプルコードであっても、それに気づかずに自分のコードに適用してしまい、後で思わぬ障害を引き起こすという可能性がある。サンプルコードは、そこで説明する内容に絞ったコードが多いため、このような例はよく見られる。また、サンプルコードをそのまま適用した結果、自分が記述すべきコードには必要のないコードが含まれてしまう場合もある。その場合、コードの可読性を下げる原因となる。自分のコードは、自分で深く理解して記述すべきである。

### 同じコードは二度書かない

コードをコピー・ペーストしていませんか？コピー・ペーストしてしまうと、何らかの修正をする際に、全ての個所に同じ修正をする羽目になる。同じコードが現れるようならまとめて一つにし、外に出してコールするような書き方にすべきである。同じコードをまとめる作業は、どちらかといえば、コーディング時よりリファクタリング（ソフトウェアの外部的振る舞いを変更せずに内部構造を改善する作業）で行われることが多い。しかし、コーディング時からできるだけ気をつけておきたいことでもある。

### 役割は一つに

メソッドの役割が明確で、かつ 1 つであれば単体テストが行いやすくなる。つまり、コードの「試験性」が高まる。また、役割が一つであれば、後でコードを変更する際に修正箇所がわかりやすいため、障害修正に要する時間が短くなる。つまり、コードの「保守性」があがることになる。例えば、「チェックをして実行する」機能を実現するために、checkAndDo()メソッドが存在したとする。この場合、このメソッドは check()メソッドと do()メソッドに分割すべきである。なぜなら、checkAndDo()メソッドの check()ロジックに誤りがあった場合、do()メソッドに書かれる内容まで把握する必要が生じるためである。分割してあれば、check()メソッドだけの変更で済む。このことはクラスの設計にもあてはまる。

# ネーミング規約

## 全般

* 大文字・小文字の違いで名前を区別しない。

  良い例：

  ```java
  private int carNumber;
  private int trainNumber;
  ```

  悪い例：

  ```java
  private int num;
  private int Num;
  ```

## パッケージ

* パッケージ名はすべて小文字にする
* パッケージ名は意味のある名前にする
* サブパッケージ名の重複は可能

## クラス

* クラス名は単語の先頭を大文字にする\
  良い例：

  ```java
  public class Entry {
  ```

  悪い例：

  ```java
  public class entry {
  ```

* インターフェース名、Enum 名はクラス名に準ずる

## メソッド

* コンストラクタと同じ名前のメソッドはつくらない

* メソッド名は区切りのみ大文字にする\
  良い例：

  ```java
  public String getName() {
      //・・・
  }
  ```

  悪い例：

  ```java
  public String getname() {
      //・・・
  }
  public String GETNAME() {
      //・・・
  }
  ```

* 変換メソッド名は「"`to`"+オブジェクト名」にする\
  良い例：

  ```java
  public String toString() {
  ```

  悪い例：

  ```java
  public String string() {
  ```

* ゲッターメソッド名は「"`get`"+属性名」にする\
  型が`boolean`の場合は「"`is`"+属性名」にする

* セッターメソッド名は「"`set`"+属性名」にする

* `boolean`変数を返すメソッド名は`true`/`false`の状態がわかるようにする

  良い例：

  ```java
  public boolean isAsleep() {
  }
  public boolean exists() {
  }
  public boolean hasExpired() {
  }
  ```

## 引数

* メソッドのパラメータ名とインスタンス変数名を一緒にしない\
  ただし、アクセサメソッドやコンストラクタなど、統合開発環境の機能により自動生成するものに関しては可とする。\
  アンダースコア　`_`　をつけての区別は原則禁止とする。

  良い例：

  ```java
  public double calc(double rate) {
      return this.value * rate;
  }
  ```

  悪い例：

  ```java
  public double calc(double value) {
      return this.value * value;
  }

  public double calc(double _value) {
      return this.value * _value;
  }
  ```

## 変数全般

* `boolean`変数は`true`/`false` の状態がわかるようにする

  良い例：

  ```java
  private boolean isOpen;
  ```

  悪い例：

  ```java
  private boolean flag;
  ```

* 定数は全て`static final`とし、すべて大文字、区切りは"`_`"

  良い例：

  ```java
  private static final String SYSTEM_NAME = "販売管理システム";
  ```

* 変数名は小文字とし、単語の区切りのみ大文字にする

  良い例：

  ```java
  private String thisIsString;
  ```

  変数名に固有名詞が含まれる場合、先頭をのぞき、単語の区切り以外に大文字を使用してもよい

  良い例：

  ```java
  private String thisIsIPAddress;
  ```

## ローカル変数

* スコープが狭い変数名は省略した名前でもよい\
  良い例：

  ```java
  if (・・・) {
      String s = "・・・・";
     //変数sを利用した処理 数行
  }
  ```

  悪い例：

  ```java
  String s = "・・・・";
  if (・・・) {
     //変数sを利用した処理
  }
  ・・・
  if (・・・) {
     //変数sを利用した処理
  }
  ```

  変数`s`の利用範囲が広いので役割が明確になる変数名に変更する。

* for 文のループカウンタは、ネストごとに"`i`","`j`","`k`"・・・を使う

## Enum

* Enum 名はクラス名と同じく、単語の先頭を大文字にする
* 列挙定数は定数と同じく、すべて大文字、区切りは"`_`"

  良い例：

  ```java
  enum Season {
      WINTER,
      SPRING,
      SUMMER,
      FALL
  }
  ```

  悪い例：

  ```java
  enum Season {
      winter,
      spring,
      summer,
      fall
  }
  ```

# コーディング規約

## 全般

* 原則としてオブジェクトの参照にはインターフェースを利用する\
  オブジェクトを参照する際は、そのオブジェクトの実装クラスを用いて宣言できるが、実装クラスに適切なインターフェースが存在している場合は、必ずインターフェースを用いて宣言すること。

  良い例：

  ```java
  List<Entry> list = new ArrayList<>();
  Map<String, String> map = new HashMap<>();
  ```

  悪い例：

  ```java
  ArrayList<Entry> list = new ArrayList<>();
  HashMap<String, String> map = new HashMap<>();
  ```

* 推奨されない API を使用しない\
  アノテーション`@Deprecated`で指定されたメソッドは利用しないこと。

* 使われないコードは書かない

* 宣言は適切な権限で行うこと（`public`, `protected`, `private`）

* `final` を適切に利用する\
  継承されないクラス、オーバーライドされないメソッド、値の変わらない変数（つまり定数）等、変化のないもの/変化させたくないものについては`final` で宣言する。

  良い例：

  ```java
  //継承されないクラス
  public final class CalculateUtils {
      //・・・
  }

  //値の変わらない変数（定数）
  private static final String MESSAGE = "・・・";

  //オーバーライドされないメソッド
  public final int sum(/*変化させたくない値*/final int... values) {
      int sumValue = 0;
      for (/*変化させたくない値*/final int value : values) {
          sumValue += value;
      }
      return sumValue;
  }
  ```

## フォーマット

* インデントは空白文字 4 文字分の Tab を使用する

* 長すぎる行は避ける

* `{` の後にステートメントを記述しない\
  良い例：

  ```java
  if (s == null) {
      return 0;
  }
  ```

  悪い例：

  ```java
  if (s == null) {return 0;}
  ```

* 1 行に 2 つ以上のステートメントを記述しない\
  悪い例：

  ```java
  } catch (Exception e) {
      log.error("Error", e);return null;
  }
  ```

* カンマの後には空白文字を\
  良い例：

  ```java
  process(x, y, z);
  ```

  悪い例：

  ```java
  process(x,y,z);
  ```

* 代入演算子（ `=` , `+=` , `-=` , …）の前後には空白文字を挿入する\
  良い例：

  ```java
  int a = x;
  a += 10;
  ```

  悪い例：

  ```java
  int a=x;
  a+= 10;
  ```

* for 文内のセミコロンの後には空白文字を挿入する\
  良い例：

  ```java
  for (int i = 0; i < array.length; i++) {
      //・・・
  }
  ```

  悪い例：

  ```java
  for (int i = 0;i < array.length ;i++) {
      //・・・
  }
  ```

* `++` や `--` とオペランドの間には空白文字を入れない\
  良い例：

  ```java
  i++;
  ```

  悪い例：

  ```java
  i ++;
  ```

* ビット演算子（ `|` 、 `&` 、 `^` 、 `<<` 、 `>>` ）の前後には空白文字を挿入する

* 論理演算子（ `||` 、`&&`）の前後には空白文字を挿入する

* 関係演算子（ `<` 、 `>` 、 `>=` 、 `<=`、`==`、 `!=` ）の前後には空白文字を挿入する

* 算術演算子（ `＋` 、 `－` 、 `＊` 、 `/` 、 `%` ）の前後には空白文字を挿入する

* return 文ではカッコを使わない\
  良い例：

  ```java
  int answer = (a + b + c) * d;
  return answer;
  ```

  悪い例：

  ```java
  return ((a + b + c) * d);
  ```

* if などの条件式で boolean の変数を比較しない

  良い例：

  ```java
  if (hasStock)
  ```

  悪い例：

  ```java
  if (hasStock == true)
  ```

* 不等号の向きは左向き（ `<` 、 `<=` ）にする\
  良い例：

  ```java
  if (from <= x && x <= to) {
  ```

  悪い例：

  ```java
  if (x >= from && x <= to) {
  ```

## コメント

* ファイルの先頭への Copyright の表記について\
  ソースのファイルヘッダにコピーライト標記は法的拘束力がないため、不要とする。\
  ただし、顧客からの要求があった場合を除く。

* Javadoc コメントには、少なくとも author と version(クラス)、param と return と exception(メソッド)を記述する
  * 今後もバージョンアップのリリースが予定されているソースでは、上記に加えて since（バージョン）を記述する
  * `@Override`のあるメソッドでは、上記に加えて`{@Inherit}`を記述する

* Javadoc 　クラスヘッダコメントのフォーマットは以下の通り

  良い例：

  ```java
  /**
   * Action（or Bean）クラス　メニュー名称
   *
   * @author 姓 名
   * @version バージョン YYYY/MM/DD 説明
   */
  ```

* コメントは必要なものだけを簡潔に\
  悪い例：

  ```java
  /**
   * 文字列に変換
   */
  @Override
  public String toString() {

  /**
   * コピー
   *
   * @return コピーしたインスタンス
   */
  public Entry copy() {
  ```

* 不要なコメントは記載しない
  * コードからすぐわかること・冗長なコメント
  * 名前の説明\
    コメントではなくわかりやすい名前を付ける。
  * 別システムで管理している内容\
    ソースコード管理システム、バグトラッキングシステムで管理している内容はソースコードにコメントで記載する必要はない。
    * コメントアウトされたコード\
      ソースコード管理システムで管理されている

## インポート

* `java.lang`パッケージはインポートしない

  悪い例：

  ```java
  import java.lang.String;//必要のない記述
  ```

* 原則として static インポートしない\
  JUnit の作成やフレームワークとして static インポートが推奨されるような場合は利用してもよい

* 原則としてオンデマンドのインポート宣言(type-import-on-demand declaration)（アスタリスク`*`によるインポート） は行わない

  悪い例：

  ```java
  import java.util.*;
  ```

## コンストラクタ

* public 宣言していないクラスには`public`権限のコンストラクタを作らない\
  良い例：

  ```java
  class Entry {
      //・・・
      Entry(int id) {
          //・・・
      }
  ```

  悪い例：

  ```java
  class Entry {
      //・・・
      public Entry(int id) {
          //・・・
      }
  ```

* インスタンスメンバを持たない（static メンバのみの）クラスは、`private`権限のコンストラクタを作成する

## メソッド

* オーバーライドさせたくないメソッドは`final`を利用する

* 戻り値が配列のメソッドで、戻る配列のサイズが 0 の場合、メソッドを使用するクライアントの余計な null チェックのロジックを回避するため、null ではなく長さゼロの配列を戻すようにする。
  良い例：

  ```java
  public String[] toArray(String s) {
      if (s == null || s.isEmpty()) {
          return ArrayUtils.EMPTY_STRING_ARRAY;
      }
      return new String[] { s };
  }

  public List<String> toList(String s) {
      if (s == null || s.isEmpty()) {
          return Collections.emptyList();
      }
      return List.of(s);
  }
  ```

  悪い例：

  ```java
  public String[] toArray(String s) {
      if (s == null || s.isEmpty()) {
          return null;
      }
      return new String[] { s };
  }

  public List<String> toList(String s) {
      if (s == null || s.isEmpty()) {
          return null;
      }
      return List.of(s);
  }
  ```

* メソッドは 1 つの役割にする

## クラスメソッド

* クラスメソッドを利用するときは、クラス名を使って呼び出す\
  良い例：

  ```java
  int comp = Integer.compare(x, y);
  ```

  悪い例：

  ```java
  Integer a = //
  int comp = a.compare(x, y);
  ```

## 変数全般

* 1 つのステートメントには 1 つの変数宣言\
  良い例：

  ```java
  /** 科目コード */
  private String code;
  /** 科目名 */
  private String name;
  /** 科目略名 */
  private String shortName;
  ```

  悪い例：

  ```java
  private String code, name, shortName;
  ```

* リテラルは使用しない\
  リテラルとは、コード中に、表現が定数として直接現れており、記号やリストで表現することができないものを指す（数値、文字列両方含む　通称マジックナンバー）。コードの可読性・保守性の低下を防ぐために、リテラル定数（`static final` フィールド）を使用すること。\
  例外：`-1`,`0`,`1` 等をカウント値としてループ処理等で使用するような場合

  良い例：

  ```java
  private static final double ONE_MILE_METRE = 1609.344;

  public double mileToMetre(double mi) {
      return mi * ONE_MILE_METRE;
  }
  ```

  悪い例：

  ```java
  public double mileToMetre(double mi) {
      return mi * 1609.344;
  }
  ```

  * リテラル定数の名前はその値の意味を正しく表現したものにする

    悪い例：

    ```java
    private static final int ZERO = 0;
    ```

* 配列宣言は「`型名[]`」にする

  良い例：

  ```java
  private int[] sampleArray = new int[10];
  ```

  悪い例：

  ```java
  private int sampleArray[] = new int[10];
  ```

* できるだけローカル変数を利用する\
  ローカル変数で事足りるものをインスタンス変数として利用するなど、必要のないインスタンス変数を定義すると、パフォーマンスや可読性の低下やの大きな要因となる上、マルチスレッドを意識した際に不整合がおきる可能性があるので、インスタンス変数は必要性を充分に考慮してから使用すること。

* 定数は`final`で宣言する

* ローカル変数とインスタンス変数を使いわける

## 定数

* `public` で宣言するクラス変数とインスタンス変数は、定数のみとし、 `static final` で定義する\
  `final` ではない `static` な定数は作成しない。

  良い例：

  ```java
  public static final String PROTOCOL_HTTP = "http";
  ```

* 定数（ `static` フィールド）に、 `static` ではないメソッドから書き込まない

* 定数は、プリミティブ型もしくは、不変（Immutable）オブジェクトで参照する
  * 不変`List`の生成には`List.of()`を利用する

    良い例：

    ```java
    public static final List<Integer> VALUES = List.of(1, 2, 3, 4, 5);
    ```

    悪い例：

    ```java
    public static final List<Integer> VALUES = Arrays.asList(1, 2, 3, 4, 5);
    ```

  * 不変`Set`の生成には`Set.of()`を利用する

  * 不変`Map`の生成には`Map.of()`を利用する

    良い例：

    ```java
    public static final Map<Integer, String> VALUES_MAP = Map.of(1, "A", 2, "B", 3, "C");
    ```

    悪い例：

    ```java
    public static final Map<Integer, String> VALUES_MAP = new HashMap<>() {
        {
            put(1, "A");
            put(2, "B");
            put(3, "C");
        }
    };
    ```

  * 不変な配列インスタンスは長さ 0 の配列以外は生成不可能なため、外部から参照される（`public`）定数では利用せず、`List`等への置き換えをすること

    良い例：

    ```java
    public static final List<Integer> VALUES = List.of(1, 2, 3, 4, 5);
    ```

    悪い例：

    ```java
    public static final int[] VALUES = { 1, 2, 3, 4, 5 };
    ```

## インスタンス変数

* インスタンス変数は`private`にする

  良い例：

  ```java
  public class Employee {
      private long id;

      //・・・
      //getter/setter
  }
  ```

  悪い例：

  ```java
  public class Employee {
      public long id;

      //・・・
      //getter/setter
  }
  ```

## クラス変数

* `public static final` 宣言した配列を利用しない\
  ※「定数」を参照

* クラス変数にはクラス名を使用してアクセスすること

  良い例：

  ```java
  BigDecimal b = BigDecimal.ZERO;
  ```

  悪い例：

  ```java
  BigDecimal a = //
  BigDecimal b = a.ZERO;
  ```

## ローカル変数

* ローカル変数は利用する直前で宣言する\
  行間の程度にもよるが、ある程度まとめて宣言するのは OK とする。

  良い例：

  ```java
  for (int i = 0; i < lines.length; i++) {
      String line = lines[i];
      //lineの処理
  }
  ```

  悪い例：

  ```java
  String line;
  for (int i = 0; i < lines.length; i++) {
      line = lines[i];
      //lineの処理
  }
  ```

* ローカル変数は安易に再利用しない\
  一度宣言したローカル変数を、複数の目的で安易に使いまわさないこと。ローカル変数は、役割ごとに新しいものを宣言して初期化することにより、コードの可読性・保守性の向上、及びコンパイラの最適化の促進をはかる。

## 引数

* メソッド引数への代入は行わない\
  原則として`final`で宣言する。

  良い例：

  ```java
  public void add(final int value) {
      //・・・
  }
  ```

## 継承

* スーパークラスのインスタンス変数をサブクラスでオーバーライドしない\
  スーパークラスと同じ名前のフィールドをサブクラスで宣言しないこと。 同じ名前のフィールドを宣言すると、スーパークラスのフィールドはサブクラスで宣言されたフィールドによって隠ぺいされてしまうので、他の人の混乱を招くことを防ぐため重複する名前は付けないこと。

  悪い例：

  ```java
  public class Abs {
      protected String name;
  }

  public class Sub extends Abs {
      protected String name;//Abs#nameは隠ぺいされる
  }
  ```

* スーパークラスのメソッドをオーバーライドするときは@Override アノテーションを指定する。

  良い例：

  ```java
  public class Abs {
      protected void process() {

      }
  }

  public class Sub extends Abs {
      @Override
      protected void process() {

      }
  }
  ```

  悪い例：

  ```java
  public class Abs {
      protected void process() {

      }
  }

  public class Sub extends Abs {
      //@Overrideアノテーションの指定がない
      protected void process() {

      }
  }
  ```

* スーパークラスで private 宣言されているメソッドと同じ名前のメソッドをサブクラスで定義しない\
  スーパークラスにある private メソッドと同じ名前のメソッドをサブクラスで定義しないこと。private メソッドはオーバーライドされず全く別のメソッドとして扱われ、他の人の混乱を招き、バグにつながる恐れがある。

## インナークラス

* 原則としてインナークラスは利用しない\
  一つの java ファイルに複数のクラスを記載するのは NG とする。また無名クラスを利用するのも原則として NG とする。\
  Enum の定数固有メソッド実装(constant-specific method implementation)、Java8 のラムダ式は内部的にインナークラスとされるがこれらは許可する。

## メンバー順序

* 以下の順で記述する
  1. static フィールド
  2. static イニシャライザー
  3. static メソッド
  4. フィールド
  5. イニシャライザー
  6. コンストラクター
  7. メソッド

* 同一カテゴリー内では以下の可視性の順で記述する
  1. public
  2. protected
  3. パッケージ private
  4. private

## インスタンス

* オブジェクト同士は`equals()`メソッドで比較する

  良い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1.equals(s2)) {
      //・・・
  }
  ```

  悪い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1 == s2) {
      //・・・
  }
  ```

  ただし Enum の場合は`==`演算子を利用して比較する

  `equals()`メソッドで比較する際、左辺のオブジェクトが null にならないように制御すること。

* Class 名を利用した比較をおこなわない

  良い例：

  ```java
  if (o instanceof Foo) {
      // ...
  }
  ```

  悪い例：

  ```java
  if ("my.Foo".equals(o.getClass().getName())) {
      // ...
  }
  ```

## 制御構造

* 制御文（ `if` , `else` , `while` , `for` , `do while` ）の `{ }` は省略しない

  良い例：

  ```java
  if (s == null) {
      return;
  }
  ```

  悪い例：

  ```java
  if (s == null)
      return;
  ```

* ステートメントが無い `{}` ブロックを利用しない\
  悪い例：

  ```java
  //{}内の記述が無い
  if (s == null) {
  }
  ```

* `if` / `while` の条件式で `=` は利用しない\
  良い例：

  ```java
  boolean a =//
  if (!a) {
      //・・・
  }
  ```

  悪い例：

  ```java
  boolean a =//
  if (a = false) {//コーディングミス
      //・・・
  }


  boolean a =//
  boolean b =//
  if (a = b) {//おそらくコーディングミス
      //・・・
  }
  ```

* `for` と `while` の使い分けを意識する

* for 文を利用した繰り返し処理中でループ変数の値を変更しない\
  悪い例：

  ```java
  String[] array = { /*・・・*/ };
  for (int i = 0; i < array.length; i++) {
      //・・・
      i += 2;//NG
  }

  for (String s : array) {
      //・・・
      s = "string";//NG
  }
  ```

* for 文のカウンタは特別な事情がない限り、0 から始める

* 配列やリストなどの全要素に対するループ処理は拡張 for 文を使用する。\
  良い例：

  ```java
  for (int value : array) {
      //・・・
  }

  for (String value : list) {
      //・・・
  }
  ```

* 配列をコピーするときは`Arrays.copyOf()`メソッドを利用する

  良い例：

  ```java
  int[] newArray = Arrays.copyOf(array, array.length);
  ```

  悪い例：

  ```java
  int[] newArray = new int[array.length];
  System.arraycopy(array, 0, newArray, 0, array.length);
  ```

* 繰り返し処理中のオブジェクトの生成は最小限にする

* if 文と else 文の繰り返しや switch 文の利用はなるべく避け、オブジェクト指向の手法を利用する\
  良い例：

  ```java
  CodingKind codingKind = toCodingKind(kind);
  d = codingKind.encode(s);

  //---

  CodingKind codingKind = toCodingKind(kind);
  s = codingKind.decode(d);
  ```

  悪い例：

  ```java
  switch (kind) {
  case 1:
      d = encode1(s);
      break;
  case 2:
      d = encode2(s);
      break;
  default:
      break;
  }

  //---

  switch (kind) {
  case 1:
      s = decode1(d);
      break;
  case 2:
      s = decode2(d);
      break;
  default:
      break;
  }
  ```

* 繰り返し処理の内部で `try` ブロックを利用しない\
  特に理由がない場合は繰り返し処理の外に`try`ブロックを記載する。\
  ただし、繰り返し処理内部で例外をキャッチし処理を行いたい場合は繰り返し処理の内部で`try`ブロックを利用してもよい。

  良い例：

  ```java
  for (String s : array) {
      BigDecimal num;
      try {
          num = new BigDecimal(s);
      } catch (NumberFormatException e) {
          num = BigDecimal.ZERO;
      }
      //・・・
  }
  ```

## 文字列操作

* 文字列同士が同じ値かを比較するときは、`equals()`メソッドを利用する\
  良い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1.equals(s2)) {
      //・・・
  }
  ```

  悪い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1 == s2) {
      //・・・
  }
  ```

* 文字列リテラルは`new` しない\
  良い例：

  ```java
  String s = "";
  ```

  悪い例：

  ```java
  String s = new String();
  ```

* 更新される文字列には`StringBuilder` クラスを利用する\
  良い例：

  ```java
  StringBuilder builder = new StringBuilder();
  for (String s : array) {
      builder.append(s);
  }
  System.out.println(builder.toString());
  ```

  悪い例：

  ```java
  String string = "";
  for (String s : array) {
      string += s;
  }
  System.out.println(string);
  ```

  [※パフォーマンスについても記載しているので参考にしてください](#文字列連結)

* １ステートメントのみで行われる文字列の連結には`+`演算子を利用する

  良い例：

  ```java
  String s = s1 + s2;

  return s1 + s2 + s3 + s4 + s5;
  ```

  悪い例：

  ```java
  String s = new StringBuilder(s1).append(s2).toString();

  return new StringBuilder(s1).append(s2).append(s3).append(s4).append(s5).toString();
  ```

* 更新されない文字列には`String` クラスを利用する

* 文字列リテラルと定数を比較するときは、文字列リテラルの`equals()`メソッドを利用する\
  良い例：

  ```java
  private static final String PROTOCOL_HTTP = "http";

  if (PROTOCOL_HTTP.equals(url.getProtocol())) {

  }
  ```

  悪い例：

  ```java
  private static final String PROTOCOL_HTTP = "http";

  if (url.getProtocol().equals(PROTOCOL_HTTP)) {

  }
  ```

* プリミティブ型と`String` オブジェクトの変換には、変換用のメソッドを利用する\
  良い例：

  ```java
  int i = 1000;
  String s = String.valueOf(i);// "1000"
  s = NumberFormat.getNumberInstance().format(i);// 3桁区切り "1,000"

  boolean b = true;
  s = String.valueOf(b);// true/false
  s = BooleanUtils.toStringOnOff(b);// on/off
  ```

* 文字列の中に、ある文字が含まれているか調べるには、`contains()`メソッドを利用する

* システム依存記号（ `\n` 、 `\r` など）は使用しない。\
  悪い例：

  ```java
  String text = Arrays.stream(array)
      .collect(Collectors.joining("\n"));
  ```

## 数値

* 誤差の無い計算をするときは、`BigDecimal` クラスを使う\
  浮動小数点演算は科学技術計算に利用するもので、誤差が発生する。これに対して、クラス「`BigDecimal`」は、文字列で数値の計算を行うので、金額などの正確な計算に適している。`BigDecimal` ではインスタンス生成時に指定された桁数での精度が保証される。

* 数値の比較は精度に気をつける\
  良い例：

  ```java
  BigDecimal a = new BigDecimal("1");
  BigDecimal b = new BigDecimal("1.0");
  if (a.compareTo(b) == 0) {
      System.out.println("一致");
  }
  ```

  悪い例：

  ```java
  BigDecimal a = new BigDecimal("1");
  BigDecimal b = new BigDecimal("1.0");

  if (a.equals(b)) {
      System.out.println("精度が違うためこの分岐には入らない");
  }
  ```

* 低精度なプリミティブ型にキャストしない

* `BigDecimal`を`String`変換する際は`toString()`ではなく`toPlainString()`を利用すること\
  `toString()`を利用した場合、指数表記になることがあります。

## 日付

* 日付の文字列のフォーマットには、`SimpleDateFormat`または`DateTimeFormatter`を使う\
  良い例：

  ```java
  Date date = new Date();
  SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
  String s = dateFormat.format(date);
  ```

## 三項演算子

* 入れ子の三項演算子の利用は禁止\
  可読性が悪くなるので三項演算子を入れ子で行うのは禁止。

## コレクション

* Java2 以降のコレクションクラスを利用する\
  `Vector` クラス、`Hashtable` クラス、`Enumeration` 等は、特にこれらを利用する理由がなければ、インターフェースを統一する目的で、これらの代わりに`List`(`ArrayList` クラス)、`Map`(`HashMap` クラス)、`Iterator` を使用すること。`List` などのインターフェースを利用することで JDK1.2 で整理されたわかりやすいメソッドを利用でき、また、インターフェースの特性から呼び出し元を変更せずに実装クラスを変更することができる。

* 特定の型のオブジェクトだけを受け入れるコレクションクラスを利用する

  良い例：

  ```java
  List<Map<String, String>> list = new ArrayList<>();
  ```

* `List`のソートは`List.sort()`を利用する\
  `List`クラスの要素をソートする際は Java8 で追加された`List.sort()`を利用すること。\
  Java 7 以前で利用されていた`Collections.sort()`は利用しないこと。

* `Collection.forEach()`は利用しない。拡張 for 文の利用を検討する\
  Java8 で追加されたメソッド。\
  拡張 for 文を利用したほうが多くの場合でデバッグに有利であり、可読性においても`forEach`の優位性は少ないため、`forEach`は原則利用しない。拡張 for 文を利用する。\
  具体的には下記のメソッドを利用しないこと。

  * `Collection#forEach`
  * `Set#forEach`
  * `List#forEach`

  ※ `Map#forEach`はこの限りではない

  良い例：

  ```java
  for (String s : List.of("A", "B")) {
      //処理
  }
  ```

  悪い例：

  ```java
  List.of("A", "B").forEach(s -> {
      //処理
  });
  ```

  ただし、メソッド参照で処理できる場合は`forEach`を利用する。\
  （デバッグのデメリットがほとんどなく、他と比較して処理効率が良いため）

  良い例：

  ```java
  List.of("A", "B").forEach(this::process);
  ```

  悪い例：

  ```java
  for (String s : List.of("A", "B")) {
      this.process(s);
  }
  ```

* `Arrays.asList()`は利用せず、`List.of()`を利用する\
  Java9 で追加されたメソッド。\
  配列を`List`に置き換える場合や、単純な固定の`List`を生成する際には`List.of()`を利用する。
  * `Arrays.asList()`と`List.of()`の違い\
    `List.of()`で生成した`List`は、完全に不変（Immutable）な`List`で、\
    `Arrays.asList()`で生成した`List`は、サイズのみ不変で、`set`等による値の操作が可能な`List`です。\
    また、`set`を行った場合、`Arrays.asList()`に与えられた配列インスタンスにも影響します。

## ラムダ式・メソッド参照・コンストラクタ参照

* ラムダ式が利用できる箇所はラムダ式を利用してよい\
  [※パフォーマンスについても記載しているので参考にしてください](#ラムダ式メソッド参照コンストラクタ参照-1)

* ただし、メソッド参照・コンストラクタ参照が利用できる場合はメソッド参照・コンストラクタ参照を利用する

  良い例：

  ```java
  String::compareToIgnoreCase
  ```

  悪い例：

  ```java
  (s1, s2) -> s1.compareToIgnoreCase(s2)
  ```

  良い例：

  ```java
  BigDecimal::add
  ```

  悪い例：

  ```java
  (b1, b2) -> b1.add(b2)
  ```

* ラムダ式記述の際、型宣言は省略記法で記述する

  良い例：

  ```java
  (s1, s2) -> s1 + "=" + s2
  ```

  悪い例：

  ```java
  (String s1, String s2) -> s1 + "=" + s2
  ```

* 原則ラムダ式内の行数は 1 行とする\
  複数行で利用したい場合は、`private`メソッドを作成しメソッド参照を利用する

  良い例：

  ```java
  this::getMax

  private int getMax(int i1, int i2) {
      if (i1 > i2) {
          return i1;
      } else {
          return i2;
      }
  }
  ```

  悪い例：

  ```java
  (i1, i2) -> {
      if (i1 > i2) {
          return i1;
      } else {
          return i2;
      }
  }
  ```

* 原則ラムダ式は 1 行記述に限定するので、中カッコ、`return`は必ず省略する

  良い例：

  ```java
  (s1, s2) -> s1 + "=" + s2
  ```

  悪い例：

  ```java
  (s1, s2) -> {
      return s1 + "=" + s2;
  }
  ```

## 実質的 final（effectively final）

* 実質的 final を利用する\
  変数宣言に`final`を記載しなくてよい。

## Stream API

* 利用してよい\
  [※パフォーマンスについても記載しているので参考にしてください](#stream-api-2)

* 並列ストリームは利用しないこと\
  悪い例：

  ```java
  Stream<?> s = list.parallelStream();
  Stream<?> s = list.stream().parallel();
  ```

* StreamAPI 記述の際の改行位置は、各中間処理・末端処理前のピリオドの前で改行する

  良い例：

  ```java
  List<Character> alphabetLower = list.stream()
      .filter(Character::isAlphabetic)
      .map(Character::toLowerCase)
      .collect(Collectors.toList());
  ```

  悪い例：

  ```java
  List<Character> alphabetLower = list.stream().filter(Character::isAlphabetic)
      .map(Character::toLowerCase).collect(Collectors.toList());

  List<Character> alphabetLower = list
      .stream()
      .filter(Character::isAlphabetic)
      .map(Character::toLowerCase)
      .collect(Collectors.toList());
  ```

* インデントは統合開発環境の提供するフォーマッタに合わせる

* 中間処理の数は 3 つ（3 行）程度までを推奨する\
  中間処理の記述が多くなると可読性も悪くなり、デバッグも難しくなるため、3 行程度を目安にロジックを検討すること。

* コメントは、原則として処理中には記載しない\
  難解になってしまった場合のみ処理中の記載を認める

  良い例：

  ```java
  // クラスFooのフィールドStrの値で昇順にソートし、フィールドStrの要素を取得して処理する。
  hogeList.stream()
      .sorted(Comparator.comparing(Foo::getStr))
      .map(Foo::getStr)
      .forEach(this::proc);
  ```

  悪い例：

  ```java
  hogeList.stream()
      .sorted(Comparator.comparing(Foo::getStr)) //クラスFooのフィールドStrの値で昇順にソート
      .map (Foo::getStr) //フィールドStrの要素を取得
      .forEach(this::proc); //処理


  hogeList.stream()
      //クラスFooのフィールドStrの値で昇順にソート
      .sorted(Comparator.comparing(Foo::getStr))
      //フィールドStrの要素を取得
      .map (Foo::getStr)
      //処理
      .forEach(this::proc);
  ```

* Stream は極力変数代入しないこと\
  Stream は中間処理、末端処理を行うと使用済みとなり、以降同じインスタンスは利用できない。\
  変数代入はほとんどの場合意味をなさず、むしろミスの元となるため極力変数代入はしないこと。

  良い例：

  ```java
  List<String> list1 = Stream.of("A", "B", "C")
          .map(String::toLowerCase)
          .collect(Collectors.toList());

  List<String> list2 = Stream.of("A", "B", "C")
          .map(s -> s + s)
          .collect(Collectors.toList());
  ```

  悪い例：

  ```java
  Stream<String> stream = Stream.of("A", "B", "C");
  Stream<String> stream1 = stream.map(String::toLowerCase);
  List<String> list1 = stream1.collect(Collectors.toList());

  Stream<String> stream2 = stream.map(s -> s + s);//コーディングミス streamは使用済のためエラーになる
  List<String> list2 = stream2.collect(Collectors.toList());
  ```

## Optional

* Optional は同メソッド内で値を取り出す場合は極力変数代入しないこと\
  Optional とその値の変数は同じものを示す名前となり、同じ意味の変数名が複数現れることで可読性が下がるため、Optional の変数代入は行わないこととする。

  良い例：

  ```java
  Employee employee = findEmployee(employeeId)
          .orElseThrow(IllegalArgumentException::new);
  ```

  悪い例：

  ```java
  Optional<Employee> employeeOpt = findEmployee(employeeId);
  Employee employee = employeeOpt.orElseThrow(IllegalArgumentException::new);
  ```

  良い例：

  ```java
  Optional<Employee> employee = findEmployee(employeeId);

  Dept dept = employee.map(Employee::getDivision)
          .map(Division::getDept)
          .orElse(null);

  Role role = employee.map(Employee::getRole)
          .orElse(null);

  //-----

  Optional<Employee> employee = findEmployee(employeeId);
  //・・・処理
  return employee;
  ```

## var (Local-Variable Type Inference)

次のリンクも参考にしてください。\
[Style Guidelines for Local Variable Type Inference in Java](https://openjdk.java.net/projects/amber/LVTIstyle.html)

* 明確な方針で、利用する・利用しないを統一すること\
  方針無く、`var`を混在させるとソースコードの見通しと保守性が悪くなります。\
  各プロジェクトで、例えば以下ののような方針で統一してください。

  1. `var`を利用しない
  2. 原則`var`を利用する
  3. 右辺で、明確に型がわかる場合は`var`を利用する

  以下で`2`、`3`について例を示します。

  * 原則`var`を利用する

    利用できる箇所は全て`var`を利用します。

    良い例：

    ```java
    var a = "";
    var b = 123;
    var c = new ArrayList<String>();
    ```

    悪い例：

    ```java
    var a = "";
    int b = 123;
    List<String> c = new ArrayList<>();
    ```

    ```java
    void methodA() {
        var a = "";
    }
    void methodB() {
        String a = "";
    }
    ```

  * 右辺で、明確に型がわかる場合は`var`を利用する

    右辺をみて型がわかる場合は、全て`var`を利用します。
    それ以外は`var`を利用してはいけません。

    良い例：

    ```java
    var s = ""; // リテラルによって型が明確に判断できます
    var list1 = new ArrayList<String>(); // newによって型が明確に判断できます
    var list2 = (List<String>) map.get("p"); // キャストによって型が明確に判断できます
    var list3 = List.of("A", "B", "C"); // ファクトリーによって型が明確に判断できます
    ```

    プロジェクトで観点を決めるべき例：

    ```java
    var b1 = s.isEmpty(); // `is`で始まるメソッドは通例としてbooleanを返します
    var b2 = Objects.equals(s1, s2); // `equals`メソッドは通例としてbooleanを返します
    var i1 = Objects.hash(s); // `hash`、`hashCode`メソッドは通例としてintを返します
    var i2 = Objects.compare(s1, s2); // `compare`、`compareTo`メソッドは通例としてintを返します
    ```

    悪い例：

    ```java
    var a = e.getData(); // `e`の型と、メソッド定義がわからなければ型が判断できません
    ```

## ストリーム（InputStream OutputStream）

* ストリームを扱う API を利用するときは、try-with-resources 文で後処理をする

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //inputStreamに対する処理を記載
  }
  ```

* `ObjectOutputStream` では`reset()`を利用する

## リソースの解放

* リソース解放を必要とするクラスを利用するときは、try-with-resources 文で後処理をする

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //inputStreamに対する処理を記載
  }
  ```

* リソース解放を必要とするクラスを作成する場合は`AutoCloseable`を`implements`する\
  `AutoCloseable`を`implements`することで try-with-resources 文が利用できるようになります。

## 例外

* catch 文で受け取る例外は、詳細な例外クラスで受け取る

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //・・・
  } catch (IOException e) {
      log.error("Error", e);
      throw e;
  }
  ```

  悪い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //・・・
  } catch (Exception e) {//範囲が広すぎる例外クラスの利用はNG
      log.error("Error", e);
      throw e;
  }
  ```

* `Exception` クラスのオブジェクトを生成してスローしない

* `catch` ブロックでは基本、例外処理をする。ただし処理を書いてはいけない部分もあるので、その部分については、"`// ignore`" というコメントを記述すること。

* 例外クラスは無駄に定義しない

## ガベージコレクション

* 原則`finalize()`のオーバーライド実装は禁止
* もし`finalize()`をオーバーライドした場合は`super.finalize()` を呼び出す
* アプリケーションから`finalize()`を呼び出さない

# コメント規約

## よいコメントの鉄則

* コードを明確化するコメントを書く\
  コードにコメントを書く理由は、自分自身、一緒に仕事をしている人、後に関わる開発者にとってコードをより理解しやすいものにするためである。

* コメント化する価値がないプログラムならば、実行するに値しない\
  有用な格言。コメントは必須。

* 過剰な装飾は使わない （例：見出し状のコメント）\
  1960 年代から 1970 年代の典型的な COBOL プログラマにはアスタリスク( `*` )でコメントを囲った箱を書く習慣があった。彼らの芸術的な主張を表わしているのかもしれないが、率直に言えばそれは製品に加わるちょっとした価値に比べれば大きな時間の無駄である。かわいいコードではなくきれいなコードを書くはずである。さらに、コードを表示するディスプレイや印刷するプリントに使われるフォントはプロポーショナルだったりそうでなかったりして、箱をきれいに整列させることは難しい。

* コメントはシンプルに\
  かつて見たもっとも最良のコメントは、シンプルな要点をまとめた注釈であった。なにも本を書く必要はなく、他の人がコードを理解するに十分な情報を提供するだけでよいのである。

* コードを書く前に先にコメントを記述する\
  コードをコメント化する最良の方法は、コードを書く前にコメントを書くことである。それが、コードを書く前にコードがどのように動作するかについて考えるよい機会となり、コメントの存在を保障することにもつながる。少なくともコードを書いた時にコメントすべきである。コメントによってコードが理解しやすくなることで、コードの開発中にアドバンテージを得ることができる。コードにコメントを書く時間を費やせば、それによって得られるものがある。

* コメントには、なぜそうなのかを書く。コードを読めば分かることを書かない\
  基本的に、コードの一部分を見ればそれが何かを理解することはできる。例えば、以下のコードを見て、$1000 以上の注文については 5%ディスカウントされることは理解できる。なぜそうなのか？大きな注文ではディスカウントがつきものだというビジネスルールがあるのだろうか？大きな注文に時間限定サービスがあるのか、それともずっとサービスがあるのか？これを書いたプログラマの気前がよかったのか？\
  どこかソースコード中か別な文書にコメントされていない限り、それがなぜなのかを知ることはできない。

  ```java
  if (grandTotal >= 1000.00) {
      grandTotal = grandTotal * 0.95;
  }
  ```

  なお、メソッドコメントには、適切な javadoc コメント（タグ）のほかに、以下の内容も可能な限り明記すること。

  * 副作用のある処理の場合は、その内容　（→ メソッドの引数オブジェクトがメソッド内で変更されるケースなど）
  * 既知のバグ　（→ 判明しているが修正しないことにした場合など）
  * 影響のある事前条件、事後条件　（→ メソッドが正しく動作するための前提について）
  * 並行性　（→ 　マルチスレッドでアクセスされた場合の動作について）
  * 該当メソッドの使用例やサンプルコード

* TODO コメント\
  設計者確認待ち、共通処理の作成待ちなどの理由により、実装時に TODO がある場合、下記のようにコメントを記述する。\
  （Eclipse の TODO コメント形式を採用）\
  例）

  ```java
  //TODO：ワークフローの仕様決定待ち　関連チケット#12345
  ```

## Java コメント（3 種類）の使い分け

Java では 3 種類のコメントが使える。javadoc コメントは`/**`で開始され、`*/`で終わる。C 風コメントは`/*`で開始され`*/`で終わる。単一行コメントは`//`で開始され、そのソースコード行が終わるまで続く。以下の表ではコメントの使い方とその例を示す。（コメントのスタイルに関しては、前述の「標準規約に準拠したコーディング例」を参照）

| コメント種類                         | 使用方法                                                                                                                                                                                              | 例                                                                                                                                                                                                 |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| javadoc コメント`/** comment */` | interface、class、メソッド、フィールドの直前に書く。コメントは javadoc によって処理され、外部ドキュメント(HTML)として生成される。（この形式以外のコメントはドキュメントとして出力されないことに注意） | /\*\* \* 顧客（Customer）- \* 顧客はわれわれがサービスまたは製品を売った人物 \* もしくは組織のいずれかである。 \* @author 開発太郎 \*/       |
| C 風コメント`/* comment */`      | 特定のコードを無効化したいが、後で使用するかもしれないので残しておくためにコメント化する時や、デバッグ時に一時的に無効化するときに使用する。                                                          | /\*  このコードは J.T.Kirk によって 1997.12.9 に前述のコードと置き換えたためコメント化した。2 年間不要であるならば削除せよ。 ... (ソースコード)  \*/ |
| 単一行コメント`// comment`       | メソッド内にて、ビジネスロジック、コードの概要、一時変数の定義内容などを記述する。                                                                                                                    | // 1995 年 2 月に開始された X 氏の寛大なキャンペーンで// 定められた通り 1000$を超える請求には、全て 5%割引を// 適用する。                                |

※ ロジック中に、頻繁に C 風コメントでコメントを書くとまとめてコメントアウトする場合に不便なため、基本的にロジック中では単一行コメントを利用すること。

# パフォーマンス

パフォーマンスを考慮した Java のコーディングについて以下に示す。

※ パフォーマンスは jre のバージョンやスペックによって変化します。本内容は jre1.8.0\_74 での検証結果を元にした内容です。

※ 性能計測結果についての記載がありますが、あくまでも参考値です。性能を保証するものではありません。

## Stream API

Java8 で追加された Stream API での記述は、可読性も高く、簡潔に書けますが、パフォーマンス・性能面で注意が必要な場合があります。

List の処理を行う際、拡張 for 文で処理する場合は Iterator インスタンスが 1 つだけ生成されますが、Stream API で処理する場合、最初の Stream インスタンスに加え、各中間処理ごとにも Stream インスタンスが生成され、その分の性能劣化が懸念されます。\
以下に処理例と計測結果を記載します。

* 拡張 for 文

  ```java
  List<String> list = //数値文字列のList
  List<String> resultList = new ArrayList<>();
  for (String string : list) {
      if (string.endsWith("0")) {
          resultList.add(string);
      }
  }
  return resultList;
  ```

* Stream API

  ```java
  List<String> list = //数値文字列のList
  List<String> resultList = list.stream()
      .filter(s -> s.endsWith("0"))
      .collect(Collectors.toList());
  return resultList;
  ```

* 計測結果

  | 処理する List の件数 | 拡張 for 文 (ms) | StreamAPI (ms) |
  | -------------------: | ---------------: | -------------: |
  |             100 万件 |                7 |              9 |
  |           1,000 万件 |               88 |            114 |
  |               1 億件 |              949 |          1,026 |
  |               2 億件 |            1,822 |          2,081 |

小中規模の処理量であれば考慮するほどの性能差はありませんが、大量の処理が見込まれる場合は考慮が必要です。\
また、Stream API は並列処理（スレッド処理）の機能をサポートしていますので、利用できる場合は並列処理も含めての検証が必要です。

## ラムダ式・メソッド参照・コンストラクタ参照

Java8 で追加されたラムダ式・メソッド参照・コンストラクタ参照は、匿名クラスを利用するよりも効率的です。\
積極的な利用を推奨します。

以下に Comparator を生成した場合の計測結果を記載します。

* 匿名クラス

  ```java
  Comparator<String> c = new Comparator<String>() {
      @Override
      public int compare(String o1, String o2) {
          return o1.compareToIgnoreCase(o2);
      }
  };
  ```

* ラムダ式

  ```java
  Comparator<String> c = (o1, o2) -> o1.compareToIgnoreCase(o2);
  ```

* メソッド参照

  ```java
  Comparator<String> c = String::compareToIgnoreCase;
  ```

* 計測結果

  | 処理件数 | 匿名クラス (ms) | ラムダ式 (ms) | メソッド参照 (ms) |
  | -------: | --------------: | ------------: | ----------------: |
  |  10 億回 |             380 |   0(計測不能) |       0(計測不能) |
  | 100 億回 |           6,374 |   0(計測不能) |       0(計測不能) |
  |   1 京回 |     (30 秒以上) |            14 |                10 |

ラムダ式は外部の変数を利用する場合、匿名クラスとほぼ同じ動作をします。

* 匿名クラス

  ```java
  new Comparator<String>() {
          @Override
          public int compare(String o1, String o2) {
              return arg.equals("DESC") ? o2.compareToIgnoreCase(o1)
                                              : o1.compareToIgnoreCase(o2);
          }
      }
  ```

* ラムダ式

  ```java
  Comparator<String> c = (o1, o2) -> arg.equals("DESC") ? o2.compareToIgnoreCase(o1)
                                      : o1.compareToIgnoreCase(o2);
  ```

* 計測結果

  |                   処理件数 | 匿名クラス (ms) | ラムダ式 (ms) |
  | -------------------------: | --------------: | ------------: |
  |  10 億回（パラメータあり） |             571 |           572 |
  | 100 億回（パラメータあり） |           9,900 |         9,864 |

## 文字列連結

### 文字列連結（繰り返し）

文字列連結を繰り返し処理中で行う際、`+`演算子で処理することはアンチパターンとして知られています。\
繰り返し処理中の文字列連結は、 `StringBuilder`、 `StringJoiner`、 `StringBuffer` を利用します。\
また、コレクション要素の結合であれば`String#join`が利用できます。

以下に処理例と計測結果を記載します。

* `+`演算子

  ```java
  String s = "";
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          s += ",";
      }
      s += string;
  }
  return s;
  ```

* StringBuilder

  ```java
  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          sb.append(",");
      }
      sb.append(string);
  }
  return sb.toString();
  ```

* StringBuffer

  ```java
  StringBuffer sb = new StringBuffer();
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          sb.append(",");
      }
      sb.append(string);
  }
  return sb.toString();
  ```

* String#join

  ```java
  return String.join(",", list);
  ```

* 計測結果

  | 処理する List の件数 | `+`演算子 (ms) | StringBuilder (ms) | StringBuffer (ms) | String#join (ms) |
  | -------------------: | -------------: | -----------------: | ----------------: | ---------------: |
  |             1,000 件 |              5 |        0(計測不能) |       0(計測不能) |      0(計測不能) |
  |               1 万件 |          1,016 |                  1 |                 1 |                1 |
  |              10 万件 |    (30 秒以上) |                  2 |                 5 |                5 |
  |             100 万件 |    (30 秒以上) |                 29 |                42 |               51 |

### 文字列連結（定数）

基本的に処理中の文字列連結では`+`演算子は使わないで処理するほうがパフォーマンスが高くなりますが、定数の場合は`+`演算子で定義するほうがパフォーマンスが高いです。

たとえば以下のように、処理したい場合、

```java
private static final String CONST_A = "A";
private static final String CONST_B = "B";
private static final String CONST_AB = CONST_A + CONST_B;
```

StringBuilder で処理しようとすると以下のようになります。

```java
private static final String CONST_AB = new StringBuilder(CONST_A).append(CONST_B).toString();
```

しかし、これらをバイトコード上で確認するとそれぞれ以下のようになります。

* `+`演算子

  ```java
  private static final java.lang.String CONST_AB = "AB";
  ```

* StringBuilder

  ```java
  private static final java.lang.String CONST_AB;

  static {};
     0  new java.lang.StringBuilder [20]
     3  dup
     4  ldc <String "A"> [8]
     6  invokespecial java.lang.StringBuilder(java.lang.String) [22]
     9  ldc <String "B"> [11]
    11  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [26]
    14  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [30]
    17  putstatic jp.co.packagename.ClassName.CONST_AB : java.lang.String [34]
    20  return
  ```

`+`演算子を利用した場合コンパイル時に最適化され、文字列`"A"`と`"B"`をあらかじめ結合して class が作成されます。\
`StringBuilder`を利用した場合は最適化はされず、記述した通りの処理が行われます。

計測した場合、下記のようになります。

* 計測結果

  |   処理回数 | StringBuilder (ms) | `+`演算子 (ms) |
  | ---------: | -----------------: | -------------: |
  | 5,000 万回 |                559 |    0(計測不能) |
  |     1 億回 |              1,059 |    0(計測不能) |

通常、定数処理を大量に処理することは考えられないので性能問題になることはありませんが、`+`演算子を利用したほうがパフォーマンスが高いこともあるということを理解してください。

## List の種類

`List`には`ArrayList`のような`RandomAccess`を implements した、ランダムアクセスをサポートしているクラスと、\
`LinkedList`のようなランダムアクセスをサポートしていない（シーケンシャルアクセス）クラスが存在します。\
`RandomAccess`ではない`List`は、`List#get`などインデックスを利用するような操作のパフォーマンスが低いので注意してください。

以下に処理例と計測結果を記載します。

* for 文(List#get(int)によるループ)

  ```java
  int size = list.size();
  for (int i = 0; i < size; i++) {
      String s = list.get(i);
      //処理
  }
  ```

* 拡張 for 文

  ```java
  for (String s : list) {
      //処理
  }
  ```

* forEach

  ```java
  list.forEach(this::処理);
  ```

* 計測結果

  | 処理する List の件数 | `ArrayList`for 文(List#get(int)によるループ) (ms) | `LinkedList`for 文(List#get(int)によるループ) (ms) | `ArrayList`拡張 for 文 (ms) | `LinkedList`拡張 for 文 (ms) | `ArrayList`forEach (ms) | `LinkedList`forEach (ms) |
  | -------------------- | ----------------------------------------------------: | -----------------------------------------------------: | ------------------------------: | -------------------------------: | --------------------------: | ---------------------------: |
  | 1 万件               |                                           0(計測不能) |                                                     73 |                     0(計測不能) |                      0(計測不能) |                 0(計測不能) |                  0(計測不能) |
  | 10 万件              |                                           0(計測不能) |                                                  7,576 |                     0(計測不能) |                      0(計測不能) |                           1 |                            2 |
  | 20 万件              |                                           0(計測不能) |                                                 17,740 |                     0(計測不能) |                      0(計測不能) |                 0(計測不能) |                  0(計測不能) |
  | 50 万件              |                                           0(計測不能) |                                            (30 秒以上) |                     0(計測不能) |                                2 |                 0(計測不能) |                            2 |
  | 100 万件             |                                                     1 |                                            (30 秒以上) |                     0(計測不能) |                                4 |                 0(計測不能) |                            4 |
  | 1,000 万件           |                                                    16 |                                            (30 秒以上) |                               8 |                               45 |                           6 |                           44 |

ランダムアクセスをサポートしている`List`がシーケンシャルアクセス（iterator を利用した処理など）で遅いということはないので、\
ループの処理は拡張 for 文等、Iterator によるループで記述するのが無難です。\
`List#get`での処理をすべて禁止することはできませんが、高いパフォーマンスが求められる場合は`List`の種類にも注目してみてください。

## String から Integer・Long への変換

数値文字列の`String`を`Integer`に変換するには、`Integer#valueOf(String)`を利用して下記のように記述します。

```java
String s = "1";
Integer value = Integer.valueOf(s);
```

しかし、下記のようにも記述できます。

```java
String s = "1";
Integer value = new Integer(s);
```

これらの違いは、\
`new Integer(s)`とした場合、必ず Integer インスタンスが生成されますが、\
`Integer.valueOf(s)`とした場合は -128 から 127 の間の数値であればキャッシュから取り出すためインスタンスを生成しません。

このため、前者の`Integer#valueOf(String)`を利用した記述のほうが効率的です。\
`Long#valueOf(String)`も同様です。

性能差が少ないため、ほとんど問題にはなりませんが、FindBugs 等、静的解析で検出される問題のため、理解が必要です。

また、String からの変換だけでなく、int や long からの変換も`#valueOf`が効率的ですが、オートボクシングを利用した場合、コンパイルで自動的にこれらの処理に変換されるため、記述することはありません。

## String から int・long への変換

数値文字列の`String`を`int`に変換するには、`Integer#parseInt(String)`を利用して下記のように記述します。

```java
String s = "1";
int value = Integer.parseInt(s);
```

しかし、オートボクシングが利用できるため、意図せず下記のように記述ミスをする場合があります。

```java
String s = "1";
int value = Integer.valueOf(s);//取得したIntegerインスタンスをオートボクシングでintにcastしている
```

```java
String s = "1";
int value = new Integer(s);//生成したIntegerインスタンスをオートボクシングでintにcastしている
```

「オートボクシング」の説明に記載した通り、性能に差が出るだけでなく、\
記述から明らかにミスであることが解るため、FindBugs 等、静的解析で検出されるコードです。

`long`への変換の場合は`Long#parseLong(String)`を利用します

以下に計測結果を記載します。

* 計測結果

  |   処理回数 | Integer.valueOf(String) (ms) | Integer#parseInt(String) (ms) |
  | ---------: | ---------------------------: | ----------------------------: |
  | 1,000 万回 |                          396 |                           318 |
  |     1 億回 |                        4,060 |                         3,077 |

## BigDecimal の ZERO との比較

BigDecimal の正・負・ZERO の判定は`BigDecimal#signum`を利用します。\
`compareTo`を利用して`BigDecimal.ZERO`と比較しても同じことができますが、`signum`を利用したほうが効率的です。

以下に処理例と計測結果を記載します。

* compareTo 利用

  ```java
  BigDecimal value = new BigDecimal("0.0");
  if (value.compareTo(BigDecimal.ZERO) == 0) {
  ```

* signum 利用

  ```java
  BigDecimal value = new BigDecimal("0.0");
  if (value.signum() == 0) {
  ```

* 計測結果

  （単位：マイクロ秒）

  | 処理回数 | compareTo 利用 (マイクロ秒) |   signum 利用 (マイクロ秒) |
  | -------: | --------------------------: | -------------------------: |
  |   1 京回 |  527max:26,367min:0 | 424max:21,213min:0 |

性能差が少ないので、必ずしも signum を利用する必要はありませんが、大量に処理する場合など、高いパフォーマンスが求められる場合は意識してください。

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)

---

---
url: /coding-standards/documents/forJava/Javaコーディング規約_for_17.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。\
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。\
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# はじめに

一般に利用・参照されている Java コーディング規約やガイドラインを以下に示す。本規約の作成においても、下記規約類を参照・抜粋している。

| 規約                                                   | 著作者               | URL                                                                                                                                 |
| ------------------------------------------------------ | -------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| Code Conventions for the Java Programming Language     | Sun Microsystems     | <http://www.oracle.com/technetwork/java/codeconvtoc-136057.html>                                                                    |
| Writing Robust Java Code                               | Scott W. Ambler      | <http://www.ambysoft.com/downloads/javaCodingStandards.pdf>                                                                         |
| オブジェクト倶楽部版 Java コーディング標準             | オブジェクト倶楽部   | <http://objectclub.jp/community/codingstandard/CodingStd.pdf>                                                                       |
| 電通国際情報際サービス版 Java コーディング規約 2004    | 電通国際情報サービス | <http://objectclub.jp/community/codingstandard/JavaCodingStandard2004.pdf>                                                          |
| JJGuideline （Java - J2EE Conventions and Guidelines） | Stephan.J & JCS Team | <http://www.fedict.belgium.be/sites/default/files/downloads/Java_J2EE_conventions_and_guidelines_EN.pdf>※現在は削除されています |
| Google Java Style (非公式和訳)                         | Google               | <https://kazurof.github.io/GoogleJavaStyle-ja/>                                                                                     |
| Acroquest Technology Java コーディング規約             | Acroquest Technology | <https://www.acroquest.co.jp/webworkshop/javacordingrule/Acroquest_JavaCodingStandard_6_7.pdf>※現在は削除されています           |

※ Sun Microsystems の規約は Java 草創期から一応の標準という位置づけだったが、オブジェクト指向、及び、その開発環境の普及・発展によって、設計やコーディングにおいて、直接的に有用な知識や豊富な指針を含むような優れた規約や、ツールなどによる機械的な準拠チェックと連携する規約が普及してきている。

# 規約の重要性

標準としての規約を定義し、遵守することの重要性を以下に示す。

* ソフトウェアメンテナンスにおける、可読性・保守性・拡張性の向上
* 問題を起こしやすい実装を未然に回避することによる、品質・生産性の向上
* 標準規約を通して得られる一般的な実装知識やノウハウ（＝学習効果）

## コーディングの心得

長いプログラムを記述すること（ステップ数）によって生産性が評価されたのは、過去の時代の出来事である。現在は、クラスやメソッドの役割が明確で、ロジックが読みやすく、保守性に優れたプログラムを記述することが評価される。コーディング規約は、コードの書き方に関する一種のパターンと考えることもでき、コードの保守性を向上させる具体的な方法を示している。したがって、規約の一つ一つの意図を理解し、守ることが重要になる。しかし、保守性に優れたコードを作成するためには、コーディング規約を守ることに加えて、良いコードを記述するための基本的な心構えをしっかり心に留めておく必要がある。以下では、その心得について述べる。

【コーディングの心得 5 か条】

1. 見やすさを重視せよ
2. ネーミングはわかりやすく
3. サンプルを鵜呑みにしない
4. 同じコードを二度書かない
5. 役割は一つに

### 見やすさを重視せよ

「良いコード」の基本は、「他の人が読んでもわかりやすいと感じられるコード」。コードの見やすさは、フォーマットはもちろん、ロジックの簡潔さや API の常識的な使い方などから生まれる。コーディングにあたっては、常に他の人の視点を意識しながら、見やすさに気を配って記述する必要がある。例えば、自分で記述したコードであっても、しばらくたってから読み返してみると理解に時間がかかった経験は誰にもあるはず。「3 日前に書いたコードは他人のコードと同じ」ということもよく言われる。見やすさを重視することは、他の人のためだけでなく自分のためにもなる。コードを読んでもすぐに理解できないような実装は、再考（リファクタリング）の必要がある。

### ネーミングはわかりやすく

コーディングでは、様々な変数やメソッドなどにネーミング（名前付け）する必要がある。ネーミングとは、本来、その対象の本質を表すような名前を考える作業である。大変難易度の高い作業だが、一方で適当に行ってもコードの動作は変わらないため、人によっては手を抜きがちとなる。しかし、ネーミングの良し悪しは、コードの可読性に非常に大きな影響を及ぼす。例えば、「C0001」というクラス名があるとする。これでは、何を表すクラスなのかすぐにはわからないだろう。また、「int p = 5000;」という記述があるとする。プログラマに聞くと、変数名 p は価格(Price)の略だと言うのだが、それならば略さずに、「int price = 5000;」としたほうが分かりやすいはずである。「ネーミングはわかりやすく」の背景には、読んで内容が理解できるという意味で、文章のようなプログラミングを行う、という考え方に基づく。

### サンプルを鵜呑みにしない

サンプルコードを活用すること自体は、著作権等を侵害しなければ問題ない。問題なのは、その内容や背景を理解しないまま、サンプルコードだけを鵜呑みにして、「おまじない」として表面的に適用してしまうことである。コードを「おまじない」ととらえていては、サンプルコードの間違いを気づかないまま適用してしまうこともある。例えば、ストリームのクローズ処理を行っていないサンプルコードであっても、それに気づかずに自分のコードに適用してしまい、後で思わぬ障害を引き起こすという可能性がある。サンプルコードは、そこで説明する内容に絞ったコードが多いため、このような例はよく見られる。また、サンプルコードをそのまま適用した結果、自分が記述すべきコードには必要のないコードが含まれてしまう場合もある。その場合、コードの可読性を下げる原因となる。自分のコードは、自分で深く理解して記述すべきである。

### 同じコードは二度書かない

コードをコピー・ペーストしていませんか？コピー・ペーストしてしまうと、何らかの修正をする際に、全ての個所に同じ修正をする羽目になる。同じコードが現れるようならまとめて一つにし、外に出してコールするような書き方にすべきである。同じコードをまとめる作業は、どちらかといえば、コーディング時よりリファクタリング（ソフトウェアの外部的振る舞いを変更せずに内部構造を改善する作業）で行われることが多い。しかし、コーディング時からできるだけ気をつけておきたいことでもある。

### 役割は一つに

メソッドの役割が明確で、かつ 1 つであれば単体テストが行いやすくなる。つまり、コードの「試験性」が高まる。また、役割が一つであれば、後でコードを変更する際に修正箇所がわかりやすいため、障害修正に要する時間が短くなる。つまり、コードの「保守性」があがることになる。例えば、「チェックをして実行する」機能を実現するために、checkAndDo()メソッドが存在したとする。この場合、このメソッドは check()メソッドと do()メソッドに分割すべきである。なぜなら、checkAndDo()メソッドの check()ロジックに誤りがあった場合、do()メソッドに書かれる内容まで把握する必要が生じるためである。分割してあれば、check()メソッドだけの変更で済む。このことはクラスの設計にもあてはまる。

# ネーミング規約

## 全般

* 大文字・小文字の違いで名前を区別しない。

  良い例：

  ```java
  private int carNumber;
  private int trainNumber;
  ```

  悪い例：

  ```java
  private int num;
  private int Num;
  ```

## パッケージ

* パッケージ名はすべて小文字にする
* パッケージ名は意味のある名前にする
* サブパッケージ名の重複は可能

## クラス

* クラス名は単語の先頭を大文字にする\
  良い例：

  ```java
  public class Entry {
  ```

  悪い例：

  ```java
  public class entry {
  ```

* インターフェース名、Enum 名、Record 名はクラス名に準ずる

## メソッド

* コンストラクタと同じ名前のメソッドはつくらない

* メソッド名は区切りのみ大文字にする\
  良い例：

  ```java
  public String getName() {
      //・・・
  }
  ```

  悪い例：

  ```java
  public String getname() {
      //・・・
  }
  public String GETNAME() {
      //・・・
  }
  ```

* 変換メソッド名は「"`to`"+オブジェクト名」にする\
  良い例：

  ```java
  public String toString() {
  ```

  悪い例：

  ```java
  public String string() {
  ```

* ゲッターメソッド名は「"`get`"+属性名」にする\
  型が`boolean`の場合は「"`is`"+属性名」にする

* セッターメソッド名は「"`set`"+属性名」にする

* `boolean`変数を返すメソッド名は`true`/`false`の状態がわかるようにする

  良い例：

  ```java
  public boolean isAsleep() {
  }
  public boolean exists() {
  }
  public boolean hasExpired() {
  }
  ```

## 引数

* メソッドのパラメータ名とインスタンス変数名を一緒にしない\
  ただし、アクセサメソッドやコンストラクタなど、統合開発環境の機能により自動生成するものに関しては可とする。\
  アンダースコア　`_`　をつけての区別は原則禁止とする。

  良い例：

  ```java
  public double calc(double rate) {
      return this.value * rate;
  }
  ```

  悪い例：

  ```java
  public double calc(double value) {
      return this.value * value;
  }

  public double calc(double _value) {
      return this.value * _value;
  }
  ```

## 変数全般

* `boolean`変数は`true`/`false` の状態がわかるようにする

  良い例：

  ```java
  private boolean isOpen;
  ```

  悪い例：

  ```java
  private boolean flag;
  ```

* 定数は全て`static final`とし、すべて大文字、区切りは"`_`"

  良い例：

  ```java
  private static final String SYSTEM_NAME = "販売管理システム";
  ```

* 変数名は小文字とし、単語の区切りのみ大文字にする

  良い例：

  ```java
  private String thisIsString;
  ```

  変数名に固有名詞が含まれる場合、先頭をのぞき、単語の区切り以外に大文字を使用してもよい

  良い例：

  ```java
  private String thisIsIPAddress;
  ```

## ローカル変数

* スコープが狭い変数名は省略した名前でもよい\
  良い例：

  ```java
  if (・・・) {
      String s = "・・・・";
     //変数sを利用した処理 数行
  }
  ```

  悪い例：

  ```java
  String s = "・・・・";
  if (・・・) {
     //変数sを利用した処理
  }
  ・・・
  if (・・・) {
     //変数sを利用した処理
  }
  ```

  変数`s`の利用範囲が広いので役割が明確になる変数名に変更する。

* for 文のループカウンタは、ネストごとに"`i`","`j`","`k`"・・・を使う

## Enum

* Enum 名はクラス名と同じく、単語の先頭を大文字にする
* 列挙定数は定数と同じく、すべて大文字、区切りは"`_`"

  良い例：

  ```java
  enum Season {
      WINTER,
      SPRING,
      SUMMER,
      FALL
  }
  ```

  悪い例：

  ```java
  enum Season {
      winter,
      spring,
      summer,
      fall
  }
  ```

# コーディング規約

## 全般

* 原則としてオブジェクトの参照にはインターフェースを利用する\
  オブジェクトを参照する際は、そのオブジェクトの実装クラスを用いて宣言できるが、実装クラスに適切なインターフェースが存在している場合は、必ずインターフェースを用いて宣言すること。

  良い例：

  ```java
  List<Entry> list = new ArrayList<>();
  Map<String, String> map = new HashMap<>();
  ```

  悪い例：

  ```java
  ArrayList<Entry> list = new ArrayList<>();
  HashMap<String, String> map = new HashMap<>();
  ```

* 推奨されない API を使用しない\
  アノテーション`@Deprecated`で指定されたメソッドは利用しないこと。

* 使われないコードは書かない

* 宣言は適切な権限で行うこと（`public`, `protected`, `private`）

* `final` を適切に利用する\
  継承されないクラス、オーバーライドされないメソッド、値の変わらない変数（つまり定数）等、変化のないもの/変化させたくないものについては`final` で宣言する。

  良い例：

  ```java
  //継承されないクラス
  public final class CalculateUtils {
      //・・・
  }

  //値の変わらない変数（定数）
  private static final String MESSAGE = "・・・";

  //オーバーライドされないメソッド
  public final int sum(/*変化させたくない値*/final int... values) {
      int sumValue = 0;
      for (/*変化させたくない値*/final int value : values) {
          sumValue += value;
      }
      return sumValue;
  }
  ```

## フォーマット

* インデントは空白文字 4 文字分の Tab を使用する

* 長すぎる行は避ける

* `{` の後にステートメントを記述しない\
  良い例：

  ```java
  if (s == null) {
      return 0;
  }
  ```

  悪い例：

  ```java
  if (s == null) {return 0;}
  ```

* 1 行に 2 つ以上のステートメントを記述しない\
  悪い例：

  ```java
  } catch (Exception e) {
      log.error("Error", e);return null;
  }
  ```

* カンマの後には空白文字を\
  良い例：

  ```java
  process(x, y, z);
  ```

  悪い例：

  ```java
  process(x,y,z);
  ```

* 代入演算子（ `=` , `+=` , `-=` , …）の前後には空白文字を挿入する\
  良い例：

  ```java
  int a = x;
  a += 10;
  ```

  悪い例：

  ```java
  int a=x;
  a+= 10;
  ```

* for 文内のセミコロンの後には空白文字を挿入する\
  良い例：

  ```java
  for (int i = 0; i < array.length; i++) {
      //・・・
  }
  ```

  悪い例：

  ```java
  for (int i = 0;i < array.length ;i++) {
      //・・・
  }
  ```

* `++` や `--` とオペランドの間には空白文字を入れない\
  良い例：

  ```java
  i++;
  ```

  悪い例：

  ```java
  i ++;
  ```

* ビット演算子（ `|` 、 `&` 、 `^` 、 `<<` 、 `>>` ）の前後には空白文字を挿入する

* 論理演算子（ `||` 、`&&`）の前後には空白文字を挿入する

* 関係演算子（ `<` 、 `>` 、 `>=` 、 `<=`、`==`、 `!=` ）の前後には空白文字を挿入する

* 算術演算子（ `＋` 、 `－` 、 `＊` 、 `/` 、 `%` ）の前後には空白文字を挿入する

* return 文ではカッコを使わない\
  良い例：

  ```java
  int answer = (a + b + c) * d;
  return answer;
  ```

  悪い例：

  ```java
  return ((a + b + c) * d);
  ```

* if などの条件式で boolean の変数を比較しない

  良い例：

  ```java
  if (hasStock)
  ```

  悪い例：

  ```java
  if (hasStock == true)
  ```

* 不等号の向きは左向き（ `<` 、 `<=` ）にする\
  良い例：

  ```java
  if (from <= x && x <= to) {
  ```

  悪い例：

  ```java
  if (x >= from && x <= to) {
  ```

## コメント

* ファイルの先頭への Copyright の表記について\
  ソースのファイルヘッダにコピーライト標記は法的拘束力がないため、不要とする。\
  ただし、顧客からの要求があった場合を除く。

* Javadoc コメントには、少なくとも author と version(クラス)、param と return と exception(メソッド)を記述する
  * 今後もバージョンアップのリリースが予定されているソースでは、上記に加えて since（バージョン）を記述する
  * `@Override`のあるメソッドでは、上記に加えて`{@Inherit}`を記述する

* Javadoc 　クラスヘッダコメントのフォーマットは以下の通り

  良い例：

  ```java
  /**
   * Action（or Bean）クラス　メニュー名称
   *
   * @author 姓 名
   * @version バージョン YYYY/MM/DD 説明
   */
  ```

* コメントは必要なものだけを簡潔に\
  悪い例：

  ```java
  /**
   * 文字列に変換
   */
  @Override
  public String toString() {

  /**
   * コピー
   *
   * @return コピーしたインスタンス
   */
  public Entry copy() {
  ```

* 不要なコメントは記載しない
  * コードからすぐわかること・冗長なコメント
  * 名前の説明\
    コメントではなくわかりやすい名前を付ける。
  * 別システムで管理している内容\
    ソースコード管理システム、バグトラッキングシステムで管理している内容はソースコードにコメントで記載する必要はない。
    * コメントアウトされたコード\
      ソースコード管理システムで管理されている

## インポート

* `java.lang`パッケージはインポートしない

  悪い例：

  ```java
  import java.lang.String;//必要のない記述
  ```

* 原則として static インポートしない\
  JUnit の作成やフレームワークとして static インポートが推奨されるような場合は利用してもよい

* 原則としてオンデマンドのインポート宣言(type-import-on-demand declaration)（アスタリスク`*`によるインポート） は行わない

  悪い例：

  ```java
  import java.util.*;
  ```

## コンストラクタ

* public 宣言していないクラスには`public`権限のコンストラクタを作らない\
  良い例：

  ```java
  class Entry {
      //・・・
      Entry(int id) {
          //・・・
      }
  ```

  悪い例：

  ```java
  class Entry {
      //・・・
      public Entry(int id) {
          //・・・
      }
  ```

* インスタンスメンバを持たない（static メンバのみの）クラスは、`private`権限のコンストラクタを作成する

## メソッド

* オーバーライドさせたくないメソッドは`final`を利用する

* 戻り値が配列のメソッドで、戻る配列のサイズが 0 の場合、メソッドを使用するクライアントの余計な null チェックのロジックを回避するため、null ではなく長さゼロの配列を戻すようにする。
  良い例：

  ```java
  public String[] toArray(String s) {
      if (s == null || s.isEmpty()) {
          return ArrayUtils.EMPTY_STRING_ARRAY;
      }
      return new String[] { s };
  }

  public List<String> toList(String s) {
      if (s == null || s.isEmpty()) {
          return Collections.emptyList();
      }
      return List.of(s);
  }
  ```

  悪い例：

  ```java
  public String[] toArray(String s) {
      if (s == null || s.isEmpty()) {
          return null;
      }
      return new String[] { s };
  }

  public List<String> toList(String s) {
      if (s == null || s.isEmpty()) {
          return null;
      }
      return List.of(s);
  }
  ```

* メソッドは 1 つの役割にする

## クラスメソッド

* クラスメソッドを利用するときは、クラス名を使って呼び出す\
  良い例：

  ```java
  int comp = Integer.compare(x, y);
  ```

  悪い例：

  ```java
  Integer a = //
  int comp = a.compare(x, y);
  ```

## 変数全般

* 1 つのステートメントには 1 つの変数宣言\
  良い例：

  ```java
  /** 科目コード */
  private String code;
  /** 科目名 */
  private String name;
  /** 科目略名 */
  private String shortName;
  ```

  悪い例：

  ```java
  private String code, name, shortName;
  ```

* リテラルは使用しない\
  リテラルとは、コード中に、表現が定数として直接現れており、記号やリストで表現することができないものを指す（数値、文字列両方含む　通称マジックナンバー）。コードの可読性・保守性の低下を防ぐために、リテラル定数（`static final` フィールド）を使用すること。\
  例外：`-1`,`0`,`1` 等をカウント値としてループ処理等で使用するような場合

  良い例：

  ```java
  private static final double ONE_MILE_METRE = 1609.344;

  public double mileToMetre(double mi) {
      return mi * ONE_MILE_METRE;
  }
  ```

  悪い例：

  ```java
  public double mileToMetre(double mi) {
      return mi * 1609.344;
  }
  ```

  * リテラル定数の名前はその値の意味を正しく表現したものにする

    悪い例：

    ```java
    private static final int ZERO = 0;
    ```

* 配列宣言は「`型名[]`」にする

  良い例：

  ```java
  private int[] sampleArray = new int[10];
  ```

  悪い例：

  ```java
  private int sampleArray[] = new int[10];
  ```

* できるだけローカル変数を利用する\
  ローカル変数で事足りるものをインスタンス変数として利用するなど、必要のないインスタンス変数を定義すると、パフォーマンスや可読性の低下やの大きな要因となる上、マルチスレッドを意識した際に不整合がおきる可能性があるので、インスタンス変数は必要性を充分に考慮してから使用すること。

* 定数は`final`で宣言する

* ローカル変数とインスタンス変数を使いわける

## 定数

* `public` で宣言するクラス変数とインスタンス変数は、定数のみとし、 `static final` で定義する\
  `final` ではない `static` な定数は作成しない。

  良い例：

  ```java
  public static final String PROTOCOL_HTTP = "http";
  ```

* 定数（ `static` フィールド）に、 `static` ではないメソッドから書き込まない

* 定数は、プリミティブ型もしくは、不変（Immutable）オブジェクトで参照する
  * 不変`List`の生成には`List.of()`を利用する

    良い例：

    ```java
    public static final List<Integer> VALUES = List.of(1, 2, 3, 4, 5);
    ```

    悪い例：

    ```java
    public static final List<Integer> VALUES = Arrays.asList(1, 2, 3, 4, 5);
    ```

  * 不変`Set`の生成には`Set.of()`を利用する

  * 不変`Map`の生成には`Map.of()`を利用する

    良い例：

    ```java
    public static final Map<Integer, String> VALUES_MAP = Map.of(1, "A", 2, "B", 3, "C");
    ```

    悪い例：

    ```java
    public static final Map<Integer, String> VALUES_MAP = new HashMap<>() {
        {
            put(1, "A");
            put(2, "B");
            put(3, "C");
        }
    };
    ```

  * 不変な配列インスタンスは長さ 0 の配列以外は生成不可能なため、外部から参照される（`public`）定数では利用せず、`List`等への置き換えをすること

    良い例：

    ```java
    public static final List<Integer> VALUES = List.of(1, 2, 3, 4, 5);
    ```

    悪い例：

    ```java
    public static final int[] VALUES = { 1, 2, 3, 4, 5 };
    ```

## インスタンス変数

* インスタンス変数は`private`にする

  良い例：

  ```java
  public class Employee {
      private long id;

      //・・・
      //getter/setter
  }
  ```

  悪い例：

  ```java
  public class Employee {
      public long id;

      //・・・
      //getter/setter
  }
  ```

## クラス変数

* `public static final` 宣言した配列を利用しない\
  ※「定数」を参照

* クラス変数にはクラス名を使用してアクセスすること

  良い例：

  ```java
  BigDecimal b = BigDecimal.ZERO;
  ```

  悪い例：

  ```java
  BigDecimal a = //
  BigDecimal b = a.ZERO;
  ```

## ローカル変数

* ローカル変数は利用する直前で宣言する\
  行間の程度にもよるが、ある程度まとめて宣言するのは OK とする。

  良い例：

  ```java
  for (int i = 0; i < lines.length; i++) {
      String line = lines[i];
      //lineの処理
  }
  ```

  悪い例：

  ```java
  String line;
  for (int i = 0; i < lines.length; i++) {
      line = lines[i];
      //lineの処理
  }
  ```

* ローカル変数は安易に再利用しない\
  一度宣言したローカル変数を、複数の目的で安易に使いまわさないこと。ローカル変数は、役割ごとに新しいものを宣言して初期化することにより、コードの可読性・保守性の向上、及びコンパイラの最適化の促進をはかる。

## 引数

* メソッド引数への代入は行わない\
  原則として`final`で宣言する。

  良い例：

  ```java
  public void add(final int value) {
      //・・・
  }
  ```

## 継承

* スーパークラスのインスタンス変数をサブクラスでオーバーライドしない\
  スーパークラスと同じ名前のフィールドをサブクラスで宣言しないこと。 同じ名前のフィールドを宣言すると、スーパークラスのフィールドはサブクラスで宣言されたフィールドによって隠ぺいされてしまうので、他の人の混乱を招くことを防ぐため重複する名前は付けないこと。

  悪い例：

  ```java
  public class Abs {
      protected String name;
  }

  public class Sub extends Abs {
      protected String name;//Abs#nameは隠ぺいされる
  }
  ```

* スーパークラスのメソッドをオーバーライドするときは@Override アノテーションを指定する。

  良い例：

  ```java
  public class Abs {
      protected void process() {

      }
  }

  public class Sub extends Abs {
      @Override
      protected void process() {

      }
  }
  ```

  悪い例：

  ```java
  public class Abs {
      protected void process() {

      }
  }

  public class Sub extends Abs {
      //@Overrideアノテーションの指定がない
      protected void process() {

      }
  }
  ```

* スーパークラスで private 宣言されているメソッドと同じ名前のメソッドをサブクラスで定義しない\
  スーパークラスにある private メソッドと同じ名前のメソッドをサブクラスで定義しないこと。private メソッドはオーバーライドされず全く別のメソッドとして扱われ、他の人の混乱を招き、バグにつながる恐れがある。

## インナークラス

* 原則としてインナークラスは利用しない\
  一つの java ファイルに複数のクラスを記載するのは NG とする。また無名クラスを利用するのも原則として NG とする。\
  Enum の定数固有メソッド実装(constant-specific method implementation)、Java8 のラムダ式は内部的にインナークラスとされるがこれらは許可する。

## メンバー順序

* 以下の順で記述する
  1. static フィールド
  2. static イニシャライザー
  3. static メソッド
  4. フィールド
  5. イニシャライザー
  6. コンストラクター
  7. メソッド

* 同一カテゴリー内では以下の可視性の順で記述する
  1. public
  2. protected
  3. パッケージ private
  4. private

## インスタンス

* オブジェクト同士は`equals()`メソッドで比較する

  良い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1.equals(s2)) {
      //・・・
  }
  ```

  悪い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1 == s2) {
      //・・・
  }
  ```

  ただし Enum の場合は`==`演算子を利用して比較する

  `equals()`メソッドで比較する際、左辺のオブジェクトが null にならないように制御すること。

* Class 名を利用した比較をおこなわない

  良い例：

  ```java
  if (o instanceof Foo f) {
      // ...
  }
  ```

  悪い例：

  ```java
  if ("my.Foo".equals(o.getClass().getName())) {
      Foo f = (Foo)o;
      // ...
  }
  ```

* インスタンスの型キャスト（Class キャスト）が必要な場合はパターンマッチングを使用する

  良い例：

  ```java
  if (o instanceof String s) {
      // ...
  }

  var str = (o instanceof BigDecimal b) ? b.toPlainString() : String.valueOf(o);

  var empty = o == null ||
    (o instanceof String s && s.isEmpty()) ||
    (o instanceof Collection c && c.isEmpty());
  ```

  悪い例：

  ```java
  if (o instanceof String) {
      String s = (String)o;
      // ...
  }

  var str = (o instanceof BigDecimal) ? ((BigDecimal)o).toPlainString() : String.valueOf(o);

  var empty = o == null ||
    (o instanceof String && ((String)o).isEmpty()) ||
    (o instanceof Collection && ((Collection)o).isEmpty());
  ```

## 制御構造

* 制御文（ `if` , `else` , `while` , `for` , `do while` ）の `{ }` は省略しない

  良い例：

  ```java
  if (s == null) {
      return;
  }
  ```

  悪い例：

  ```java
  if (s == null)
      return;
  ```

* ステートメントが無い `{}` ブロックを利用しない\
  悪い例：

  ```java
  //{}内の記述が無い
  if (s == null) {
  }
  ```

* `if` / `while` の条件式で `=` は利用しない\
  良い例：

  ```java
  boolean a =//
  if (!a) {
      //・・・
  }
  ```

  悪い例：

  ```java
  boolean a =//
  if (a = false) {//コーディングミス
      //・・・
  }


  boolean a =//
  boolean b =//
  if (a = b) {//おそらくコーディングミス
      //・・・
  }
  ```

* `for` と `while` の使い分けを意識する

* for 文を利用した繰り返し処理中でループ変数の値を変更しない\
  悪い例：

  ```java
  String[] array = { /*・・・*/ };
  for (int i = 0; i < array.length; i++) {
      //・・・
      i += 2;//NG
  }

  for (String s : array) {
      //・・・
      s = "string";//NG
  }
  ```

* for 文のカウンタは特別な事情がない限り、0 から始める

* 配列やリストなどの全要素に対するループ処理は拡張 for 文を使用する。\
  良い例：

  ```java
  for (int value : array) {
      //・・・
  }

  for (String value : list) {
      //・・・
  }
  ```

* 配列をコピーするときは`Arrays.copyOf()`メソッドを利用する

  良い例：

  ```java
  int[] newArray = Arrays.copyOf(array, array.length);
  ```

  悪い例：

  ```java
  int[] newArray = new int[array.length];
  System.arraycopy(array, 0, newArray, 0, array.length);
  ```

* 繰り返し処理中のオブジェクトの生成は最小限にする

* if 文と else 文の繰り返しや switch 文の利用はなるべく避け、オブジェクト指向の手法を利用する\
  良い例：

  ```java
  CodingKind codingKind = toCodingKind(kind);
  d = codingKind.encode(s);

  //---

  CodingKind codingKind = toCodingKind(kind);
  s = codingKind.decode(d);
  ```

  悪い例：

  ```java
  switch (kind) {
  case 1 ->
      d = encode1(s);
  case 2 ->
      d = encode2(s);
  }

  //---

  switch (kind) {
  case 1 ->
      s = decode1(d);
  case 2 ->
      s = decode2(d);
  }
  ```

* 繰り返し処理の内部で `try` ブロックを利用しない\
  特に理由がない場合は繰り返し処理の外に`try`ブロックを記載する。\
  ただし、繰り返し処理内部で例外をキャッチし処理を行いたい場合は繰り返し処理の内部で`try`ブロックを利用してもよい。

  良い例：

  ```java
  for (String s : array) {
      BigDecimal num;
      try {
          num = new BigDecimal(s);
      } catch (NumberFormatException e) {
          num = BigDecimal.ZERO;
      }
      //・・・
  }
  ```

## 文字列操作

* 文字列同士が同じ値かを比較するときは、`equals()`メソッドを利用する\
  良い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1.equals(s2)) {
      //・・・
  }
  ```

  悪い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1 == s2) {
      //・・・
  }
  ```

* 文字列リテラルは`new` しない\
  良い例：

  ```java
  String s = "";
  ```

  悪い例：

  ```java
  String s = new String();
  ```

* 更新される文字列には`StringBuilder` クラスを利用する\
  良い例：

  ```java
  StringBuilder builder = new StringBuilder();
  for (String s : array) {
      builder.append(s);
  }
  System.out.println(builder.toString());
  ```

  悪い例：

  ```java
  String string = "";
  for (String s : array) {
      string += s;
  }
  System.out.println(string);
  ```

  [※パフォーマンスについても記載しているので参考にしてください](#文字列連結)

* １ステートメントのみで行われる文字列の連結には`+`演算子を利用する

  良い例：

  ```java
  String s = s1 + s2;

  return s1 + s2 + s3 + s4 + s5;
  ```

  悪い例：

  ```java
  String s = new StringBuilder(s1).append(s2).toString();

  return new StringBuilder(s1).append(s2).append(s3).append(s4).append(s5).toString();
  ```

* 更新されない文字列には`String` クラスを利用する

* 文字列リテラルと定数を比較するときは、文字列リテラルの`equals()`メソッドを利用する\
  良い例：

  ```java
  private static final String PROTOCOL_HTTP = "http";

  if (PROTOCOL_HTTP.equals(url.getProtocol())) {

  }
  ```

  悪い例：

  ```java
  private static final String PROTOCOL_HTTP = "http";

  if (url.getProtocol().equals(PROTOCOL_HTTP)) {

  }
  ```

* プリミティブ型と`String` オブジェクトの変換には、変換用のメソッドを利用する\
  良い例：

  ```java
  int i = 1000;
  String s = String.valueOf(i);// "1000"
  s = NumberFormat.getNumberInstance().format(i);// 3桁区切り "1,000"

  boolean b = true;
  s = String.valueOf(b);// true/false
  s = BooleanUtils.toStringOnOff(b);// on/off
  ```

* 文字列の中に、ある文字が含まれているか調べるには、`contains()`メソッドを利用する

* システム依存記号（ `\n` 、 `\r` など）は使用しない。\
  悪い例：

  ```java
  String text = Arrays.stream(array)
      .collect(Collectors.joining("\n"));
  ```

## 数値

* 誤差の無い計算をするときは、`BigDecimal` クラスを使う\
  浮動小数点演算は科学技術計算に利用するもので、誤差が発生する。これに対して、クラス「`BigDecimal`」は、文字列で数値の計算を行うので、金額などの正確な計算に適している。`BigDecimal` ではインスタンス生成時に指定された桁数での精度が保証される。

* 数値の比較は精度に気をつける\
  良い例：

  ```java
  BigDecimal a = new BigDecimal("1");
  BigDecimal b = new BigDecimal("1.0");
  if (a.compareTo(b) == 0) {
      System.out.println("一致");
  }
  ```

  悪い例：

  ```java
  BigDecimal a = new BigDecimal("1");
  BigDecimal b = new BigDecimal("1.0");

  if (a.equals(b)) {
      System.out.println("精度が違うためこの分岐には入らない");
  }
  ```

* 低精度なプリミティブ型にキャストしない

* `BigDecimal`を`String`変換する際は`toString()`ではなく`toPlainString()`を利用すること\
  `toString()`を利用した場合、指数表記になることがあります。

## 日付

* 日付の文字列のフォーマットには、`SimpleDateFormat`または`DateTimeFormatter`を使う\
  良い例：

  ```java
  Date date = new Date();
  SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
  String s = dateFormat.format(date);
  ```

## 三項演算子

* 入れ子の三項演算子の利用は禁止\
  可読性が悪くなるので三項演算子を入れ子で行うのは禁止。

## switch 式

* 一つの値を変数に代入するための if-else 文は代わりに switch 式の使用を推奨する\
  switch 式の値を使用することで変数を不変（実質的 final）にでき、代入箇所が分散することによる可読性の低下を防げます。

  良い例：

  ```java
  var value = switch (op) {
      case "add" -> a + b;
      default -> a - b;
  };
  ```

  悪い例：

  ```java
  int value;
  if (op.equals("add")) {
      value = a + b;
  } else {
      value = a - b;
  }
  ```

* case 句はなるべく一つの式での記述を推奨する\
  複雑な式や複雑なステートメントを記述しなければならない場合は、メソッドに分割することを検討してください。

* switch 式は、コーディングミスによるフォールスルーを避けるため、常にアロー構文を使用する\
  <https://docs.oracle.com/javase/jp/16/language/switch-expressions.html>からの引用：

  > ノート:`case L ->`ラベルの使用をお薦めします。`case L:`ラベルの使用時は、`break`文または`yield`文の挿入を忘れがちです。これを忘れると、コード内で思いがけないフォール・スルーが発生する場合があります。
  > `case L ->`ラベルで、複数の文または式でないコード、あるいは`throw`文を指定するには、それらをブロック内に囲みます。`case`ラベルが生成する値を`yield`文で指定します。

  良い例：

  ```java
  var date = LocalDate.now();
  var off = switch (date.getDayOfWeek()) {
      case MONDAY -> {
          if (myCalendar.isOff(date) || localCalendar.isHoliday(date)) {
              yield true;
          }
          yield localCalendar.isHoliday(date.minusDays(1));
      }
      case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY ->
          myCalendar.isOff(date) || localCalendar.isHoliday(date);
      case SUNDAY, SATURDAY -> true;
  };
  ```

  悪い例：

  ```java
  var date = LocalDate.now();
  var off = switch (date.getDayOfWeek()) {
      case MONDAY:
          if (myCalendar.isOff(date) || localCalendar.isHoliday(date)) {
              yield true;
          }
          yield localCalendar.isHoliday(date.minusDays(1));
      case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY:
          yield myCalendar.isOff(date) || localCalendar.isHoliday(date);
      case SUNDAY, SATURDAY:
          yield true;
  };
  ```

* アロー構文の、中カッコ、`yield`を省略できる場合は必ず省略する\
  良い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  var shortDay = switch (day) {
      case MONDAY -> "M";
      case WEDNESDAY -> "W";
      case FRIDAY -> "F";
      case TUESDAY, THURSDAY -> "T";
      case SUNDAY, SATURDAY -> "S";
  };
  ```

  悪い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  var shortDay = switch (day) {
      case MONDAY -> {
          yield "M";
      }
      case WEDNESDAY -> {
          yield "W";
      }
      case FRIDAY -> {
          yield "F";
      }
      case TUESDAY, THURSDAY -> {
          yield "T";
      }
      case SUNDAY, SATURDAY -> {
          yield "S";
      }
  };
  ```

* Enum 値の switch 式で case 句が全ての Enum 値をカバーする場合は default 句はデッドコードとなるため記述しない\
  良い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  var off = switch (day) {
      case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> false;
      case SUNDAY, SATURDAY -> true;
  };

  var day = DayOfWeek.SUNDAY;
  var off = switch (day) {
      case SUNDAY, SATURDAY -> true;
      default -> false;
  };
  ```

  悪い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  var off = switch (day) {
      case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> false;
      case SUNDAY, SATURDAY -> true;
      default -> false;
  };
  ```

## switch 文

* 代わりに switch 式が使用できる箇所は switch 式を使用する
  * case 句で`return`を記述する場合は switch 文を使用して良い

* case 句はなるべく 1 行のステートメントでの記述を推奨する\
  複雑なステートメントを記述しなければならない場合は、メソッドに分割することを検討してください。

* switch 文は、コーディングミスによるフォールスルーを避けるため、なるべくアロー構文を使用することを推奨する\
  <https://docs.oracle.com/javase/jp/16/language/switch-expressions.html>からの引用：

  > ノート:`case L ->`ラベルの使用をお薦めします。`case L:`ラベルの使用時は、`break`文または`yield`文の挿入を忘れがちです。これを忘れると、コード内で思いがけないフォール・スルーが発生する場合があります。
  > `case L ->`ラベルで、複数の文または式でないコード、あるいは`throw`文を指定するには、それらをブロック内に囲みます。`case`ラベルが生成する値を`yield`文で指定します。

  良い例：

  ```java
  var date = LocalDate.now();
  switch (date.getDayOfWeek()) {
      case MONDAY -> {
          if (
              !myCalendar.isOff(date) && !localCalendar.isHoliday(date) &&
              !localCalendar.isHoliday(date.minusDays(1))
          ) {
              work();
          }
      }
      case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> {
          if (!myCalendar.isOff(date) && !localCalendar.isHoliday(date)) {
              work();
          }
      }
  }
  ```

  悪い例：

  ```java
  var date = LocalDate.now();
  switch (date.getDayOfWeek()) {
      case MONDAY:
          if (
              !myCalendar.isOff(date) && !localCalendar.isHoliday(date) &&
              !localCalendar.isHoliday(date.minusDays(1))
          ) {
              work();
          }
          break;
      case TUESDAY, WEDNESDAY, THURSDAY, FRIDAY:
          if (!myCalendar.isOff(date) && !localCalendar.isHoliday(date)) {
              work();
          }
          break;
  }
  ```

* アロー構文を使用しない（コロンを使用する）場合、複数の値をマッチさせるときの case 句はカンマを使用して列挙する\
  良い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  boolean off = false;
  switch (day) {
      case SUNDAY, SATURDAY:
        off = true;
        break;
  };
  ```

  悪い例：

  ```java
  var day = DayOfWeek.SUNDAY;
  boolean off = false;
  switch (day) {
      case SUNDAY:
      case SATURDAY:
        off = true;
        break;
  };
  ```

## コレクション

* Java2 以降のコレクションクラスを利用する\
  `Vector` クラス、`Hashtable` クラス、`Enumeration` 等は、特にこれらを利用する理由がなければ、インターフェースを統一する目的で、これらの代わりに`List`(`ArrayList` クラス)、`Map`(`HashMap` クラス)、`Iterator` を使用すること。`List` などのインターフェースを利用することで JDK1.2 で整理されたわかりやすいメソッドを利用でき、また、インターフェースの特性から呼び出し元を変更せずに実装クラスを変更することができる。

* 特定の型のオブジェクトだけを受け入れるコレクションクラスを利用する

  良い例：

  ```java
  List<Map<String, String>> list = new ArrayList<>();
  ```

* `List`のソートは`List.sort()`を利用する\
  `List`クラスの要素をソートする際は Java8 で追加された`List.sort()`を利用すること。\
  Java 7 以前で利用されていた`Collections.sort()`は利用しないこと。

* `Collection.forEach()`は利用しない。拡張 for 文の利用を検討する\
  Java8 で追加されたメソッド。\
  拡張 for 文を利用したほうが多くの場合でデバッグに有利であり、可読性においても`forEach`の優位性は少ないため、`forEach`は原則利用しない。拡張 for 文を利用する。\
  具体的には下記のメソッドを利用しないこと。

  * `Collection#forEach`
  * `Set#forEach`
  * `List#forEach`

  ※ `Map#forEach`はこの限りではない

  良い例：

  ```java
  for (String s : List.of("A", "B")) {
      //処理
  }
  ```

  悪い例：

  ```java
  List.of("A", "B").forEach(s -> {
      //処理
  });
  ```

  ただし、メソッド参照で処理できる場合は`forEach`を利用する。\
  （デバッグのデメリットがほとんどなく、他と比較して処理効率が良いため）

  良い例：

  ```java
  List.of("A", "B").forEach(this::process);
  ```

  悪い例：

  ```java
  for (String s : List.of("A", "B")) {
      this.process(s);
  }
  ```

* `Arrays.asList()`は利用せず、`List.of()`を利用する\
  Java9 で追加されたメソッド。\
  配列を`List`に置き換える場合や、単純な固定の`List`を生成する際には`List.of()`を利用する。
  * `Arrays.asList()`と`List.of()`の違い\
    `List.of()`で生成した`List`は、完全に不変（Immutable）な`List`で、\
    `Arrays.asList()`で生成した`List`は、サイズのみ不変で、`set`等による値の操作が可能な`List`です。\
    また、`set`を行った場合、`Arrays.asList()`に与えられた配列インスタンスにも影響します。

## ラムダ式・メソッド参照・コンストラクタ参照

* ラムダ式が利用できる箇所はラムダ式を利用してよい\
  [※パフォーマンスについても記載しているので参考にしてください](#ラムダ式メソッド参照コンストラクタ参照-1)

* ただし、メソッド参照・コンストラクタ参照が利用できる場合はメソッド参照・コンストラクタ参照を利用する

  良い例：

  ```java
  String::compareToIgnoreCase
  ```

  悪い例：

  ```java
  (s1, s2) -> s1.compareToIgnoreCase(s2)
  ```

  良い例：

  ```java
  BigDecimal::add
  ```

  悪い例：

  ```java
  (b1, b2) -> b1.add(b2)
  ```

* ラムダ式記述の際、型宣言は省略記法で記述する

  良い例：

  ```java
  (s1, s2) -> s1 + "=" + s2
  ```

  悪い例：

  ```java
  (String s1, String s2) -> s1 + "=" + s2
  ```

* 原則ラムダ式内の行数は 1 行とする\
  複数行で利用したい場合は、`private`メソッドを作成しメソッド参照を利用する

  良い例：

  ```java
  this::getMax

  private int getMax(int i1, int i2) {
      if (i1 > i2) {
          return i1;
      } else {
          return i2;
      }
  }
  ```

  悪い例：

  ```java
  (i1, i2) -> {
      if (i1 > i2) {
          return i1;
      } else {
          return i2;
      }
  }
  ```

* 原則ラムダ式は 1 行記述に限定するので、中カッコ、`return`は必ず省略する

  良い例：

  ```java
  (s1, s2) -> s1 + "=" + s2
  ```

  悪い例：

  ```java
  (s1, s2) -> {
      return s1 + "=" + s2;
  }
  ```

## 実質的 final（effectively final）

* 実質的 final を利用する\
  変数宣言に`final`を記載しなくてよい。

## Stream API

* 利用してよい\
  [※パフォーマンスについても記載しているので参考にしてください](#stream-api-2)

* 並列ストリームは利用しないこと\
  悪い例：

  ```java
  Stream<?> s = list.parallelStream();
  Stream<?> s = list.stream().parallel();
  ```

* StreamAPI 記述の際の改行位置は、各中間処理・末端処理前のピリオドの前で改行する

  良い例：

  ```java
  List<Character> alphabetLower = list.stream()
      .filter(Character::isAlphabetic)
      .map(Character::toLowerCase)
      .toList();
  ```

  悪い例：

  ```java
  List<Character> alphabetLower = list.stream().filter(Character::isAlphabetic)
      .map(Character::toLowerCase).toList();

  List<Character> alphabetLower = list
      .stream()
      .filter(Character::isAlphabetic)
      .map(Character::toLowerCase)
      .toList();
  ```

* インデントは統合開発環境の提供するフォーマッタに合わせる

* 中間処理の数は 3 つ（3 行）程度までを推奨する\
  中間処理の記述が多くなると可読性も悪くなり、デバッグも難しくなるため、3 行程度を目安にロジックを検討すること。

* コメントは、原則として処理中には記載しない\
  難解になってしまった場合のみ処理中の記載を認める

  良い例：

  ```java
  // クラスFooのフィールドStrの値で昇順にソートし、フィールドStrの要素を取得して処理する。
  fooList.stream()
      .sorted(Comparator.comparing(Foo::getStr))
      .map(Foo::getStr)
      .forEach(this::proc);
  ```

  悪い例：

  ```java
  fooList.stream()
      .sorted(Comparator.comparing(Foo::getStr)) //クラスFooのフィールドStrの値で昇順にソート
      .map (Foo::getStr) //フィールドStrの要素を取得
      .forEach(this::proc); //処理


  fooList.stream()
      //クラスFooのフィールドStrの値で昇順にソート
      .sorted(Comparator.comparing(Foo::getStr))
      //フィールドStrの要素を取得
      .map (Foo::getStr)
      //処理
      .forEach(this::proc);
  ```

* Stream は極力変数代入しないこと\
  Stream は中間処理、末端処理を行うと使用済みとなり、以降同じインスタンスは利用できない。\
  変数代入はほとんどの場合意味をなさず、むしろミスの元となるため極力変数代入はしないこと。

  良い例：

  ```java
  List<String> list1 = Stream.of("A", "B", "C")
          .map(String::toLowerCase)
          .toList();

  List<String> list2 = Stream.of("A", "B", "C")
          .map(s -> s + s)
          .toList();
  ```

  悪い例：

  ```java
  Stream<String> stream = Stream.of("A", "B", "C");
  Stream<String> stream1 = stream.map(String::toLowerCase);
  List<String> list1 = stream1.toList();

  Stream<String> stream2 = stream.map(s -> s + s);//コーディングミス streamは使用済のためエラーになる
  List<String> list2 = stream2.toList();
  ```

## Optional

* Optional は同メソッド内で値を取り出す場合は極力変数代入しないこと\
  Optional とその値の変数は同じものを示す名前となり、同じ意味の変数名が複数現れることで可読性が下がるため、Optional の変数代入は行わないこととする。

  良い例：

  ```java
  Employee employee = findEmployee(employeeId)
          .orElseThrow(IllegalArgumentException::new);
  ```

  悪い例：

  ```java
  Optional<Employee> employeeOpt = findEmployee(employeeId);
  Employee employee = employeeOpt.orElseThrow(IllegalArgumentException::new);
  ```

  良い例：

  ```java
  Optional<Employee> employee = findEmployee(employeeId);

  Dept dept = employee.map(Employee::getDivision)
          .map(Division::getDept)
          .orElse(null);

  Role role = employee.map(Employee::getRole)
          .orElse(null);

  //-----

  Optional<Employee> employee = findEmployee(employeeId);
  //・・・処理
  return employee;
  ```

## var (Local-Variable Type Inference)

次のリンクも参考にしてください。\
[Style Guidelines for Local Variable Type Inference in Java](https://openjdk.java.net/projects/amber/LVTIstyle.html)

* 明確な方針で、利用する・利用しないを統一すること\
  方針無く、`var`を混在させるとソースコードの見通しと保守性が悪くなります。\
  各プロジェクトで、例えば以下ののような方針で統一してください。

  1. `var`を利用しない
  2. 原則`var`を利用する
  3. 右辺で、明確に型がわかる場合は`var`を利用する

  以下で`2`、`3`について例を示します。

  * 原則`var`を利用する

    利用できる箇所は全て`var`を利用します。

    良い例：

    ```java
    var a = "";
    var b = 123;
    var c = new ArrayList<String>();
    ```

    悪い例：

    ```java
    var a = "";
    int b = 123;
    List<String> c = new ArrayList<>();
    ```

    ```java
    void methodA() {
        var a = "";
    }
    void methodB() {
        String a = "";
    }
    ```

  * 右辺で、明確に型がわかる場合は`var`を利用する

    右辺をみて型がわかる場合は、全て`var`を利用します。
    それ以外は`var`を利用してはいけません。

    良い例：

    ```java
    var s = ""; // リテラルによって型が明確に判断できます
    var list1 = new ArrayList<String>(); // newによって型が明確に判断できます
    var list2 = (List<String>) map.get("p"); // キャストによって型が明確に判断できます
    var list3 = List.of("A", "B", "C"); // ファクトリーによって型が明確に判断できます
    ```

    プロジェクトで観点を決めるべき例：

    ```java
    var b1 = s.isEmpty(); // `is`で始まるメソッドは通例としてbooleanを返します
    var b2 = Objects.equals(s1, s2); // `equals`メソッドは通例としてbooleanを返します
    var i1 = Objects.hash(s); // `hash`、`hashCode`メソッドは通例としてintを返します
    var i2 = Objects.compare(s1, s2); // `compare`、`compareTo`メソッドは通例としてintを返します
    ```

    悪い例：

    ```java
    var a = e.getData(); // `e`の型と、メソッド定義がわからなければ型が判断できません
    ```

## レコード

* 明確な方針で、利用する・利用しないを統一すること\
  方針無く、`record`とクラスと JavaBeans 形式のクラスや Lombok の @Data の使用を混在させるとソースコードの見通しと保守性が悪くなります。\
  各プロジェクトで、`record`を利用しないか、`record`の使用しても良い箇所について方針を決めた上で使用するようにしてください。
  また、`record`は JavaBeans とは互換性がないため使用している各種ライブラリの対応状況にも注意する必要があります。

  方針例： クラス内で処理する一時的なデータを表現するためだけに`record`を使用しても良い。

  ```java
  // parentId と id をキーとして、重複を排除した uniqueItems を作成します。
  record Key(int parentId, int id) {
  }
  var map = new HashMap<Key, Item>();
  for (Item item : items) {
    var key = new Key(item.getParenId(), item.getId());
    map.putIfAbsent(key, item);
  }
  var uniqueItems = map.values();
  ```

* 次の記述スタイルを標準とする\
  ただし、フォーマッタを導入している場合はフォーマッタに合わせます。

  良い例：

  ```java
  /**
   * 矩形を表すクラス
   *
   * @param x      矩形の左上隅の x 座標
   * @param y      矩形の左上隅の y 座標
   * @param width  矩形の幅
   * @param height 矩形の高さ
   */
  public record Rect(
      /* 矩形の左上隅の x 座標 */
      double x,
      /* 矩形の左上隅の y 座標 */
      double y,
      /* 矩形の幅 */
      double width,
      /* 矩形の高さ */
      double height) {
  }
  ```

  次にポイントを説明します。

  * `{`の後、`}`の前に改行する

  * レコードコンポーネント（パラメータ）のカンマの後に改行することを推奨する\
    レコードコンポーネントが少なく、レコードコンポーネント名からでも意味が理解でき、改行がなくても可読性が低下しない場合は、改行を必要としません。\
    改行を推奨する理由は以下です。
    * アノテーションを付与したときでも比較的読みやすい（アノテーション引数との混在による可読性の低下の回避）
    * レコードコンポーネントが多い場合も比較的読みやすい

  * レコードコンポーネントが多い場合、レコードコンポーネントへ直接コメントをつけることを検討する\
    レコードコンポーネントの JavaDoc としては`@param`形式でレコード名の上部に記述しますが、このソースコードをテキストとしてみた場合、レコードコンポーネントの定義と`@param`の説明とで距離が空いてしまう場合があり、型と説明を読むのに時間がかかってしまう可能性があります。\
    また、使用する IDE によっては、アクセサから宣言へのジャンプを使用すると、レコードコンポーネント（パラメータ）の定義へジャンプするものがあります。レコードコンポーネントにコメントがあればすぐに説明を読むことができますが、JavaDoc しか記述しない場合は、ファイル上部へ移動して対応するレコードコンポーネントの説明を探さなければなりません。

    ```java
    public record Rect(
        /* 矩形の左上隅の x 座標 */
        double x,
        /* 矩形の左上隅の y 座標 */
        double y,
        /* 矩形の幅 */
        double width,
        /* 矩形の高さ */
        double height) {
    }
    ```

* レコードのアクセサを上書きしない

  悪い例：

  ```java
  public record Rect(
      double x,
      double y,
      double width,
      double height) {

      public double x() {
          return x;
      }
  }
  ```

## テキストブロック

次のリンクも参考にしてください。\
[Programmer's Guide To Text Blocks > Style Guidelines For Text Blocks](https://docs.oracle.com/en/java/javase/17/text-blocks/index.html#style-guidelines-for-text-blocks)

* 複数行の文字列を定義する際、文字列連結よりもテキストブロックを使用する

  良い例：

  ```java
  String message = """
          複数行の文字列はテキストブロックを使用しましょう。
          文字列連結と違い、プラス記号や改行コードのエスケープシーケンスのような無駄を排除でき、
          より読みやすいソースコードで書くことができます。
          """;
  ```

  悪い例：

  ```java
  String message =
          "複数行の文字列はテキストブロックを使用しましょう。\n" +
          "文字列連結と違い、プラス記号や改行コードのエスケープシーケンスのような無駄を排除でき、\n" +
          "より読みやすいソースコードで書くことができます。\n";
  ```

* 単一行の文字列を定義する際、テキストブロックは使用せず文字列リテラルを使用する\
  ただし、二重引用符(`"`)のエスケープを避ける目的ではテキストブロックを使用しても良い。

  良い例：

  ```java
  String singleLine = "単一行の文字列です。";

  String message = """
          テキストブロックでは単一の二重引用符「"」にエスケープを使用する必要がありません。""";
  ```

  悪い例：

  ```java
  String singleLine = """
          単一行の文字列です。""";
  ```

* テキストブロック内では基本的に改行コードのエスケープシーケンス(`\n`)を使用しないが、読みやすさ向上の目的で改行コードのエスケープシーケンス(`\n`)を使用しても良い

  良い例：

  ```java
  String multiLine = """
          複数行の、
          文字列です。
          """;

  String csv = """
          名前,説明,MIMEタイプ
          CSV,"Comma-Separated Valuesの略\nCharacter-Separated Valuesの意味で使用されることもある","text/csv"
          TSV,"Tab-Separated Valuesの略","text/tab-separated-values"
          """;
  ```

  悪い例：

  ```java
  String multiLine = """
          複数行の、\n文字列です。
          """;
  ```

* テキストブロックで定義した文字列を処理する場合は、テキストブロックをローカル変数やフィールドへ代入してから使用することを推奨する

  良い例：

  ```java
  String selectX = """
          SELECT
              ID,
              NAME
          FROM
              TABLE_X
          """;
  String selectY = """
          SELECT
              ID,
              NAME
          FROM
              TABLE_Y
          """;
  processValues(fetch(selectX, Entity1.class), fetch(selectY, Entity2.class));
  ```

  悪い例：

  ```java
  processValues(fetch("""
          SELECT
              ID,
              NAME
          FROM
              TABLE_X
          """, Entity1.class), fetch("""
          SELECT
              ID,
              NAME
          FROM
              TABLE_Y
          """, Entity2.class));
  ```

  複雑な処理に直接テキストブロックを使用すると可読性を下げる可能性があります。

* 3 つ以上続く二重引用符(`"`)をエスケープする際は、最初の二重引用符にエスケープシーケンスを使用する

  良い例：

  ```java
  String javaCode = """
          String message = \"""
                  テキストブロックです。
                  \""";
          System.out.println(message);
          """;
  ```

  悪い例：

  ```java
  String javaCode = """
          String message = \"\"\"
                  テキストブロックです。
                  \"\"\";
          System.out.println(message);
          """;

  String javaCode = """
          String message = ""\"
                  テキストブロックです。
                  ""\";
          System.out.println(message);
          """;
  ```

* テキストブロックの開始引用符(`"""`)は前の行の右端に記述する

  良い例：

  ```java
  String message = """
          テキストブロックです。
          """;
  ```

  悪い例：

  ```java
  String message =
          """
          テキストブロックです。
          """;
  ```

* テキストブロックのインデントは開始引用符(`"""`)に合わせる必要はない

  良い例：

  ```java
  String message = """
          テキストブロックです。
          """;
  ```

  悪い例：

  ```java
  String message = """
                   テキストブロックです。
                   """;
  ```

  一見すると、読みやすく見えるかもしれませんが、変数名の変更によって簡単に崩れてしまい、修正するために多くの行の変更を強制することになるため、メンテナンス性が低下します。

* テキストブロックで定義する文字列のインデントは基本的に周辺の Java コードに合わせてインデントする\
  ただし、横に長い文字列などの可読性向上の目的で左端に揃えるのは良い。

  良い例：

  ```java
  public class Foo {
      public void process() {
          String message = """
                  テキストブロックです。
                  """;
      }
  }
  ```

  悪い例：

  ```java
  public class Foo {
      public void process() {
          String message = """
      テキストブロックです。
      """;
      }
  }
  ```

  良い例：

  ```java
  public class Foo {
      public void process() {
          if (foo) {
              String message = """
  それはもう長い長いテキストブロックのためインデントするとエディタ上でテキストを見るためには横スクロールが必要になるかもしれません。
  """;
          }
      }
  }
  ```

  悪い例：

  ```java
  public class Foo {
      public void process() {
          if (foo) {
              String message = """
                      それはもう長い長いテキストブロックのためインデントするとエディタ上でテキストを見るためには横スクロールが必要になるかもしれません。
                      """;
          }
      }
  }
  ```

* テキストブロックのインデントにスペース文字とタブ文字を混在させない

* 文字列の最後に改行コードを入れずに、意図的にインデントした文字列を定義するとき終了引用符(`"""`)の前の行の右端に`\`を使用する

  良い例：

  ```java
  String text = """
              ABC
              DEF
              GHI\
          """;
  ```

  悪い例：

  ```java
  String text = """
          ABC
          DEF
          GHI""".indent(4);
  ```

## ストリーム（InputStream OutputStream）

* ストリームを扱う API を利用するときは、try-with-resources 文で後処理をする

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //inputStreamに対する処理を記載
  }
  ```

* `ObjectOutputStream` では`reset()`を利用する

## リソースの解放

* リソース解放を必要とするクラスを利用するときは、try-with-resources 文で後処理をする

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //inputStreamに対する処理を記載
  }
  ```

* リソース解放を必要とするクラスを作成する場合は`AutoCloseable`を`implements`する\
  `AutoCloseable`を`implements`することで try-with-resources 文が利用できるようになります。

## 例外

* catch 文で受け取る例外は、詳細な例外クラスで受け取る

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //・・・
  } catch (IOException e) {
      log.error("Error", e);
      throw e;
  }
  ```

  悪い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //・・・
  } catch (Exception e) {//範囲が広すぎる例外クラスの利用はNG
      log.error("Error", e);
      throw e;
  }
  ```

* `Exception` クラスのオブジェクトを生成してスローしない

* `catch` ブロックでは基本、例外処理をする。ただし処理を書いてはいけない部分もあるので、その部分については、"`// ignore`" というコメントを記述すること。

* 例外クラスは無駄に定義しない

## ガベージコレクション

* 原則`finalize()`のオーバーライド実装は禁止
* もし`finalize()`をオーバーライドした場合は`super.finalize()` を呼び出す
* アプリケーションから`finalize()`を呼び出さない

# コメント規約

## よいコメントの鉄則

* コードを明確化するコメントを書く\
  コードにコメントを書く理由は、自分自身、一緒に仕事をしている人、後に関わる開発者にとってコードをより理解しやすいものにするためである。

* コメント化する価値がないプログラムならば、実行するに値しない\
  有用な格言。コメントは必須。

* 過剰な装飾は使わない （例：見出し状のコメント）\
  1960 年代から 1970 年代の典型的な COBOL プログラマにはアスタリスク( `*` )でコメントを囲った箱を書く習慣があった。彼らの芸術的な主張を表わしているのかもしれないが、率直に言えばそれは製品に加わるちょっとした価値に比べれば大きな時間の無駄である。かわいいコードではなくきれいなコードを書くはずである。さらに、コードを表示するディスプレイや印刷するプリントに使われるフォントはプロポーショナルだったりそうでなかったりして、箱をきれいに整列させることは難しい。

* コメントはシンプルに\
  かつて見たもっとも最良のコメントは、シンプルな要点をまとめた注釈であった。なにも本を書く必要はなく、他の人がコードを理解するに十分な情報を提供するだけでよいのである。

* コードを書く前に先にコメントを記述する\
  コードをコメント化する最良の方法は、コードを書く前にコメントを書くことである。それが、コードを書く前にコードがどのように動作するかについて考えるよい機会となり、コメントの存在を保障することにもつながる。少なくともコードを書いた時にコメントすべきである。コメントによってコードが理解しやすくなることで、コードの開発中にアドバンテージを得ることができる。コードにコメントを書く時間を費やせば、それによって得られるものがある。

* コメントには、なぜそうなのかを書く。コードを読めば分かることを書かない\
  基本的に、コードの一部分を見ればそれが何かを理解することはできる。例えば、以下のコードを見て、$1000 以上の注文については 5%ディスカウントされることは理解できる。なぜそうなのか？大きな注文ではディスカウントがつきものだというビジネスルールがあるのだろうか？大きな注文に時間限定サービスがあるのか、それともずっとサービスがあるのか？これを書いたプログラマの気前がよかったのか？\
  どこかソースコード中か別な文書にコメントされていない限り、それがなぜなのかを知ることはできない。

  ```java
  if (grandTotal >= 1000.00) {
      grandTotal = grandTotal * 0.95;
  }
  ```

  なお、メソッドコメントには、適切な javadoc コメント（タグ）のほかに、以下の内容も可能な限り明記すること。

  * 副作用のある処理の場合は、その内容　（→ メソッドの引数オブジェクトがメソッド内で変更されるケースなど）
  * 既知のバグ　（→ 判明しているが修正しないことにした場合など）
  * 影響のある事前条件、事後条件　（→ メソッドが正しく動作するための前提について）
  * 並行性　（→ 　マルチスレッドでアクセスされた場合の動作について）
  * 該当メソッドの使用例やサンプルコード

* TODO コメント\
  設計者確認待ち、共通処理の作成待ちなどの理由により、実装時に TODO がある場合、下記のようにコメントを記述する。\
  （Eclipse の TODO コメント形式を採用）\
  例）

  ```java
  //TODO：ワークフローの仕様決定待ち　関連チケット#12345
  ```

## Java コメント（3 種類）の使い分け

Java では 3 種類のコメントが使える。javadoc コメントは`/**`で開始され、`*/`で終わる。C 風コメントは`/*`で開始され`*/`で終わる。単一行コメントは`//`で開始され、そのソースコード行が終わるまで続く。以下の表ではコメントの使い方とその例を示す。（コメントのスタイルに関しては、前述の「標準規約に準拠したコーディング例」を参照）

| コメント種類                         | 使用方法                                                                                                                                                                                              | 例                                                                                                                                                                                                 |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| javadoc コメント`/** comment */` | interface、class、メソッド、フィールドの直前に書く。コメントは javadoc によって処理され、外部ドキュメント(HTML)として生成される。（この形式以外のコメントはドキュメントとして出力されないことに注意） | /\*\* \* 顧客（Customer）- \* 顧客はわれわれがサービスまたは製品を売った人物 \* もしくは組織のいずれかである。 \* @author 開発太郎 \*/       |
| C 風コメント`/* comment */`      | 特定のコードを無効化したいが、後で使用するかもしれないので残しておくためにコメント化する時や、デバッグ時に一時的に無効化するときに使用する。                                                          | /\*  このコードは J.T.Kirk によって 1997.12.9 に前述のコードと置き換えたためコメント化した。2 年間不要であるならば削除せよ。 ... (ソースコード)  \*/ |
| 単一行コメント`// comment`       | メソッド内にて、ビジネスロジック、コードの概要、一時変数の定義内容などを記述する。                                                                                                                    | // 1995 年 2 月に開始された X 氏の寛大なキャンペーンで// 定められた通り 1000$を超える請求には、全て 5%割引を// 適用する。                                |

※ ロジック中に、頻繁に C 風コメントでコメントを書くとまとめてコメントアウトする場合に不便なため、基本的にロジック中では単一行コメントを利用すること。

# パフォーマンス

パフォーマンスを考慮した Java のコーディングについて以下に示す。

※ パフォーマンスは jre のバージョンやスペックによって変化します。本内容は jre1.8.0\_74 での検証結果を元にした内容です。

※ 性能計測結果についての記載がありますが、あくまでも参考値です。性能を保証するものではありません。

## Stream API

Java8 で追加された Stream API での記述は、可読性も高く、簡潔に書けますが、パフォーマンス・性能面で注意が必要な場合があります。

List の処理を行う際、拡張 for 文で処理する場合は Iterator インスタンスが 1 つだけ生成されますが、Stream API で処理する場合、最初の Stream インスタンスに加え、各中間処理ごとにも Stream インスタンスが生成され、その分の性能劣化が懸念されます。\
以下に処理例と計測結果を記載します。

* 拡張 for 文

  ```java
  List<String> list = //数値文字列のList
  List<String> resultList = new ArrayList<>();
  for (String string : list) {
      if (string.endsWith("0")) {
          resultList.add(string);
      }
  }
  return resultList;
  ```

* Stream API

  ```java
  List<String> list = //数値文字列のList
  List<String> resultList = list.stream()
      .filter(s -> s.endsWith("0"))
      .toList();
  return resultList;
  ```

* 計測結果

  | 処理する List の件数 | 拡張 for 文 (ms) | StreamAPI (ms) |
  | -------------------: | ---------------: | -------------: |
  |             100 万件 |                7 |              9 |
  |           1,000 万件 |               88 |            114 |
  |               1 億件 |              949 |          1,026 |
  |               2 億件 |            1,822 |          2,081 |

小中規模の処理量であれば考慮するほどの性能差はありませんが、大量の処理が見込まれる場合は考慮が必要です。\
また、Stream API は並列処理（スレッド処理）の機能をサポートしていますので、利用できる場合は並列処理も含めての検証が必要です。

## ラムダ式・メソッド参照・コンストラクタ参照

Java8 で追加されたラムダ式・メソッド参照・コンストラクタ参照は、匿名クラスを利用するよりも効率的です。\
積極的な利用を推奨します。

以下に Comparator を生成した場合の計測結果を記載します。

* 匿名クラス

  ```java
  Comparator<String> c = new Comparator<String>() {
      @Override
      public int compare(String o1, String o2) {
          return o1.compareToIgnoreCase(o2);
      }
  };
  ```

* ラムダ式

  ```java
  Comparator<String> c = (o1, o2) -> o1.compareToIgnoreCase(o2);
  ```

* メソッド参照

  ```java
  Comparator<String> c = String::compareToIgnoreCase;
  ```

* 計測結果

  | 処理件数 | 匿名クラス (ms) | ラムダ式 (ms) | メソッド参照 (ms) |
  | -------: | --------------: | ------------: | ----------------: |
  |  10 億回 |             380 |   0(計測不能) |       0(計測不能) |
  | 100 億回 |           6,374 |   0(計測不能) |       0(計測不能) |
  |   1 京回 |     (30 秒以上) |            14 |                10 |

ラムダ式は外部の変数を利用する場合、匿名クラスとほぼ同じ動作をします。

* 匿名クラス

  ```java
  new Comparator<String>() {
          @Override
          public int compare(String o1, String o2) {
              return arg.equals("DESC") ? o2.compareToIgnoreCase(o1)
                                              : o1.compareToIgnoreCase(o2);
          }
      }
  ```

* ラムダ式

  ```java
  Comparator<String> c = (o1, o2) -> arg.equals("DESC") ? o2.compareToIgnoreCase(o1)
                                      : o1.compareToIgnoreCase(o2);
  ```

* 計測結果

  |                   処理件数 | 匿名クラス (ms) | ラムダ式 (ms) |
  | -------------------------: | --------------: | ------------: |
  |  10 億回（パラメータあり） |             571 |           572 |
  | 100 億回（パラメータあり） |           9,900 |         9,864 |

## 文字列連結

### 文字列連結（繰り返し）

文字列連結を繰り返し処理中で行う際、`+`演算子で処理することはアンチパターンとして知られています。\
繰り返し処理中の文字列連結は、 `StringBuilder`、 `StringJoiner`、 `StringBuffer` を利用します。\
また、コレクション要素の結合であれば`String#join`が利用できます。

以下に処理例と計測結果を記載します。

* `+`演算子

  ```java
  String s = "";
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          s += ",";
      }
      s += string;
  }
  return s;
  ```

* StringBuilder

  ```java
  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          sb.append(",");
      }
      sb.append(string);
  }
  return sb.toString();
  ```

* StringBuffer

  ```java
  StringBuffer sb = new StringBuffer();
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          sb.append(",");
      }
      sb.append(string);
  }
  return sb.toString();
  ```

* String#join

  ```java
  return String.join(",", list);
  ```

* 計測結果

  | 処理する List の件数 | `+`演算子 (ms) | StringBuilder (ms) | StringBuffer (ms) | String#join (ms) |
  | -------------------: | -------------: | -----------------: | ----------------: | ---------------: |
  |             1,000 件 |              5 |        0(計測不能) |       0(計測不能) |      0(計測不能) |
  |               1 万件 |          1,016 |                  1 |                 1 |                1 |
  |              10 万件 |    (30 秒以上) |                  2 |                 5 |                5 |
  |             100 万件 |    (30 秒以上) |                 29 |                42 |               51 |

### 文字列連結（定数）

基本的に処理中の文字列連結では`+`演算子は使わないで処理するほうがパフォーマンスが高くなりますが、定数の場合は`+`演算子で定義するほうがパフォーマンスが高いです。

たとえば以下のように、処理したい場合、

```java
private static final String CONST_A = "A";
private static final String CONST_B = "B";
private static final String CONST_AB = CONST_A + CONST_B;
```

StringBuilder で処理しようとすると以下のようになります。

```java
private static final String CONST_AB = new StringBuilder(CONST_A).append(CONST_B).toString();
```

しかし、これらをバイトコード上で確認するとそれぞれ以下のようになります。

* `+`演算子

  ```java
  private static final java.lang.String CONST_AB = "AB";
  ```

* StringBuilder

  ```java
  private static final java.lang.String CONST_AB;

  static {};
     0  new java.lang.StringBuilder [20]
     3  dup
     4  ldc <String "A"> [8]
     6  invokespecial java.lang.StringBuilder(java.lang.String) [22]
     9  ldc <String "B"> [11]
    11  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [26]
    14  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [30]
    17  putstatic jp.co.packagename.ClassName.CONST_AB : java.lang.String [34]
    20  return
  ```

`+`演算子を利用した場合コンパイル時に最適化され、文字列`"A"`と`"B"`をあらかじめ結合して class が作成されます。\
`StringBuilder`を利用した場合は最適化はされず、記述した通りの処理が行われます。

計測した場合、下記のようになります。

* 計測結果

  |   処理回数 | StringBuilder (ms) | `+`演算子 (ms) |
  | ---------: | -----------------: | -------------: |
  | 5,000 万回 |                559 |    0(計測不能) |
  |     1 億回 |              1,059 |    0(計測不能) |

通常、定数処理を大量に処理することは考えられないので性能問題になることはありませんが、`+`演算子を利用したほうがパフォーマンスが高いこともあるということを理解してください。

## List の種類

`List`には`ArrayList`のような`RandomAccess`を implements した、ランダムアクセスをサポートしているクラスと、\
`LinkedList`のようなランダムアクセスをサポートしていない（シーケンシャルアクセス）クラスが存在します。\
`RandomAccess`ではない`List`は、`List#get`などインデックスを利用するような操作のパフォーマンスが低いので注意してください。

以下に処理例と計測結果を記載します。

* for 文(List#get(int)によるループ)

  ```java
  int size = list.size();
  for (int i = 0; i < size; i++) {
      String s = list.get(i);
      //処理
  }
  ```

* 拡張 for 文

  ```java
  for (String s : list) {
      //処理
  }
  ```

* forEach

  ```java
  list.forEach(this::処理);
  ```

* 計測結果

  | 処理する List の件数 | `ArrayList`for 文(List#get(int)によるループ) (ms) | `LinkedList`for 文(List#get(int)によるループ) (ms) | `ArrayList`拡張 for 文 (ms) | `LinkedList`拡張 for 文 (ms) | `ArrayList`forEach (ms) | `LinkedList`forEach (ms) |
  | -------------------- | ----------------------------------------------------: | -----------------------------------------------------: | ------------------------------: | -------------------------------: | --------------------------: | ---------------------------: |
  | 1 万件               |                                           0(計測不能) |                                                     73 |                     0(計測不能) |                      0(計測不能) |                 0(計測不能) |                  0(計測不能) |
  | 10 万件              |                                           0(計測不能) |                                                  7,576 |                     0(計測不能) |                      0(計測不能) |                           1 |                            2 |
  | 20 万件              |                                           0(計測不能) |                                                 17,740 |                     0(計測不能) |                      0(計測不能) |                 0(計測不能) |                  0(計測不能) |
  | 50 万件              |                                           0(計測不能) |                                            (30 秒以上) |                     0(計測不能) |                                2 |                 0(計測不能) |                            2 |
  | 100 万件             |                                                     1 |                                            (30 秒以上) |                     0(計測不能) |                                4 |                 0(計測不能) |                            4 |
  | 1,000 万件           |                                                    16 |                                            (30 秒以上) |                               8 |                               45 |                           6 |                           44 |

ランダムアクセスをサポートしている`List`がシーケンシャルアクセス（iterator を利用した処理など）で遅いということはないので、\
ループの処理は拡張 for 文等、Iterator によるループで記述するのが無難です。\
`List#get`での処理をすべて禁止することはできませんが、高いパフォーマンスが求められる場合は`List`の種類にも注目してみてください。

## BigDecimal の ZERO との比較

BigDecimal の正・負・ZERO の判定は`BigDecimal#signum`を利用します。\
`compareTo`を利用して`BigDecimal.ZERO`と比較しても同じことができますが、`signum`を利用したほうが効率的です。

以下に処理例と計測結果を記載します。

* compareTo 利用

  ```java
  BigDecimal value = new BigDecimal("0.0");
  if (value.compareTo(BigDecimal.ZERO) == 0) {
  ```

* signum 利用

  ```java
  BigDecimal value = new BigDecimal("0.0");
  if (value.signum() == 0) {
  ```

* 計測結果

  （単位：マイクロ秒）

  | 処理回数 | compareTo 利用 (マイクロ秒) |   signum 利用 (マイクロ秒) |
  | -------: | --------------------------: | -------------------------: |
  |   1 京回 |  527max:26,367min:0 | 424max:21,213min:0 |

性能差が少ないので、必ずしも signum を利用する必要はありませんが、大量に処理する場合など、高いパフォーマンスが求められる場合は意識してください。

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)

---

---
url: /coding-standards/documents/forJava/Javaコーディング規約_for_8.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。\
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。\
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# はじめに

一般に利用・参照されている Java コーディング規約やガイドラインを以下に示す。本規約の作成においても、下記規約類を参照・抜粋している。

| 規約                                                   | 著作者               | URL                                                                                                                                 |
| ------------------------------------------------------ | -------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| Code Conventions for the Java Programming Language     | Sun Microsystems     | <http://www.oracle.com/technetwork/java/codeconvtoc-136057.html>                                                                    |
| Writing Robust Java Code                               | Scott W. Ambler      | <http://www.ambysoft.com/downloads/javaCodingStandards.pdf>                                                                         |
| オブジェクト倶楽部版 Java コーディング標準             | オブジェクト倶楽部   | <http://objectclub.jp/community/codingstandard/CodingStd.pdf>                                                                       |
| 電通国際情報際サービス版 Java コーディング規約 2004    | 電通国際情報サービス | <http://objectclub.jp/community/codingstandard/JavaCodingStandard2004.pdf>                                                          |
| JJGuideline （Java - J2EE Conventions and Guidelines） | Stephan.J & JCS Team | <http://www.fedict.belgium.be/sites/default/files/downloads/Java_J2EE_conventions_and_guidelines_EN.pdf>※現在は削除されています |
| Google Java Style (非公式和訳)                         | Google               | <https://kazurof.github.io/GoogleJavaStyle-ja/>                                                                                     |
| Acroquest Technology Java コーディング規約             | Acroquest Technology | <https://www.acroquest.co.jp/webworkshop/javacordingrule/Acroquest_JavaCodingStandard_6_7.pdf>※現在は削除されています           |

※ Sun Microsystems の規約は Java 草創期から一応の標準という位置づけだったが、オブジェクト指向、及び、その開発環境の普及・発展によって、設計やコーディングにおいて、直接的に有用な知識や豊富な指針を含むような優れた規約や、ツールなどによる機械的な準拠チェックと連携する規約が普及してきている。

# 規約の重要性

標準としての規約を定義し、遵守することの重要性を以下に示す。

* ソフトウェアメンテナンスにおける、可読性・保守性・拡張性の向上
* 問題を起こしやすい実装を未然に回避することによる、品質・生産性の向上
* 標準規約を通して得られる一般的な実装知識やノウハウ（＝学習効果）

## コーディングの心得

長いプログラムを記述すること（ステップ数）によって生産性が評価されたのは、過去の時代の出来事である。現在は、クラスやメソッドの役割が明確で、ロジックが読みやすく、保守性に優れたプログラムを記述することが評価される。コーディング規約は、コードの書き方に関する一種のパターンと考えることもでき、コードの保守性を向上させる具体的な方法を示している。したがって、規約の一つ一つの意図を理解し、守ることが重要になる。しかし、保守性に優れたコードを作成するためには、コーディング規約を守ることに加えて、良いコードを記述するための基本的な心構えをしっかり心に留めておく必要がある。以下では、その心得について述べる。

【コーディングの心得 5 か条】

1. 見やすさを重視せよ
2. ネーミングはわかりやすく
3. サンプルを鵜呑みにしない
4. 同じコードを二度書かない
5. 役割は一つに

### 見やすさを重視せよ

「良いコード」の基本は、「他の人が読んでもわかりやすいと感じられるコード」。コードの見やすさは、フォーマットはもちろん、ロジックの簡潔さや API の常識的な使い方などから生まれる。コーディングにあたっては、常に他の人の視点を意識しながら、見やすさに気を配って記述する必要がある。例えば、自分で記述したコードであっても、しばらくたってから読み返してみると理解に時間がかかった経験は誰にもあるはず。「3 日前に書いたコードは他人のコードと同じ」ということもよく言われる。見やすさを重視することは、他の人のためだけでなく自分のためにもなる。コードを読んでもすぐに理解できないような実装は、再考（リファクタリング）の必要がある。

### ネーミングはわかりやすく

コーディングでは、様々な変数やメソッドなどにネーミング（名前付け）する必要がある。ネーミングとは、本来、その対象の本質を表すような名前を考える作業である。大変難易度の高い作業だが、一方で適当に行ってもコードの動作は変わらないため、人によっては手を抜きがちとなる。しかし、ネーミングの良し悪しは、コードの可読性に非常に大きな影響を及ぼす。例えば、「C0001」というクラス名があるとする。これでは、何を表すクラスなのかすぐにはわからないだろう。また、「int p = 5000;」という記述があるとする。プログラマに聞くと、変数名 p は価格(Price)の略だと言うのだが、それならば略さずに、「int price = 5000;」としたほうが分かりやすいはずである。「ネーミングはわかりやすく」の背景には、読んで内容が理解できるという意味で、文章のようなプログラミングを行う、という考え方に基づく。

### サンプルを鵜呑みにしない

サンプルコードを活用すること自体は、著作権等を侵害しなければ問題ない。問題なのは、その内容や背景を理解しないまま、サンプルコードだけを鵜呑みにして、「おまじない」として表面的に適用してしまうことである。コードを「おまじない」ととらえていては、サンプルコードの間違いを気づかないまま適用してしまうこともある。例えば、ストリームのクローズ処理を行っていないサンプルコードであっても、それに気づかずに自分のコードに適用してしまい、後で思わぬ障害を引き起こすという可能性がある。サンプルコードは、そこで説明する内容に絞ったコードが多いため、このような例はよく見られる。また、サンプルコードをそのまま適用した結果、自分が記述すべきコードには必要のないコードが含まれてしまう場合もある。その場合、コードの可読性を下げる原因となる。自分のコードは、自分で深く理解して記述すべきである。

### 同じコードは二度書かない

コードをコピー・ペーストしていませんか？コピー・ペーストしてしまうと、何らかの修正をする際に、全ての個所に同じ修正をする羽目になる。同じコードが現れるようならまとめて一つにし、外に出してコールするような書き方にすべきである。同じコードをまとめる作業は、どちらかといえば、コーディング時よりリファクタリング（ソフトウェアの外部的振る舞いを変更せずに内部構造を改善する作業）で行われることが多い。しかし、コーディング時からできるだけ気をつけておきたいことでもある。

### 役割は一つに

メソッドの役割が明確で、かつ 1 つであれば単体テストが行いやすくなる。つまり、コードの「試験性」が高まる。また、役割が一つであれば、後でコードを変更する際に修正箇所がわかりやすいため、障害修正に要する時間が短くなる。つまり、コードの「保守性」があがることになる。例えば、「チェックをして実行する」機能を実現するために、checkAndDo()メソッドが存在したとする。この場合、このメソッドは check()メソッドと do()メソッドに分割すべきである。なぜなら、checkAndDo()メソッドの check()ロジックに誤りがあった場合、do()メソッドに書かれる内容まで把握する必要が生じるためである。分割してあれば、check()メソッドだけの変更で済む。このことはクラスの設計にもあてはまる。

# ネーミング規約

## 全般

* 大文字・小文字の違いで名前を区別しない。

  良い例：

  ```java
  private int carNumber;
  private int trainNumber;
  ```

  悪い例：

  ```java
  private int num;
  private int Num;
  ```

## パッケージ

* パッケージ名はすべて小文字にする
* パッケージ名は意味のある名前にする
* サブパッケージ名の重複は可能

## クラス

* クラス名は単語の先頭を大文字にする\
  良い例：

  ```java
  public class Entry {
  ```

  悪い例：

  ```java
  public class entry {
  ```

* インターフェース名、Enum 名はクラス名に準ずる

## メソッド

* コンストラクタと同じ名前のメソッドはつくらない

* メソッド名は区切りのみ大文字にする\
  良い例：

  ```java
  public String getName() {
      //・・・
  }
  ```

  悪い例：

  ```java
  public String getname() {
      //・・・
  }
  public String GETNAME() {
      //・・・
  }
  ```

* 変換メソッド名は「"`to`"+オブジェクト名」にする\
  良い例：

  ```java
  public String toString() {
  ```

  悪い例：

  ```java
  public String string() {
  ```

* ゲッターメソッド名は「"`get`"+属性名」にする\
  型が`boolean`の場合は「"`is`"+属性名」にする

* セッターメソッド名は「"`set`"+属性名」にする

* `boolean`変数を返すメソッド名は`true`/`false`の状態がわかるようにする

  良い例：

  ```java
  public boolean isAsleep() {
  }
  public boolean exists() {
  }
  public boolean hasExpired() {
  }
  ```

## 引数

* メソッドのパラメータ名とインスタンス変数名を一緒にしない\
  ただし、アクセサメソッドやコンストラクタなど、統合開発環境の機能により自動生成するものに関しては可とする。\
  アンダースコア　`_`　をつけての区別は原則禁止とする。

  良い例：

  ```java
  public double calc(double rate) {
      return this.value * rate;
  }
  ```

  悪い例：

  ```java
  public double calc(double value) {
      return this.value * value;
  }

  public double calc(double _value) {
      return this.value * _value;
  }
  ```

## 変数全般

* `boolean`変数は`true`/`false` の状態がわかるようにする

  良い例：

  ```java
  private boolean isOpen;
  ```

  悪い例：

  ```java
  private boolean flag;
  ```

* 定数は全て`static final`とし、すべて大文字、区切りは"`_`"

  良い例：

  ```java
  private static final String SYSTEM_NAME = "販売管理システム";
  ```

* 変数名は小文字とし、単語の区切りのみ大文字にする

  良い例：

  ```java
  private String thisIsString;
  ```

  変数名に固有名詞が含まれる場合、先頭をのぞき、単語の区切り以外に大文字を使用してもよい

  良い例：

  ```java
  private String thisIsIPAddress;
  ```

## ローカル変数

* スコープが狭い変数名は省略した名前でもよい\
  良い例：

  ```java
  if (・・・) {
      String s = "・・・・";
     //変数sを利用した処理 数行
  }
  ```

  悪い例：

  ```java
  String s = "・・・・";
  if (・・・) {
     //変数sを利用した処理
  }
  ・・・
  if (・・・) {
     //変数sを利用した処理
  }
  ```

  変数`s`の利用範囲が広いので役割が明確になる変数名に変更する。

* for 文のループカウンタは、ネストごとに"`i`","`j`","`k`"・・・を使う

## Enum

* Enum 名はクラス名と同じく、単語の先頭を大文字にする
* 列挙定数は定数と同じく、すべて大文字、区切りは"`_`"

  良い例：

  ```java
  enum Season {
      WINTER,
      SPRING,
      SUMMER,
      FALL
  }
  ```

  悪い例：

  ```java
  enum Season {
      winter,
      spring,
      summer,
      fall
  }
  ```

# コーディング規約

## 全般

* 原則としてオブジェクトの参照にはインターフェースを利用する\
  オブジェクトを参照する際は、そのオブジェクトの実装クラスを用いて宣言できるが、実装クラスに適切なインターフェースが存在している場合は、必ずインターフェースを用いて宣言すること。

  良い例：

  ```java
  List<Entry> list = new ArrayList<>();
  Map<String, String> map = new HashMap<>();
  ```

  悪い例：

  ```java
  ArrayList<Entry> list = new ArrayList<>();
  HashMap<String, String> map = new HashMap<>();
  ```

* 推奨されない API を使用しない\
  アノテーション`@Deprecated`で指定されたメソッドは利用しないこと。

* 使われないコードは書かない

* 宣言は適切な権限で行うこと（`public`, `protected`, `private`）

* `final` を適切に利用する\
  継承されないクラス、オーバーライドされないメソッド、値の変わらない変数（つまり定数）等、変化のないもの/変化させたくないものについては`final` で宣言する。

  良い例：

  ```java
  //継承されないクラス
  public final class CalculateUtils {
      //・・・
  }

  //値の変わらない変数（定数）
  private static final String MESSAGE = "・・・";

  //オーバーライドされないメソッド
  public final int sum(/*変化させたくない値*/final int... values) {
      int sumValue = 0;
      for (/*変化させたくない値*/final int value : values) {
          sumValue += value;
      }
      return sumValue;
  }
  ```

## フォーマット

* インデントは空白文字 4 文字分の Tab を使用する

* 長すぎる行は避ける

* `{` の後にステートメントを記述しない\
  良い例：

  ```java
  if (s == null) {
      return 0;
  }
  ```

  悪い例：

  ```java
  if (s == null) {return 0;}
  ```

* 1 行に 2 つ以上のステートメントを記述しない\
  悪い例：

  ```java
  } catch (Exception e) {
      log.error("Error", e);return null;
  }
  ```

* カンマの後には空白文字を\
  良い例：

  ```java
  process(x, y, z);
  ```

  悪い例：

  ```java
  process(x,y,z);
  ```

* 代入演算子（ `=` , `+=` , `-=` , …）の前後には空白文字を挿入する\
  良い例：

  ```java
  int a = x;
  a += 10;
  ```

  悪い例：

  ```java
  int a=x;
  a+= 10;
  ```

* for 文内のセミコロンの後には空白文字を挿入する\
  良い例：

  ```java
  for (int i = 0; i < array.length; i++) {
      //・・・
  }
  ```

  悪い例：

  ```java
  for (int i = 0;i < array.length ;i++) {
      //・・・
  }
  ```

* `++` や `--` とオペランドの間には空白文字を入れない\
  良い例：

  ```java
  i++;
  ```

  悪い例：

  ```java
  i ++;
  ```

* ビット演算子（ `|` 、 `&` 、 `^` 、 `<<` 、 `>>` ）の前後には空白文字を挿入する

* 論理演算子（ `||` 、`&&`）の前後には空白文字を挿入する

* 関係演算子（ `<` 、 `>` 、 `>=` 、 `<=`、`==`、 `!=` ）の前後には空白文字を挿入する

* 算術演算子（ `＋` 、 `－` 、 `＊` 、 `/` 、 `%` ）の前後には空白文字を挿入する

* return 文ではカッコを使わない\
  良い例：

  ```java
  int answer = (a + b + c) * d;
  return answer;
  ```

  悪い例：

  ```java
  return ((a + b + c) * d);
  ```

* if などの条件式で boolean の変数を比較しない

  良い例：

  ```java
  if (hasStock)
  ```

  悪い例：

  ```java
  if (hasStock == true)
  ```

* 不等号の向きは左向き（ `<` 、 `<=` ）にする\
  良い例：

  ```java
  if (from <= x && x <= to) {
  ```

  悪い例：

  ```java
  if (x >= from && x <= to) {
  ```

## コメント

* ファイルの先頭への Copyright の表記について\
  ソースのファイルヘッダにコピーライト標記は法的拘束力がないため、不要とする。\
  ただし、顧客からの要求があった場合を除く。

* Javadoc コメントには、少なくとも author と version(クラス)、param と return と exception(メソッド)を記述する
  * 今後もバージョンアップのリリースが予定されているソースでは、上記に加えて since（バージョン）を記述する
  * `@Override`のあるメソッドでは、上記に加えて`{@Inherit}`を記述する

* Javadoc 　クラスヘッダコメントのフォーマットは以下の通り

  良い例：

  ```java
  /**
   * Action（or Bean）クラス　メニュー名称
   *
   * @author 姓 名
   * @version バージョン YYYY/MM/DD 説明
   */
  ```

* コメントは必要なものだけを簡潔に\
  悪い例：

  ```java
  /**
   * 文字列に変換
   */
  @Override
  public String toString() {

  /**
   * コピー
   *
   * @return コピーしたインスタンス
   */
  public Entry copy() {
  ```

* 不要なコメントは記載しない
  * コードからすぐわかること・冗長なコメント
  * 名前の説明\
    コメントではなくわかりやすい名前を付ける。
  * 別システムで管理している内容\
    ソースコード管理システム、バグトラッキングシステムで管理している内容はソースコードにコメントで記載する必要はない。
    * コメントアウトされたコード\
      ソースコード管理システムで管理されている

## インポート

* `java.lang`パッケージはインポートしない

  悪い例：

  ```java
  import java.lang.String;//必要のない記述
  ```

* 原則として static インポートしない\
  JUnit の作成やフレームワークとして static インポートが推奨されるような場合は利用してもよい

* 原則としてオンデマンドのインポート宣言(type-import-on-demand declaration)（アスタリスク`*`によるインポート） は行わない

  悪い例：

  ```java
  import java.util.*;
  ```

## コンストラクタ

* public 宣言していないクラスには`public`権限のコンストラクタを作らない\
  良い例：

  ```java
  class Entry {
      //・・・
      Entry(int id) {
          //・・・
      }
  ```

  悪い例：

  ```java
  class Entry {
      //・・・
      public Entry(int id) {
          //・・・
      }
  ```

* インスタンスメンバを持たない（static メンバのみの）クラスは、`private`権限のコンストラクタを作成する

## メソッド

* オーバーライドさせたくないメソッドは`final`を利用する

* 戻り値が配列のメソッドで、戻る配列のサイズが 0 の場合、メソッドを使用するクライアントの余計な null チェックのロジックを回避するため、null ではなく長さゼロの配列を戻すようにする。
  良い例：

  ```java
  public String[] toArray(String s) {
      if (s == null || s.isEmpty()) {
          return ArrayUtils.EMPTY_STRING_ARRAY;
      }
      return new String[] { s };
  }

  public List<String> toList(String s) {
      if (s == null || s.isEmpty()) {
          return Collections.emptyList();
      }
      return Arrays.asList(s);
  }
  ```

  悪い例：

  ```java
  public String[] toArray(String s) {
      if (s == null || s.isEmpty()) {
          return null;
      }
      return new String[] { s };
  }

  public List<String> toList(String s) {
      if (s == null || s.isEmpty()) {
          return null;
      }
      return Arrays.asList(s);
  }
  ```

* メソッドは 1 つの役割にする

## クラスメソッド

* クラスメソッドを利用するときは、クラス名を使って呼び出す\
  良い例：

  ```java
  int comp = Integer.compare(x, y);
  ```

  悪い例：

  ```java
  Integer a = //
  int comp = a.compare(x, y);
  ```

## 変数全般

* 1 つのステートメントには 1 つの変数宣言\
  良い例：

  ```java
  /** 科目コード */
  private String code;
  /** 科目名 */
  private String name;
  /** 科目略名 */
  private String shortName;
  ```

  悪い例：

  ```java
  private String code, name, shortName;
  ```

* リテラルは使用しない\
  リテラルとは、コード中に、表現が定数として直接現れており、記号やリストで表現することができないものを指す（数値、文字列両方含む　通称マジックナンバー）。コードの可読性・保守性の低下を防ぐために、リテラル定数（`static final` フィールド）を使用すること。\
  例外：`-1`,`0`,`1` 等をカウント値としてループ処理等で使用するような場合

  良い例：

  ```java
  private static final double ONE_MILE_METRE = 1609.344;

  public double mileToMetre(double mi) {
      return mi * ONE_MILE_METRE;
  }
  ```

  悪い例：

  ```java
  public double mileToMetre(double mi) {
      return mi * 1609.344;
  }
  ```

  * リテラル定数の名前はその値の意味を正しく表現したものにする

    悪い例：

    ```java
    private static final int ZERO = 0;
    ```

* 配列宣言は「`型名[]`」にする

  良い例：

  ```java
  private int[] sampleArray = new int[10];
  ```

  悪い例：

  ```java
  private int sampleArray[] = new int[10];
  ```

* できるだけローカル変数を利用する\
  ローカル変数で事足りるものをインスタンス変数として利用するなど、必要のないインスタンス変数を定義すると、パフォーマンスや可読性の低下やの大きな要因となる上、マルチスレッドを意識した際に不整合がおきる可能性があるので、インスタンス変数は必要性を充分に考慮してから使用すること。

* 定数は`final`で宣言する

* ローカル変数とインスタンス変数を使いわける

## 定数

* `public` で宣言するクラス変数とインスタンス変数は、定数のみとし、 `static final` で定義する\
  `final` ではない `static` な定数は作成しない。

  良い例：

  ```java
  public static final String PROTOCOL_HTTP = "http";
  ```

* 定数（ `static` フィールド）に、 `static` ではないメソッドから書き込まない

* 定数は、プリミティブ型もしくは、不変（Immutable）オブジェクトで参照する
  * 不変`List`の生成には`Collections`クラスの`unmodifiableList()`メソッドを利用する

    良い例：

    ```java
    public static final List<Integer> VALUES = Collections.unmodifiableList(Arrays.asList(1, 2, 3, 4, 5));
    ```

    悪い例：

    ```java
    public static final List<Integer> VALUES = Arrays.asList(1, 2, 3, 4, 5);
    ```

  * 不変`Set`の生成には`Collections`クラスの`unmodifiableSet()`メソッドを利用する

  * 不変`Map`の生成には`Collections`クラスの`unmodifiableMap()`メソッドを利用する

    良い例：

    ```java
    public static final Map<Integer, String> VALUES_MAP = Collections.unmodifiableMap(new HashMap<>() {
        {
            put(1, "A");
            put(2, "B");
            put(3, "C");
        }
    });
    ```

    悪い例：

    ```java
    public static final Map<Integer, String> VALUES_MAP = new HashMap<>() {
        {
            put(1, "A");
            put(2, "B");
            put(3, "C");
        }
    };
    ```

  * 不変な配列インスタンスは長さ 0 の配列以外は生成不可能なため、外部から参照される（`public`）定数では利用せず、`List`等への置き換えをすること

    良い例：

    ```java
    public static final List<Integer> VALUES = Collections.unmodifiableList(Arrays.asList(1, 2, 3, 4, 5));
    ```

    悪い例：

    ```java
    public static final int[] VALUES = { 1, 2, 3, 4, 5 };
    ```

## インスタンス変数

* インスタンス変数は`private`にする

  良い例：

  ```java
  public class Employee {
      private long id;

      //・・・
      //getter/setter
  }
  ```

  悪い例：

  ```java
  public class Employee {
      public long id;

      //・・・
      //getter/setter
  }
  ```

## クラス変数

* `public static final` 宣言した配列を利用しない\
  ※「定数」を参照

* クラス変数にはクラス名を使用してアクセスすること

  良い例：

  ```java
  BigDecimal b = BigDecimal.ZERO;
  ```

  悪い例：

  ```java
  BigDecimal a = //
  BigDecimal b = a.ZERO;
  ```

## ローカル変数

* ローカル変数は利用する直前で宣言する\
  行間の程度にもよるが、ある程度まとめて宣言するのは OK とする。

  良い例：

  ```java
  for (int i = 0; i < lines.length; i++) {
      String line = lines[i];
      //lineの処理
  }
  ```

  悪い例：

  ```java
  String line;
  for (int i = 0; i < lines.length; i++) {
      line = lines[i];
      //lineの処理
  }
  ```

* ローカル変数は安易に再利用しない\
  一度宣言したローカル変数を、複数の目的で安易に使いまわさないこと。ローカル変数は、役割ごとに新しいものを宣言して初期化することにより、コードの可読性・保守性の向上、及びコンパイラの最適化の促進をはかる。

## 引数

* メソッド引数への代入は行わない\
  原則として`final`で宣言する。

  良い例：

  ```java
  public void add(final int value) {
      //・・・
  }
  ```

## 継承

* スーパークラスのインスタンス変数をサブクラスでオーバーライドしない\
  スーパークラスと同じ名前のフィールドをサブクラスで宣言しないこと。 同じ名前のフィールドを宣言すると、スーパークラスのフィールドはサブクラスで宣言されたフィールドによって隠ぺいされてしまうので、他の人の混乱を招くことを防ぐため重複する名前は付けないこと。

  悪い例：

  ```java
  public class Abs {
      protected String name;
  }

  public class Sub extends Abs {
      protected String name;//Abs#nameは隠ぺいされる
  }
  ```

* スーパークラスのメソッドをオーバーライドするときは@Override アノテーションを指定する。

  良い例：

  ```java
  public class Abs {
      protected void process() {

      }
  }

  public class Sub extends Abs {
      @Override
      protected void process() {

      }
  }
  ```

  悪い例：

  ```java
  public class Abs {
      protected void process() {

      }
  }

  public class Sub extends Abs {
      //@Overrideアノテーションの指定がない
      protected void process() {

      }
  }
  ```

* スーパークラスで private 宣言されているメソッドと同じ名前のメソッドをサブクラスで定義しない\
  スーパークラスにある private メソッドと同じ名前のメソッドをサブクラスで定義しないこと。private メソッドはオーバーライドされず全く別のメソッドとして扱われ、他の人の混乱を招き、バグにつながる恐れがある。

## インナークラス

* 原則としてインナークラスは利用しない\
  一つの java ファイルに複数のクラスを記載するのは NG とする。また無名クラスを利用するのも原則として NG とする。\
  Enum の定数固有メソッド実装(constant-specific method implementation)、Java8 のラムダ式は内部的にインナークラスとされるがこれらは許可する。

## メンバー順序

* 以下の順で記述する
  1. static フィールド
  2. static イニシャライザー
  3. static メソッド
  4. フィールド
  5. イニシャライザー
  6. コンストラクター
  7. メソッド

* 同一カテゴリー内では以下の可視性の順で記述する
  1. public
  2. protected
  3. パッケージ private
  4. private

## インスタンス

* オブジェクト同士は`equals()`メソッドで比較する

  良い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1.equals(s2)) {
      //・・・
  }
  ```

  悪い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1 == s2) {
      //・・・
  }
  ```

  ただし Enum の場合は`==`演算子を利用して比較する

  `equals()`メソッドで比較する際、左辺のオブジェクトが null にならないように制御すること。

* Class 名を利用した比較をおこなわない

  良い例：

  ```java
  if (o instanceof Foo) {
      // ...
  }
  ```

  悪い例：

  ```java
  if ("my.Foo".equals(o.getClass().getName())) {
      // ...
  }
  ```

## 制御構造

* 制御文（ `if` , `else` , `while` , `for` , `do while` ）の `{ }` は省略しない

  良い例：

  ```java
  if (s == null) {
      return;
  }
  ```

  悪い例：

  ```java
  if (s == null)
      return;
  ```

* ステートメントが無い `{}` ブロックを利用しない\
  悪い例：

  ```java
  //{}内の記述が無い
  if (s == null) {
  }
  ```

* `if` / `while` の条件式で `=` は利用しない\
  良い例：

  ```java
  boolean a =//
  if (!a) {
      //・・・
  }
  ```

  悪い例：

  ```java
  boolean a =//
  if (a = false) {//コーディングミス
      //・・・
  }


  boolean a =//
  boolean b =//
  if (a = b) {//おそらくコーディングミス
      //・・・
  }
  ```

* `for` と `while` の使い分けを意識する

* for 文を利用した繰り返し処理中でループ変数の値を変更しない\
  悪い例：

  ```java
  String[] array = { /*・・・*/ };
  for (int i = 0; i < array.length; i++) {
      //・・・
      i += 2;//NG
  }

  for (String s : array) {
      //・・・
      s = "string";//NG
  }
  ```

* for 文のカウンタは特別な事情がない限り、0 から始める

* 配列やリストなどの全要素に対するループ処理は拡張 for 文を使用する。\
  良い例：

  ```java
  for (int value : array) {
      //・・・
  }

  for (String value : list) {
      //・・・
  }
  ```

* 配列をコピーするときは`Arrays.copyOf()`メソッドを利用する

  良い例：

  ```java
  int[] newArray = Arrays.copyOf(array, array.length);
  ```

  悪い例：

  ```java
  int[] newArray = new int[array.length];
  System.arraycopy(array, 0, newArray, 0, array.length);
  ```

* 繰り返し処理中のオブジェクトの生成は最小限にする

* if 文と else 文の繰り返しや switch 文の利用はなるべく避け、オブジェクト指向の手法を利用する\
  良い例：

  ```java
  CodingKind codingKind = toCodingKind(kind);
  d = codingKind.encode(s);

  //---

  CodingKind codingKind = toCodingKind(kind);
  s = codingKind.decode(d);
  ```

  悪い例：

  ```java
  switch (kind) {
  case 1:
      d = encode1(s);
      break;
  case 2:
      d = encode2(s);
      break;
  default:
      break;
  }

  //---

  switch (kind) {
  case 1:
      s = decode1(d);
      break;
  case 2:
      s = decode2(d);
      break;
  default:
      break;
  }
  ```

* 繰り返し処理の内部で `try` ブロックを利用しない\
  特に理由がない場合は繰り返し処理の外に`try`ブロックを記載する。\
  ただし、繰り返し処理内部で例外をキャッチし処理を行いたい場合は繰り返し処理の内部で`try`ブロックを利用してもよい。

  良い例：

  ```java
  for (String s : array) {
      BigDecimal num;
      try {
          num = new BigDecimal(s);
      } catch (NumberFormatException e) {
          num = BigDecimal.ZERO;
      }
      //・・・
  }
  ```

## 文字列操作

* 文字列同士が同じ値かを比較するときは、`equals()`メソッドを利用する\
  良い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1.equals(s2)) {
      //・・・
  }
  ```

  悪い例：

  ```java
  String s1 = "text";
  String s2 = "text";
  if (s1 == s2) {
      //・・・
  }
  ```

* 文字列リテラルは`new` しない\
  良い例：

  ```java
  String s = "";
  ```

  悪い例：

  ```java
  String s = new String();
  ```

* 更新される文字列には`StringBuilder` クラスを利用する\
  良い例：

  ```java
  StringBuilder builder = new StringBuilder();
  for (String s : array) {
      builder.append(s);
  }
  System.out.println(builder.toString());
  ```

  悪い例：

  ```java
  String string = "";
  for (String s : array) {
      string += s;
  }
  System.out.println(string);
  ```

  [※パフォーマンスについても記載しているので参考にしてください](#文字列連結)

* 更新されない文字列には`String` クラスを利用する

* 文字列リテラルと定数を比較するときは、文字列リテラルの`equals()`メソッドを利用する\
  良い例：

  ```java
  private static final String PROTOCOL_HTTP = "http";

  if (PROTOCOL_HTTP.equals(url.getProtocol())) {

  }
  ```

  悪い例：

  ```java
  private static final String PROTOCOL_HTTP = "http";

  if (url.getProtocol().equals(PROTOCOL_HTTP)) {

  }
  ```

* プリミティブ型と`String` オブジェクトの変換には、変換用のメソッドを利用する\
  良い例：

  ```java
  int i = 1000;
  String s = String.valueOf(i);// "1000"
  s = NumberFormat.getNumberInstance().format(i);// 3桁区切り "1,000"

  boolean b = true;
  s = String.valueOf(b);// true/false
  s = BooleanUtils.toStringOnOff(b);// on/off
  ```

* 文字列の中に、ある文字が含まれているか調べるには、`contains()`メソッドを利用する

* システム依存記号（ `\n` 、 `\r` など）は使用しない。\
  悪い例：

  ```java
  String text = Arrays.stream(array)
      .collect(Collectors.joining("\n"));
  ```

## 数値

* 誤差の無い計算をするときは、`BigDecimal` クラスを使う\
  浮動小数点演算は科学技術計算に利用するもので、誤差が発生する。これに対して、クラス「`BigDecimal`」は、文字列で数値の計算を行うので、金額などの正確な計算に適している。`BigDecimal` ではインスタンス生成時に指定された桁数での精度が保証される。

* 数値の比較は精度に気をつける\
  良い例：

  ```java
  BigDecimal a = new BigDecimal("1");
  BigDecimal b = new BigDecimal("1.0");
  if (a.compareTo(b) == 0) {
      System.out.println("一致");
  }
  ```

  悪い例：

  ```java
  BigDecimal a = new BigDecimal("1");
  BigDecimal b = new BigDecimal("1.0");

  if (a.equals(b)) {
      System.out.println("精度が違うためこの分岐には入らない");
  }
  ```

* 低精度なプリミティブ型にキャストしない

* `BigDecimal`を`String`変換する際は`toString()`ではなく`toPlainString()`を利用すること\
  `toString()`を利用した場合、指数表記になることがあります。

## 日付

* 日付の文字列のフォーマットには、`SimpleDateFormat`または`DateTimeFormatter`を使う\
  良い例：

  ```java
  Date date = new Date();
  SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
  String s = dateFormat.format(date);
  ```

## 三項演算子

* 入れ子の三項演算子の利用は禁止\
  可読性が悪くなるので三項演算子を入れ子で行うのは禁止。

## コレクション

* Java2 以降のコレクションクラスを利用する\
  `Vector` クラス、`Hashtable` クラス、`Enumeration` 等は、特にこれらを利用する理由がなければ、インターフェースを統一する目的で、これらの代わりに`List`(`ArrayList` クラス)、`Map`(`HashMap` クラス)、`Iterator` を使用すること。`List` などのインターフェースを利用することで JDK1.2 で整理されたわかりやすいメソッドを利用でき、また、インターフェースの特性から呼び出し元を変更せずに実装クラスを変更することができる。

* 特定の型のオブジェクトだけを受け入れるコレクションクラスを利用する

  良い例：

  ```java
  List<Map<String, String>> list = new ArrayList<>();
  ```

* `List`のソートは`List.sort()`を利用する\
  `List`クラスの要素をソートする際は Java8 で追加された`List.sort()`を利用すること。\
  Java 7 以前で利用されていた`Collections.sort()`は利用しないこと。

* `Collection.forEach()`は利用しない。拡張 for 文の利用を検討する\
  Java8 で追加されたメソッド。\
  拡張 for 文を利用したほうが多くの場合でデバッグに有利であり、可読性においても`forEach`の優位性は少ないため、`forEach`は原則利用しない。拡張 for 文を利用する。\
  具体的には下記のメソッドを利用しないこと。

  * `Collection#forEach`
  * `Set#forEach`
  * `List#forEach`

  ※ `Map#forEach`はこの限りではない

  良い例：

  ```java
  for (String s : Arrays.asList("A", "B")) {
      //処理
  }
  ```

  悪い例：

  ```java
  Arrays.asList("A", "B").forEach(s -> {
      //処理
  });
  ```

  ただし、メソッド参照で処理できる場合は`forEach`を利用する。\
  （デバッグのデメリットがほとんどなく、他と比較して処理効率が良いため）

  良い例：

  ```java
  Arrays.asList("A", "B").forEach(this::process);
  ```

  悪い例：

  ```java
  for (String s : Arrays.asList("A", "B")) {
      this.process(s);
  }
  ```

## ラムダ式・メソッド参照・コンストラクタ参照

* ラムダ式が利用できる箇所はラムダ式を利用してよい\
  [※パフォーマンスについても記載しているので参考にしてください](#ラムダ式メソッド参照コンストラクタ参照-1)

* ただし、メソッド参照・コンストラクタ参照が利用できる場合はメソッド参照・コンストラクタ参照を利用する

  良い例：

  ```java
  String::compareToIgnoreCase
  ```

  悪い例：

  ```java
  (s1, s2) -> s1.compareToIgnoreCase(s2)
  ```

  良い例：

  ```java
  BigDecimal::add
  ```

  悪い例：

  ```java
  (b1, b2) -> b1.add(b2)
  ```

* ラムダ式記述の際、型宣言は省略記法で記述する

  良い例：

  ```java
  (s1, s2) -> s1 + "=" + s2
  ```

  悪い例：

  ```java
  (String s1, String s2) -> s1 + "=" + s2
  ```

* 原則ラムダ式内の行数は 1 行とする\
  複数行で利用したい場合は、`private`メソッドを作成しメソッド参照を利用する

  良い例：

  ```java
  this::getMax

  private int getMax(int i1, int i2) {
      if (i1 > i2) {
          return i1;
      } else {
          return i2;
      }
  }
  ```

  悪い例：

  ```java
  (i1, i2) -> {
      if (i1 > i2) {
          return i1;
      } else {
          return i2;
      }
  }
  ```

* 原則ラムダ式は 1 行記述に限定するので、中カッコ、`return`は必ず省略する

  良い例：

  ```java
  (s1, s2) -> s1 + "=" + s2
  ```

  悪い例：

  ```java
  (s1, s2) -> {
      return s1 + "=" + s2;
  }
  ```

## 実質的 final（effectively final）

* 実質的 final を利用する\
  変数宣言に`final`を記載しなくてよい。

## Stream API

* 利用してよい\
  [※パフォーマンスについても記載しているので参考にしてください](#stream-api-2)

* 並列ストリームは利用しないこと\
  悪い例：

  ```java
  Stream<?> s = list.parallelStream();
  Stream<?> s = list.stream().parallel();
  ```

* StreamAPI 記述の際の改行位置は、各中間処理・末端処理前のピリオドの前で改行する

  良い例：

  ```java
  List<Character> alphabetLower = list.stream()
      .filter(Character::isAlphabetic)
      .map(Character::toLowerCase)
      .collect(Collectors.toList());
  ```

  悪い例：

  ```java
  List<Character> alphabetLower = list.stream().filter(Character::isAlphabetic)
      .map(Character::toLowerCase).collect(Collectors.toList());

  List<Character> alphabetLower = list
      .stream()
      .filter(Character::isAlphabetic)
      .map(Character::toLowerCase)
      .collect(Collectors.toList());
  ```

* インデントは統合開発環境の提供するフォーマッタに合わせる

* 中間処理の数は 3 つ（3 行）程度までを推奨する\
  中間処理の記述が多くなると可読性も悪くなり、デバッグも難しくなるため、3 行程度を目安にロジックを検討すること。

* コメントは、原則として処理中には記載しない\
  難解になってしまった場合のみ処理中の記載を認める

  良い例：

  ```java
  // クラスFooのフィールドStrの値で昇順にソートし、フィールドStrの要素を取得して処理する。
  fooList.stream()
      .sorted(Comparator.comparing(Foo::getStr))
      .map(Foo::getStr)
      .forEach(this::proc);
  ```

  悪い例：

  ```java
  fooList.stream()
      .sorted(Comparator.comparing(Foo::getStr)) //クラスFooのフィールドStrの値で昇順にソート
      .map (Foo::getStr) //フィールドStrの要素を取得
      .forEach(this::proc); //処理


  fooList.stream()
      //クラスFooのフィールドStrの値で昇順にソート
      .sorted(Comparator.comparing(Foo::getStr))
      //フィールドStrの要素を取得
      .map (Foo::getStr)
      //処理
      .forEach(this::proc);
  ```

* Stream は極力変数代入しないこと\
  Stream は中間処理、末端処理を行うと使用済みとなり、以降同じインスタンスは利用できない。\
  変数代入はほとんどの場合意味をなさず、むしろミスの元となるため極力変数代入はしないこと。

  良い例：

  ```java
  List<String> list1 = Stream.of("A", "B", "C")
          .map(String::toLowerCase)
          .collect(Collectors.toList());

  List<String> list2 = Stream.of("A", "B", "C")
          .map(s -> s + s)
          .collect(Collectors.toList());
  ```

  悪い例：

  ```java
  Stream<String> stream = Stream.of("A", "B", "C");
  Stream<String> stream1 = stream.map(String::toLowerCase);
  List<String> list1 = stream1.collect(Collectors.toList());

  Stream<String> stream2 = stream.map(s -> s + s);//コーディングミス streamは使用済のためエラーになる
  List<String> list2 = stream2.collect(Collectors.toList());
  ```

## Optional

* Optional は同メソッド内で値を取り出す場合は極力変数代入しないこと\
  Optional とその値の変数は同じものを示す名前となり、同じ意味の変数名が複数現れることで可読性が下がるため、Optional の変数代入は行わないこととする。

  良い例：

  ```java
  Employee employee = findEmployee(employeeId)
          .orElseThrow(IllegalArgumentException::new);
  ```

  悪い例：

  ```java
  Optional<Employee> employeeOpt = findEmployee(employeeId);
  Employee employee = employeeOpt.orElseThrow(IllegalArgumentException::new);
  ```

  良い例：

  ```java
  Optional<Employee> employee = findEmployee(employeeId);

  Dept dept = employee.map(Employee::getDivision)
          .map(Division::getDept)
          .orElse(null);

  Role role = employee.map(Employee::getRole)
          .orElse(null);

  //-----

  Optional<Employee> employee = findEmployee(employeeId);
  //・・・処理
  return employee;
  ```

## ストリーム（InputStream OutputStream）

* ストリームを扱う API を利用するときは、try-with-resources 文で後処理をする

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //inputStreamに対する処理を記載
  }
  ```

* `ObjectOutputStream` では`reset()`を利用する

## リソースの解放

* リソース解放を必要とするクラスを利用するときは、try-with-resources 文で後処理をする

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //inputStreamに対する処理を記載
  }
  ```

* リソース解放を必要とするクラスを作成する場合は`AutoCloseable`を`implements`する\
  `AutoCloseable`を`implements`することで try-with-resources 文が利用できるようになります。

## 例外

* catch 文で受け取る例外は、詳細な例外クラスで受け取る

  良い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //・・・
  } catch (IOException e) {
      log.error("Error", e);
      throw e;
  }
  ```

  悪い例：

  ```java
  try (InputStream inputStream = Files.newInputStream(Paths.get("foo.txt")) {
      //・・・
  } catch (Exception e) {//範囲が広すぎる例外クラスの利用はNG
      log.error("Error", e);
      throw e;
  }
  ```

* `Exception` クラスのオブジェクトを生成してスローしない

* `catch` ブロックでは基本、例外処理をする。ただし処理を書いてはいけない部分もあるので、その部分については、"`// ignore`" というコメントを記述すること。

* 例外クラスは無駄に定義しない

## ガベージコレクション

* 原則`finalize()`のオーバーライド実装は禁止
* もし`finalize()`をオーバーライドした場合は`super.finalize()` を呼び出す
* アプリケーションから`finalize()`を呼び出さない

# コメント規約

## よいコメントの鉄則

* コードを明確化するコメントを書く\
  コードにコメントを書く理由は、自分自身、一緒に仕事をしている人、後に関わる開発者にとってコードをより理解しやすいものにするためである。

* コメント化する価値がないプログラムならば、実行するに値しない\
  有用な格言。コメントは必須。

* 過剰な装飾は使わない （例：見出し状のコメント）\
  1960 年代から 1970 年代の典型的な COBOL プログラマにはアスタリスク( `*` )でコメントを囲った箱を書く習慣があった。彼らの芸術的な主張を表わしているのかもしれないが、率直に言えばそれは製品に加わるちょっとした価値に比べれば大きな時間の無駄である。かわいいコードではなくきれいなコードを書くはずである。さらに、コードを表示するディスプレイや印刷するプリントに使われるフォントはプロポーショナルだったりそうでなかったりして、箱をきれいに整列させることは難しい。

* コメントはシンプルに\
  かつて見たもっとも最良のコメントは、シンプルな要点をまとめた注釈であった。なにも本を書く必要はなく、他の人がコードを理解するに十分な情報を提供するだけでよいのである。

* コードを書く前に先にコメントを記述する\
  コードをコメント化する最良の方法は、コードを書く前にコメントを書くことである。それが、コードを書く前にコードがどのように動作するかについて考えるよい機会となり、コメントの存在を保障することにもつながる。少なくともコードを書いた時にコメントすべきである。コメントによってコードが理解しやすくなることで、コードの開発中にアドバンテージを得ることができる。コードにコメントを書く時間を費やせば、それによって得られるものがある。

* コメントには、なぜそうなのかを書く。コードを読めば分かることを書かない\
  基本的に、コードの一部分を見ればそれが何かを理解することはできる。例えば、以下のコードを見て、$1000 以上の注文については 5%ディスカウントされることは理解できる。なぜそうなのか？大きな注文ではディスカウントがつきものだというビジネスルールがあるのだろうか？大きな注文に時間限定サービスがあるのか、それともずっとサービスがあるのか？これを書いたプログラマの気前がよかったのか？\
  どこかソースコード中か別な文書にコメントされていない限り、それがなぜなのかを知ることはできない。

  ```java
  if (grandTotal >= 1000.00) {
      grandTotal = grandTotal * 0.95;
  }
  ```

  なお、メソッドコメントには、適切な javadoc コメント（タグ）のほかに、以下の内容も可能な限り明記すること。

  * 副作用のある処理の場合は、その内容　（→ メソッドの引数オブジェクトがメソッド内で変更されるケースなど）
  * 既知のバグ　（→ 判明しているが修正しないことにした場合など）
  * 影響のある事前条件、事後条件　（→ メソッドが正しく動作するための前提について）
  * 並行性　（→ 　マルチスレッドでアクセスされた場合の動作について）
  * 該当メソッドの使用例やサンプルコード

* TODO コメント\
  設計者確認待ち、共通処理の作成待ちなどの理由により、実装時に TODO がある場合、下記のようにコメントを記述する。\
  （Eclipse の TODO コメント形式を採用）\
  例）

  ```java
  //TODO：ワークフローの仕様決定待ち　関連チケット#12345
  ```

## Java コメント（3 種類）の使い分け

Java では 3 種類のコメントが使える。javadoc コメントは`/**`で開始され、`*/`で終わる。C 風コメントは`/*`で開始され`*/`で終わる。単一行コメントは`//`で開始され、そのソースコード行が終わるまで続く。以下の表ではコメントの使い方とその例を示す。（コメントのスタイルに関しては、前述の「標準規約に準拠したコーディング例」を参照）

| コメント種類                         | 使用方法                                                                                                                                                                                              | 例                                                                                                                                                                                                 |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| javadoc コメント`/** comment */` | interface、class、メソッド、フィールドの直前に書く。コメントは javadoc によって処理され、外部ドキュメント(HTML)として生成される。（この形式以外のコメントはドキュメントとして出力されないことに注意） | /\*\* \* 顧客（Customer）- \* 顧客はわれわれがサービスまたは製品を売った人物 \* もしくは組織のいずれかである。 \* @author 開発太郎 \*/       |
| C 風コメント`/* comment */`      | 特定のコードを無効化したいが、後で使用するかもしれないので残しておくためにコメント化する時や、デバッグ時に一時的に無効化するときに使用する。                                                          | /\*  このコードは J.T.Kirk によって 1997.12.9 に前述のコードと置き換えたためコメント化した。2 年間不要であるならば削除せよ。 ... (ソースコード)  \*/ |
| 単一行コメント`// comment`       | メソッド内にて、ビジネスロジック、コードの概要、一時変数の定義内容などを記述する。                                                                                                                    | // 1995 年 2 月に開始された X 氏の寛大なキャンペーンで// 定められた通り 1000$を超える請求には、全て 5%割引を// 適用する。                                |

※ ロジック中に、頻繁に C 風コメントでコメントを書くとまとめてコメントアウトする場合に不便なため、基本的にロジック中では単一行コメントを利用すること。

# パフォーマンス

パフォーマンスを考慮した Java のコーディングについて以下に示す。

※ パフォーマンスは jre のバージョンやスペックによって変化します。本内容は jre1.8.0\_74 での検証結果を元にした内容です。

※ 性能計測結果についての記載がありますが、あくまでも参考値です。性能を保証するものではありません。

## Stream API

Java8 で追加された Stream API での記述は、可読性も高く、簡潔に書けますが、パフォーマンス・性能面で注意が必要な場合があります。

List の処理を行う際、拡張 for 文で処理する場合は Iterator インスタンスが 1 つだけ生成されますが、Stream API で処理する場合、最初の Stream インスタンスに加え、各中間処理ごとにも Stream インスタンスが生成され、その分の性能劣化が懸念されます。\
以下に処理例と計測結果を記載します。

* 拡張 for 文

  ```java
  List<String> list = //数値文字列のList
  List<String> resultList = new ArrayList<>();
  for (String string : list) {
      if (string.endsWith("0")) {
          resultList.add(string);
      }
  }
  return resultList;
  ```

* Stream API

  ```java
  List<String> list = //数値文字列のList
  List<String> resultList = list.stream()
      .filter(s -> s.endsWith("0"))
      .collect(Collectors.toList());
  return resultList;
  ```

* 計測結果

  | 処理する List の件数 | 拡張 for 文 (ms) | StreamAPI (ms) |
  | -------------------: | ---------------: | -------------: |
  |             100 万件 |                7 |              9 |
  |           1,000 万件 |               88 |            114 |
  |               1 億件 |              949 |          1,026 |
  |               2 億件 |            1,822 |          2,081 |

小中規模の処理量であれば考慮するほどの性能差はありませんが、大量の処理が見込まれる場合は考慮が必要です。\
また、Stream API は並列処理（スレッド処理）の機能をサポートしていますので、利用できる場合は並列処理も含めての検証が必要です。

## ラムダ式・メソッド参照・コンストラクタ参照

Java8 で追加されたラムダ式・メソッド参照・コンストラクタ参照は、匿名クラスを利用するよりも効率的です。\
積極的な利用を推奨します。

以下に Comparator を生成した場合の計測結果を記載します。

* 匿名クラス

  ```java
  Comparator<String> c = new Comparator<String>() {
      @Override
      public int compare(String o1, String o2) {
          return o1.compareToIgnoreCase(o2);
      }
  };
  ```

* ラムダ式

  ```java
  Comparator<String> c = (o1, o2) -> o1.compareToIgnoreCase(o2);
  ```

* メソッド参照

  ```java
  Comparator<String> c = String::compareToIgnoreCase;
  ```

* 計測結果

  | 処理件数 | 匿名クラス (ms) | ラムダ式 (ms) | メソッド参照 (ms) |
  | -------: | --------------: | ------------: | ----------------: |
  |  10 億回 |             380 |   0(計測不能) |       0(計測不能) |
  | 100 億回 |           6,374 |   0(計測不能) |       0(計測不能) |
  |   1 京回 |     (30 秒以上) |            14 |                10 |

ラムダ式は外部の変数を利用する場合、匿名クラスとほぼ同じ動作をします。

* 匿名クラス

  ```java
  new Comparator<String>() {
          @Override
          public int compare(String o1, String o2) {
              return arg.equals("DESC") ? o2.compareToIgnoreCase(o1)
                                              : o1.compareToIgnoreCase(o2);
          }
      }
  ```

* ラムダ式

  ```java
  Comparator<String> c = (o1, o2) -> arg.equals("DESC") ? o2.compareToIgnoreCase(o1)
                                      : o1.compareToIgnoreCase(o2);
  ```

* 計測結果

  |                   処理件数 | 匿名クラス (ms) | ラムダ式 (ms) |
  | -------------------------: | --------------: | ------------: |
  |  10 億回（パラメータあり） |             571 |           572 |
  | 100 億回（パラメータあり） |           9,900 |         9,864 |

## 文字列連結

### 文字列連結（繰り返し）

文字列連結を繰り返し処理中で行う際、`+`演算子で処理することはアンチパターンとして知られています。\
繰り返し処理中の文字列連結は、 `StringBuilder`、 `StringJoiner`、 `StringBuffer` を利用します。\
また、コレクション要素の結合であれば`String#join`が利用できます。

以下に処理例と計測結果を記載します。

* `+`演算子

  ```java
  String s = "";
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          s += ",";
      }
      s += string;
  }
  return s;
  ```

* StringBuilder

  ```java
  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          sb.append(",");
      }
      sb.append(string);
  }
  return sb.toString();
  ```

* StringBuffer

  ```java
  StringBuffer sb = new StringBuffer();
  for (int i = 0; i < list.size(); i++) {
      String string = list.get(i);
      if (i > 0) {
          sb.append(",");
      }
      sb.append(string);
  }
  return sb.toString();
  ```

* String#join

  ```java
  return String.join(",", list);
  ```

* 計測結果

  | 処理する List の件数 | `+`演算子 (ms) | StringBuilder (ms) | StringBuffer (ms) | String#join (ms) |
  | -------------------: | -------------: | -----------------: | ----------------: | ---------------: |
  |             1,000 件 |              5 |        0(計測不能) |       0(計測不能) |      0(計測不能) |
  |               1 万件 |          1,016 |                  1 |                 1 |                1 |
  |              10 万件 |    (30 秒以上) |                  2 |                 5 |                5 |
  |             100 万件 |    (30 秒以上) |                 29 |                42 |               51 |

### 文字列連結（定数）

基本的に処理中の文字列連結では`+`演算子は使わないで処理するほうがパフォーマンスが高くなりますが、定数の場合は`+`演算子で定義するほうがパフォーマンスが高いです。

たとえば以下のように、処理したい場合、

```java
private static final String CONST_A = "A";
private static final String CONST_B = "B";
private static final String CONST_AB = CONST_A + CONST_B;
```

StringBuilder で処理しようとすると以下のようになります。

```java
private static final String CONST_AB = new StringBuilder(CONST_A).append(CONST_B).toString();
```

しかし、これらをバイトコード上で確認するとそれぞれ以下のようになります。

* `+`演算子

  ```java
  private static final java.lang.String CONST_AB = "AB";
  ```

* StringBuilder

  ```java
  private static final java.lang.String CONST_AB;

  static {};
     0  new java.lang.StringBuilder [20]
     3  dup
     4  ldc <String "A"> [8]
     6  invokespecial java.lang.StringBuilder(java.lang.String) [22]
     9  ldc <String "B"> [11]
    11  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [26]
    14  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [30]
    17  putstatic jp.co.packagename.ClassName.CONST_AB : java.lang.String [34]
    20  return
  ```

`+`演算子を利用した場合コンパイル時に最適化され、文字列`"A"`と`"B"`をあらかじめ結合して class が作成されます。\
`StringBuilder`を利用した場合は最適化はされず、記述した通りの処理が行われます。

計測した場合、下記のようになります。

* 計測結果

  |   処理回数 | StringBuilder (ms) | `+`演算子 (ms) |
  | ---------: | -----------------: | -------------: |
  | 5,000 万回 |                559 |    0(計測不能) |
  |     1 億回 |              1,059 |    0(計測不能) |

通常、定数処理を大量に処理することは考えられないので性能問題になることはありませんが、`+`演算子を利用したほうがパフォーマンスが高いこともあるということを理解してください。

## List の種類

`List`には`ArrayList`のような`RandomAccess`を implements した、ランダムアクセスをサポートしているクラスと、\
`LinkedList`のようなランダムアクセスをサポートしていない（シーケンシャルアクセス）クラスが存在します。\
`RandomAccess`ではない`List`は、`List#get`などインデックスを利用するような操作のパフォーマンスが低いので注意してください。

以下に処理例と計測結果を記載します。

* for 文(List#get(int)によるループ)

  ```java
  int size = list.size();
  for (int i = 0; i < size; i++) {
      String s = list.get(i);
      //処理
  }
  ```

* 拡張 for 文

  ```java
  for (String s : list) {
      //処理
  }
  ```

* forEach

  ```java
  list.forEach(this::処理);
  ```

* 計測結果

  | 処理する List の件数 | `ArrayList`for 文(List#get(int)によるループ) (ms) | `LinkedList`for 文(List#get(int)によるループ) (ms) | `ArrayList`拡張 for 文 (ms) | `LinkedList`拡張 for 文 (ms) | `ArrayList`forEach (ms) | `LinkedList`forEach (ms) |
  | -------------------- | ----------------------------------------------------: | -----------------------------------------------------: | ------------------------------: | -------------------------------: | --------------------------: | ---------------------------: |
  | 1 万件               |                                           0(計測不能) |                                                     73 |                     0(計測不能) |                      0(計測不能) |                 0(計測不能) |                  0(計測不能) |
  | 10 万件              |                                           0(計測不能) |                                                  7,576 |                     0(計測不能) |                      0(計測不能) |                           1 |                            2 |
  | 20 万件              |                                           0(計測不能) |                                                 17,740 |                     0(計測不能) |                      0(計測不能) |                 0(計測不能) |                  0(計測不能) |
  | 50 万件              |                                           0(計測不能) |                                            (30 秒以上) |                     0(計測不能) |                                2 |                 0(計測不能) |                            2 |
  | 100 万件             |                                                     1 |                                            (30 秒以上) |                     0(計測不能) |                                4 |                 0(計測不能) |                            4 |
  | 1,000 万件           |                                                    16 |                                            (30 秒以上) |                               8 |                               45 |                           6 |                           44 |

ランダムアクセスをサポートしている`List`がシーケンシャルアクセス（iterator を利用した処理など）で遅いということはないので、\
ループの処理は拡張 for 文等、Iterator によるループで記述するのが無難です。\
`List#get`での処理をすべて禁止することはできませんが、高いパフォーマンスが求められる場合は`List`の種類にも注目してみてください。

## String から Integer・Long への変換

数値文字列の`String`を`Integer`に変換するには、`Integer#valueOf(String)`を利用して下記のように記述します。

```java
String s = "1";
Integer value = Integer.valueOf(s);
```

しかし、下記のようにも記述できます。

```java
String s = "1";
Integer value = new Integer(s);
```

これらの違いは、\
`new Integer(s)`とした場合、必ず Integer インスタンスが生成されますが、\
`Integer.valueOf(s)`とした場合は -128 から 127 の間の数値であればキャッシュから取り出すためインスタンスを生成しません。

このため、前者の`Integer#valueOf(String)`を利用した記述のほうが効率的です。\
`Long#valueOf(String)`も同様です。

性能差が少ないため、ほとんど問題にはなりませんが、FindBugs 等、静的解析で検出される問題のため、理解が必要です。

また、String からの変換だけでなく、int や long からの変換も`#valueOf`が効率的ですが、オートボクシングを利用した場合、コンパイルで自動的にこれらの処理に変換されるため、記述することはありません。

## String から int・long への変換

数値文字列の`String`を`int`に変換するには、`Integer#parseInt(String)`を利用して下記のように記述します。

```java
String s = "1";
int value = Integer.parseInt(s);
```

しかし、オートボクシングが利用できるため、意図せず下記のように記述ミスをする場合があります。

```java
String s = "1";
int value = Integer.valueOf(s);//取得したIntegerインスタンスをオートボクシングでintにcastしている
```

```java
String s = "1";
int value = new Integer(s);//生成したIntegerインスタンスをオートボクシングでintにcastしている
```

「オートボクシング」の説明に記載した通り、性能に差が出るだけでなく、\
記述から明らかにミスであることが解るため、FindBugs 等、静的解析で検出されるコードです。

`long`への変換の場合は`Long#parseLong(String)`を利用します

以下に計測結果を記載します。

* 計測結果

  |   処理回数 | Integer.valueOf(String) (ms) | Integer#parseInt(String) (ms) |
  | ---------: | ---------------------------: | ----------------------------: |
  | 1,000 万回 |                          396 |                           318 |
  |     1 億回 |                        4,060 |                         3,077 |

## BigDecimal の ZERO との比較

BigDecimal の正・負・ZERO の判定は`BigDecimal#signum`を利用します。\
`compareTo`を利用して`BigDecimal.ZERO`と比較しても同じことができますが、`signum`を利用したほうが効率的です。

以下に処理例と計測結果を記載します。

* compareTo 利用

  ```java
  BigDecimal value = new BigDecimal("0.0");
  if (value.compareTo(BigDecimal.ZERO) == 0) {
  ```

* signum 利用

  ```java
  BigDecimal value = new BigDecimal("0.0");
  if (value.signum() == 0) {
  ```

* 計測結果

  （単位：マイクロ秒）

  | 処理回数 | compareTo 利用 (マイクロ秒) |   signum 利用 (マイクロ秒) |
  | -------: | --------------------------: | -------------------------: |
  |   1 京回 |  527max:26,367min:0 | 424max:21,213min:0 |

性能差が少ないので、必ずしも signum を利用する必要はありませんが、大量に処理する場合など、高いパフォーマンスが求められる場合は意識してください。

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)

---

---
url: >-
  /coding-standards/documents/forOpenAPISpecification/OpenAPI_Specification_2.0.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# はじめに

[OpenAPI Specification 2.0（Swagger, OAS2）](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md)定義についてのコーディング規約をまとめます。より新しいバージョンとして OAS 3.0.3 規約（作成中）がありますので、ご注意ください。

# 前提条件

本規約は以下の前提で作成されたものである。。ToC 向けの LSUDs（Large Set of Unknown Developers）な Web API にはマッチしない可能性があります。

* 業務システム向けの Web API 提供
  * サードパーティ向けに広く開発する Web API ではなく、限られたクライアントやシステムと連携すること
  * いわゆる、LSUDs（Large Set of Unknown Developers）ではなく、SSKDs（Small Set of Known Developers）を対象とする
* RESTish な Web API
  * 原理的な REST を必ずしも守る必要はないが、例えば HTTP メソッドは、参照は GET、登録は POST、更新は PUT や PATCH、削除は DELETE で使い分けていたり、Web API の要求が成功すれば 200（OK）、204（No Content）を返し、リソースが無ければ 404（Not Found）、操作に失敗すれば 500 系のエラーを返すといったことを指す
  * 本規約を利用するに当たり必須条件ではないが、定義例などはそれに基づいて記載しているので注意する
* スキーマファースト
  * OpenAPI Specification の定義ファイルを駆動に、クライアント・サーバサイドのコード生成やモック時の利用に用い、高速な Web API 開発につなげることを前提とする
    * Python における、FastAPI・Django REST Framework のように、アプリケーションコードから OpenAPI document を自動生成する開発手法も存在するが、本規約はこれは想定しない
  * 定義ファイルの完成度はできるかぎり高め、コード生成やドキュメントの価値を高める
    * OAS 定義からコードを生成し、通常は記載した型・項目長・最大～最小・enum・必須定義・正規表現フォーマットでバリデーションを行い、カバーできない部分のバリデーションをアプリケーション固有ロジックとして実装する方針とする。例えば、複数項目間のチェックや DB を確認しないと行えないチェックである
    * ドキュメントとしての価値を高めるため、その API 呼び出しで発生しうる全ての HTTP ステータスコードを記載する
      * API の振る舞いを読み手に伝えるものとして、どのような異常系があるかは有用な場合が多いからである
* JavaScript/TypeScript、Java、Go のエコシステムがターゲット
  * OpenAPI Specification は広く受け入れられており、コレに対応する様々なツールやフレームワークといったエコシステムがあり、中には定義された設定がうまく認識されない場合がある。本規約では対応していないツールが多い場合、特定の記法を非推奨とすることがあり、同時にその理由も説明する
  * 全ての言語・フレームワーク・ツールの対応状況は調査しきれていないため、利用するプロダクトの対応状況は利用者側で確認をお願いする

# 免責事項

::: warning 有志で作成したドキュメントである

フューチャーアーキテクトには多様なプロジェクトが存在し、それぞれの状況に合わせた開発手法が採用されている。本規約はフューチャーアーキテクトの全ての部署／プロジェクトで利用されているわけではなく、有志が観点を持ち寄って新たに整理したものである。相容れない部分があればその領域を書き換えて利用することを想定している

:::

# API設計

Web API の設計自体は、[Web API設計ガイドライン | Future Enterprise Arch Guidelines](https://future-architect.github.io/arch-guidelines/documents/forWebAPI/web_api_guidelines.html)を参考にすること。

# YAMLファイルフォーマット

OpenAPI ドキュメントは JSON 形式、YAML 形式いずれかのフォーマットで記載できるが **YAML 形式** を利用する。理由として、JSON と比較して YAML は視覚的に見やすく、レビューや差分管理が行いやすいためである。

## ファイル名

ファイルの拡張子は `yaml` とする。通常ファイル名は `api.yaml` や `swagger.yaml`（v2 の場合） を推奨する。

もし、複数の Swagger 定義を管理するため区別したい場合は `${service}_api.yaml` とする。

`${service}` にはサービス名を指定する

## YAML バージョン

[YAML v1.2](https://yaml.org/spec/1.2.2/#61-indentation-spaces)を用いる。

## ファイルレイアウト

* ファイルの最終行には空行を入れる
* 文字コードは UTF-8 とする
* タブは半角スペース 2 つとする

## クォート

クォートは可読性を上げるために、できる限り利用しない。利用する場合はダブルクォートを利用する。

```yaml
# OK
description: 何かしらの説明

# NG（クォートでのラップは不要）
description: '何かしらの説明'
description: "何かしらの説明"
```

以下の場合は必須で利用する

* 文字列として認識させる必要のある数字（"0123"）
* 60 進数と認識させたくない場合（"12:34"）
* Bool として認識させたくない（"true", "false", "yes", "no", "y", "n", "on", "off"）
* `#` で始まる文字列（`#` はコメントを示す記号のためである。例: `#/definitions/Users`）

## YAML 配列スタイル

* 複数項目を指定する場合は、 **Flow style(配列スキーム)** を用いることを推奨する

  ```yaml
  # OK（推奨: 配列リテラル構文）
  required: [user_id, user_name, account_type, register_at]

  # NG（非推奨: リスト構文）
  required:
    - user_id
    - user_name
    - account_type
    - register_at
  ```

  * YAML は項目定義がネストすることで縦長な定義になりやすい。情報密度を上げるために配列リテラルを推奨する

## 改行の表現

改行を含む場合は、パイプ（ブロックスカラー） `|` を用いる

```yaml
description: |
  説明文1
  説明文2
     - 箇条書き1
     - 箇条書き2
     - 箇条書き3
```

# 要素規約

Swagger の基本構造は以下の、swagger・info・host・basePath・schemes・paths・definitions から構成される。

要素の並び順は、原則 [OpenAPI Specification 2.0（Swagger, OAS2）](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md) に記載された順番に記載する。

```yaml
swagger: "2.0"
info:
  title: サンプルAPI
  description: サンプルAPIはシステムにおけるユーザーのアカウント、契約、支払い、注文履歴などを管理できます
  version: 1.0.0
host: api.example.com
basePath: /v1
schemes:
  - https
consumes:
  - application/json
produces:
  - application/json
tags:
  - name: user
    description: ユーザー
paths:
  /users/{user_id}/account:
    get:
      tags:
        - user
      summary: API-001 ユーザーアカウント取得
      description: ユーザーのアカウント情報を取得します
      operationId: getUserAccount
      parameters:
        - name: user_id
          in: path
          type: string
          pattern: ^[0-9a-zA-Z_-]*$
          minLength: 4
          maxLength: 16
          required: true
          description: 登録時に設定されたユーザーID
      responses:
        "200":
          description: OK
          schema:
            $ref: "#/definitions/UserAccount"
        "400":
          description: パラメータ不正
          schema:
            $ref: "#/definitions/Error"
        "404":
          description: リソースが存在しない
          schema:
            $ref: "#/definitions/Error"
        "500":
          description: 内部エラー
          schema:
            $ref: "#/definitions/Error"
        default:
          description: その他予期せぬエラー
          schema:
            $ref: "#/definitions/Error"
definitions:
  UserAccount:
    required: [user_id, user_name, account_type, register_at]
    properties:
      user_id:
        type: string
        description: ユーザーID
        minLength: 4
        maxLength: 16
        example: 32AB1aaad100eavV
      user_name:
        type: string
        description: ユーザー名
        minLength: 1
        maxLength: 128
        example: 未来太郎
      account_type:
        type: string
        description: アカウント種別(1:ゲスト 2:登録済み 3:プレミアム 4:管理者)
        minLength: 1
        maxLength: 1
        example: "1"
      register_at:
        type: string
        description: 登録日時
        format: date-time
        example: "2023-04-01T11:30:45.000Z"
```

# swagger

* `2.0` 固定とする

# info

info オブジェクトには Web API に関するメタデータを記載する。
`title`, `description`, `version` を必須項目とする。

| フィールド名   | 必須 | 記載内容                         |
| -------------- | :--: | -------------------------------- |
| title          |  ○   | Web API の総称                   |
| description    |  ○   | Web API の簡単な説明             |
| version        |  ○   | OpenAPI ドキュメントのバージョン |
| termsOfService |      | 利用規約の URL                   |
| contact        |      | 連絡先情報                       |
| license        |      | ライセンス情報                   |

## title

WebAPI の総称を記載する。システム名やサービス名 + API のような命名とすることを推奨する。
例. `X System API`

## desctiption

Web API が提供する機能の概要・想定する利用者やユースケース・制約などを記載する。

## version

この API 仕様のドキュメントのバージョンを記載する。アプリケーションのバージョン（git tag やリリースで管理するようなバージョン）とは別である。

本規約の推奨は `major.minor` 形式である。 `0.1 `固定で開発を進め、サービスのリリース時に `1.0` とし、その後の項目やオプション、パスの追加ごとに `1.1` などインクリメントしていく。もし他チームへのドキュメントの頻繁な共有が必要だれば、`1.0` のかわりに `2023.03.26` といった形式も許容する。

# host

OpenAPI 3 系と異なり、 **Swagger では複数のホストを指定できない**。そのため host には開発環境（local, develop, staging, production というステージ区別であれば、develop）で用いる IP、ポート番号を指定する。他チームに提供するサンドボックス環境を用意する場合は、そのエンドポイントを指定しても良い。localhost などのローカル開発への向き先変更は、ツール側で対応している事が多く上書き可能なため記載しない。API 定義書は予期せぬタイミングで他チームに展開する必要がしばしばあり、お試しで触っても良い環境があることを示すことで情報量を増やし、円滑なコミュニケーションを促進することを狙いとする。

```yaml
# OK
host: dev.api.example.com:80
host: sandbox.api.example.com:80

# NG（ローカル開発で用いる環境を指定する）
host: localhost:8001

# NG（LSUDs向けのWeb API開発では不用意に本番環境を触られたくないときが多く、避けるべきである）
host: prod.api.example.com:80
```

# basePath

作成する Swagger 定義の URL パスの全てで、共通するプレフィックスを持つ場合に指定する。Swagger の仕様上、先頭には `/` が必須であるため、以下のように定義する。

```yaml
# OK
basePath: /v1
basePAth: /api/v2

# NG
basePath: v2
```

# schemes

最終的に利用するスキーマのみを記載する。通常、HTTP 通信での Web API 提供は行わないと考えられるため、 `https` 固定で設定する。ローカル開発では `http` を指定することも多いが、ツールで生成されたコードのオプションで通常書き換えが可能なため、`http` の併記は許可しない。ただし、サーバサイドのマイクロサービス同士の通信で、VPC（プライベートセグメント）内であり、SSL 通信を本当に利用しない場合は `http` と記載する。

```yaml
# OK
schemes:
  - https

# NG（httpの指定は通常、Web APIサーバアプリケーションの開発時を除いて不要であるためわざわざ追加しない）
schemes:
  - http
  - https
```

もし、WebSocket スキームを提供するサービスの定義である場合は、`wss` を（追加で）指定する。定義上は `https` 側との共存ができないため、ファイル定義を分けるようにする。

# security, securityDefinitions

Swagger では、次の認証タイプを記載できる（[詳細](https://swagger.io/docs/specification/2-0/authentication/)）。

1. ベーシック認証
2. API キー（リクエストヘッダ, クエリパラメータ）
3. OAuth2

もし、認証が必須であれば記載する。全ての Web API で未認証を受け入れる場合は記載しない。認証の要否が API ごとに異なる場合は、各 API 側で `security: []` と記載しして上書き定義する必要がある。

```yaml
# OK
securityDefinitions:
  OAuth2:
    type: oauth2
    flow: accessCode
    authorizationUrl: https://example.com/authorize
    tokenUrl: https://example.com/.well-known/jwks.json

# OK（OAuth2認証ありの場合）
paths:
  /users/{user_id}/account:
    get:
      ...
      security:      # 認証が不要な場合は security: [] と記載する
        - OAuth2: []
```

# produces

Web API が応答する際の MIME タイプを指定します。未指定の場合に、コード生成などツール側で予期しない動作をすることがあるため、固定で指定する。新規構築の Web API であれば `application/xml` は不要と通常は考えられるので、`application/json` を記載する。また、[RFC 7807 Problem Details for HTTP APIs](https://www.rfc-editor.org/rfc/rfc7807) では Content-Type に `application/problem+json` を設定するとあるが、一部のコード生成ツールにおいて、 `application/problem` と `application/problem+json` の使い分けが難しいため、併記を必須としない。OpenAPI Specification の 3 系ではステータスコードごとに Content-Type を指定できるため、3 系への移行も検討する。

```yaml
# OK（applicaton/problem+json 無しでも良い）
produces:
  - application/json

# OK（利用するツールで複数のContent-Typeの使い分けが実現しやすい場合は以下でも良い）
produces:
  - application/json
  - application/problem+json
```

ある API のみ、バイナリ（画像データなど）を返すなどのケースがあれば、 `paths` 配下で上書き指定する。

```yaml
paths:
  /logo:
    get:
      summary: API-002 ロゴ画像を取得する
      description: サービスのロゴ画像をpng形式で取得します
      operationId: getLogoImage
      produces:
        - image/png
      responses:
        "200":
          description: OK
          schema:
            type: file
```

# consumes

Web API が要求を受け入れる際の MIME タイプを指定する。未指定の場合に、コード生成などツール側で予期しない動作をすることがあるため、固定で指定する。新規構築の Web API であれば `application/xml` は不要と通常は考えらえるので、`application/json` だけ記載する。

仕様上、 `consumes` は POST, PUT, PATCH を利用した操作のみに影響し、GET などリクエストボディが無い操作では無視される。

```yaml
# OK
consumes:
  - application/json
```

# tags

タグを用いて、API 操作をグループ化することができる。ドキュメントやツールにとって非常に重要であるため、 **必須** で指定する。

* Swagger UI（HTML ドキュメント）の順序を制御できる
  * 未指定の場合は、登場順で生成されてしまう
* 命名は、 **単数形** で、小文字かつ半角スペース区切り で記載する
  * コード生成で利用され、Go ではパッケージ名や TypeScript の Class 単位となるため、シンプルな命名にする
  * HTML ドキュメントで参照する場合の可読性を上げるため、単語を半角スペース区切りとする
* タグごとに `description` も必須で記載する

```yaml
# NG
tags:
  - name: product
    description: 製品
  - name: store
    description: 店舗
  - name: user account
    description: ユーザーアカウント

# NG
tags:
  - name: products
  - name: stores
  - name: user_account
  - name: UserAccount
```

# paths

`paths` 配下に個々の API エンドポイントを記載する。

`paths` は根幹となる定義部分であり、以下のように重要な定義が続く。それぞれ重要な要素ごとに規約を示す。

```sh
Paths              # API定義全体
  └ Path           # URLパス
    └ Operation    # HTTPメソッド
      ├ Parameter  # リクエストパラメータ
      └ Responses  # レスポンス
        └ Response # ステータスコードに応じたレスポンス
```

## Paths > Path

記載順は以下のルールである。

* トップレベルの `tags` でグルーピングした順番に記載する
* URL は短いものから並べる
* HTTP メソッドは、 head, get, post, put, patch, delete の順にする

```yaml
# 並び順の例（HTTPメソッドの子要素はtags以外を省略）
tags:
  - user
  - item
paths:
  /users:
    get:
      tags:
        - user
      ...
  /users/{user_id}/account:
    get:
      tags:
        - user
      ...
  /users/{user_id}/account:
    patch:
      tags:
        - user
      ...
  /items:
    get:
      tags:
        - item
      ...
```

## Paths > Path > Operation

URL に紐づく HTTP メソッドで、1 つの操作を定義します。

* `summary`
  * API の操作概要を summary に記載する
  * 機能 ID があるのでれば、ここに記載する
  * 例: `API-001 ユーザアカウント取得`
* `description`
  * API の振る舞いの詳細や注意点（ある条件で区分の値が変わったり、権限についての注意、要素が空になるなど）を記載する
* `operationId`
  * コード生成で利用される項目なので、必須で指定する
  * 原則、`camelCase` の `${HTTPメソッド}${機能物理名}` で記載する（例: getUser, postUser, deleteUser）
    * ただし、HTTP メソッドに紐づかない操作であれば、HTTP メソッドの代わりに個別の動詞（例: searchUser, moveItemList, addPermission）を当てはめる
    * コード生成対象によっては、get\_user（Python）、GetUser（Go）といった命名規約にしたくなるが、通常はコード生成側で配慮してくれる
* `consumes`, `produces`
  * トップレベルに `application/json` を記載しているため、同様であれば記載しない

```yaml
/users:
  get:
    tags:
      - user
    summary: API-001 ユーザーアカウント取得
    description: |
      ユーザーのアカウント情報を取得します。
      ログイン情報が不正の場合はアカウントが存在しても404を返すことがあります。
      アカウント種別については【別紙】X_定数一覧 を参照ください。
    operationId: getUser
    parameters: ...
    responses: ...
```

## Paths > Path > Parameter

リクエストの定義を記載する。

* `name`
  * `snake_case` で物理名を記載します
  * HTTP メソッドが POST/PUT/HTTP の場合は `body` に固定する

* `in`
  * 仕様上、必須で `query`, `header`, `path`, `formData`, `body` のどれかを指定する
  * HTTP メソッドが HEAD/GET/DELETE の場合
    * `path`, `query` のみの利用を推奨する
  * HTTP メソッドが POST/PUT/HTTP の場合
    * `body` のみの利用を推奨する

* `required`
  * 必須の場合のみ記載する。デフォルト false であるため、任意項目の場合は記載しない
  * POST, PUT で用いるリクエストボディに対しては、 `required: true` を必ず指定する
    * リクエストボディ自体が未指定だった場合、各項目の `required: true` を指定していてもサーバサイドのチェックが有効に働かないことがあるため

* `pattern`, `minLength`, `maxLength` などの条件について
  * <https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#fixed-fields-7> を参考に、指定できる条件はなるべく細かく指定する

* `schema`

  * リクエストボディは、`$ref` を用いて、`#/definitions` 配下に記載する。**$ref を用いない記載は許可しない。**

  ```yaml
    # OK
    - name: body
      in: body
      required: true
      schema:
        $ref: "#/definitions/PutUserAccount"

    # NG
    - name: body
      in: body
      required: true
      type: object
      required: [user_name, account_type, register_at, point]
      properties:
        user_name:
          type: string
          ...
        account_type:
          type: string
          ...
  ```

  * モデル名は、 `{HTTPメソッド名}{物理名}` の PascalCase で記載する
    * 例: PutUserAccount、PostUserAccount, PatchUserAccount

* `desription`
  * 項目の論理名や補足説明を記載する

```yaml
  /users/{user_id}/account:
    get:
      ...
      parameters:
        - name: user_id
          in: path
          type: string
          pattern: ^[0-9a-zA-Z_-]*$
          minLength: 4
          maxLength: 16
          required: true
          description: 登録時に設定されたユーザーID
      responses:
        ...
    put:
      ...
      parameters:
        - name: user_id
          in: path
          type: string
          pattern: ^[0-9a-zA-Z_-]*$
          minLength: 4
          maxLength: 16
          required: true
          description: 登録時に設定されたユーザーID
        - name: body
          in: body
          required: true
          schema:
            $ref: "#/definitions/PutUserAccount"
      responses:
        ...
```

## Paths > Path > Responses

レスポンスの定義を記載する。

* `description`
  * 必須で記載する
* ステータスコードは発生し得る全てのパターンを列挙する
  * 正常系の `200 OK`、 `201 Created`、`202 Accepted` `204 No Content` 以外の、異常系も忘れず記載する
  * 通常発生しない、サーバサイドの内部的な予期せぬエラー `500 Internal Server Error` は必須で記載する
  * リクエストパラメータが存在する場合は `400 Bad Request` が、認証がある場合は `401 Unauthorized` や `403 Forbiddend` が考えられる
  * `default` は必須で指定する
    * 例えば、URL 自体が存在しない場合の `404 NotFound` や、提供していない HTTP メソッドを呼び出した場合に `405 Method Not Allowed` を、自動生成したサーバサイドの実装が返すことがある。この場合、 `default` を指定していないとフロントエンド側でパースエラーとなることがあるため。各 API エンドポイントのサーバサイド側の実装が応答しないコードは、 `default` でまとめて指定させる

```yaml
  /users/{user_id}/account:
    get:
      ...
      parameters:
        ...
      responses:
        "200":
          description: OK
          schema:
            $ref: "#/definitions/Users"
        "400":
          description: パラメータ不正
          schema:
            $ref: "#/definitions/Error"
        "404":
          description: リソースが存在しない
          schema:
            $ref: "#/definitions/Error"
        "500":
          description: 内部エラー
          schema:
            $ref: "#/definitions/Error"
        default:
          description: その他予期せぬエラー
          schema:
            $ref: "#/definitions/Error"
    post:
      ...
      parameters:
        ...
      responses:
        "201":
          description: 新規登録に成功
          schema:
            $ref: "#/definitions/UserAccount"
        "400":
          description: パラメータ不正
          schema:
            $ref: "#/definitions/Error"
        "409":
          description: すでに登録済みのユーザーIDを用いている
          schema:
            $ref: "#/definitions/Error"
        "500":
          description: Internal Server Error
          schema:
            $ref: "#/definitions/Error"
        default:
          description: "その他予期せぬエラー"
          schema:
            $ref: "#/definitions/Error"
```

# definitions

* モデル名は、PascalCase で記載する

* 種別が配列の場合、ネストして定義するのではなく、 `$ref` を活用する

* もし、リソース名が単複同形で `type: array` と区別できない場合、 `List` を末尾に付けて区別する

  * そうではない場合は `s` を付けて表現する

  ```yml
  # OK
  - in: query
    name: product_types
    type: array
    description: プロダクト種別

  # NG
  - in: query
    name: product_type_list # xxx_listはNG
    type: array
    description: プロダクト種別
  ```

* リクエストボディ
  * 必須項目は `required` で項目を全て指定する
  * その他、項目定義として可能であればできる限り細かく指定する

* レスポンスボディ
  * `type`, `description`, `example`が必須。
  * `format`, `minLength`, `maxLength` などの型桁はできる限り細かく指定する
    * 多くのクライアントは RDB をデータストアに持ち、それらの型定義の参考にするためである
  * `enum` は **指定してはならない**
    * 一部のクライアント側のコード生成で、存在しない区分値を指定するとエラーになる（レスポンスを受信できない）。これはサーバサイドで区分値を増やす必要があるケースで、サーバ・クライアントの同期をとる必要があり困難なケースが多い。例えばクライアントがモバイルである場合、サーバサイドで区分値を追加した場合には、全端末でアプリアップデートが必要となリ、事実上 API 互換性がなくなるため、v1 を保持しつつ、区分値を追加した v2 の Path を追加する必要が出てくる
  * `pattern` の指定は不要
    * `pattern` も enum と同様に、サーバサイドが当初よりリクエストのバリデーションを緩めた場合に、古い `pattern` でクライアントがレスポンスを検証すると動作しなくなるため。クライアントサイドが RDB など書き込み時のスキーマが厳密であったとしても、正規表現レベルの厳格さで書き込みチェックをすることは無いと考えられる
  * `example` の値は、 例えば Prism でサーバのモックとして動かす場合に返される値になるため、できる限り具体的な値にする
  * 空文字、false, 0 値を返しうる項目に、`x-omitempty :false` を付与する
    * ツールの実装によっては、0 値や false を返した場合に JSON フィールドから除外される（omit される）ことがある

* 日付は `2023-04-02` といった ISO 8601 date フォーマットを推奨する。この場合は `fromat: date` を指定する

* 日時は `2023-04-02T15:04:05+09:00` といった ISO 8601 datetime フォーマットを推奨する。この場合は、 `format: date-time` を指定する

* エラーについて
  * API 全体で一貫したエラーを返すことを推奨とし、そのために `"#/definitions/Error"` といった共通のエラーモデルを利用を推奨する
  * [RFC 7807 Problem Details for HTTP APIs](https://www.rfc-editor.org/rfc/rfc7807) があるため、レイアウトを参考にする

```yaml
definitions:
  UserAccounts:
    type: array
    items:
      $ref: "#/definitions/UserAccount"
  UserAccount:
    required: [user_id, user_name, account_type, register_at, point]
    properties:
      user_id:
        type: string
        description: ユーザーID
        minLength: 4
        maxLength: 16
        example: 32AB1aaad100eavV
      user_name:
        type: string
        description: ユーザー名
        minLength: 1
        maxLength: 128
        example: 未来太郎
      account_type: # enumは指定しないこと
        type: string
        description: アカウント種別(1:ゲスト 2:登録済み 3:プレミアム 4:管理者)
        minLength: 1
        maxLength: 1
        example: "1"
      register_at:
        type: string
        format: date-time
        description: 登録日時
        example: "2023-04-01T11:30:45.000Z"
      point:
        type: integer
        format: int64
        description: ポイント（0ポイント以上）
        exampe: 421
  PostUserAccount:
    required: [user_id, user_name, account_type, register_at]
    properties:
      user_id:
        type: string
        minLength: 4
        maxLength: 16
        pattern: ^[0-9a-zA-Z_-]*$
        description: ユーザーID
        example: 32AB1aaad100eavV
      user_name:
        type: string
        minLength: 1
        maxLength: 128
        description: ユーザー名
        example: 未来太郎
      account_type:
        type: string
        minLength: 1
        maxLength: 1
        enum: ["1", "2", "3", "4"]
        description: アカウント種別(1:ゲスト 2:登録済み 3:プレミアム 4:管理者)
        example: "1"
      register_at:
        type: string
        format: date-time
        description: 登録日時
        example: "2023-04-01T11:30:45.000Z"
  Error:
    description: エラー (RFC 7807)
    type: object
    required: [title, status, detail]
    properties:
      title:
        type: string
        description: タイトル
        minLength: 1
        maxLength: 64
        example: request validation error
      status:
        type: integer
        format: int32
        description: HTTPステータスコード
        minimum: 400
        maximum: 600
        exclusiveMaximum: true
        example: 503
      message_cd:
        type: string
        description: 状態の切り分けとアクションが一意に特定できるメッセージコード
        minLength: 1
        maxLength: 16
        example: APPERR-0001
      detail:
        type: string
        description: エラーメッセージ詳細
        minLength: 1
        maxLength: 128
        example: user name is too long
```

# バリデーション

OpenAPI 定義を記載するにあたり、バリデーションをどこまで厳密に定義すべきかという議論はよく行いがちである。

リクエストパラメータの各項目に対して、必須・型・桁・区分値・日付・正規表現のチェックが行える。レスポンスで用いるモデルについても同様に設定でき、`enum`, `pattern` 以外は API の利用者（クライアント）側の DB 設計などに必要な型桁情報を渡すのに有用であるため、できる限り詳しく指定する。

## 必須

必須パラメータのみ `required: true` を定義する

## デフォルト値

パラメータにデフォルト値がある場合は`default` を定義する。

```yaml
# ex. enum
name: limit
type: number
format: integer
minimum: 1
maximum: 100
default: 20
description: 検索結果の項目数上限（1~100が指定可能）
```

【注意】API 公開後に、default 値を変更してはならない（API の互換性が崩れるため）。もし変更する場合は、API のバージョンを上げること。

## 型・フォーマット

型（`type`）は `string(文字列)`, `number（数値）`, `integer（整数値）`, `boolean（真偽値）` `array（配列）`, `file（ファイル）` のうちどれか指定する.

フォーマット（`format`） は以下の型の詳細情報を示すもので、可能な限り設定する。

* `integer` （整数）
  * `int32`, `int64`
* `number` （数値）
  * `float`, `double`
* `string` （バイナリ）
  * `byte`: Base64 でエンコードされた文字列
  * `binary`: バイト配列
* `string` （日付）
  * `date`: [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) full-date(例: 2023-07-21)
    * 項目名は `_on` を接尾辞につけることを推奨とする
  * `date-time`: [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) date-time(例: 2023-07-21T17:32:28Z)
    * 項目名は `_at` を接尾辞につけることを推奨とする
* `string` （その他）
  * `password`: Swagger UI で入力が隠される
  * その他、 `email`, `uuid` など Open API 仕様に存在しない任意のフォーマットを独自のドキュメント生成などのために記載しても良い

## 桁

データ型によって、利用できる桁を指定する項目が異なる。可能な限り設定する。

* 文字列
  * 最大桁数：`maxLength`
  * 最小桁数：`minLength`
* 数値または整数値
  * 最小値（境界値を含む）：`minimum`
  * 最大値（境界値を含む）：`maximum`
  * 境界値を含まない場合のみ`exclusiveMinimum: true`または`exclusiveMaximum: true`を定義する。minimum, maximum で代用できる場合は利用しない
* 配列:
  * 最大要素数：`maxItems`
  * 最小要素数：`minItems`
  * `required: true`の場合は原則として`minItems: 1`を定義する
  * `uniqueItems` は必須で指定する（通常は一意であるべき）

【注意】API 公開後に、レスポンスの `maxLength` を以前より大きい値に変更してはならない。レスポンスの `maxLength` など API 利用者側システムの DB の ERD 定義のインプットになる事が多いため。もし行う場合は API のバージョンを上げることや、連携先に桁数変更の旨を調整するなどの考慮を行う。

## 区分値

区分値の場合は `enum` 属性を利用し、`description`には区分値の論理名を記載する。

```yaml
name: gender
type: string
enum: ["0", "1", "2", "9"]
description: |
  性別
    0: 不明
    1: 男
    2: 女
    9: 適用不能
```

## 固定値

**固定値** の場合も enum を 1 つだけ指定して表現する。この場合もレスポンスで利用する場合は指定しない

```yaml
name: file_layout
type: string
enum: ["json"]
description: ファイルレイアウト
```

## その他（正規表現）

正規表現で表現できる文字列は`pattern`を利用して定義する。桁や区分値で代替できる場合は、`pattern` を用いない

例:

```yaml
remind_time:
  type: string
  description: リマインド時刻。（hh:mm）形式
  example: 23:59
  pattern: "^(2[0-3]|[01][0-9]):([0-5][0-9])$"
```

## ファイルアップロード

[Web API設計ガイドライン>ファイル連携>ファイルアップロード](https://future-architect.github.io/arch-guidelines/documents/forWebAPI/web_api_guidelines.html#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%A2%E3%83%83%E3%83%95%E3%82%9A%E3%83%AD%E3%83%BC%E3%83%88%E3%82%99) で推奨された「署名付きURL」を用いた手法を採用する場合、次のようなフローとする。

```mermaid
sequenceDiagram
participant A as クライアント
participant B as Web APIサーバ
participant C as オブジェクトストレージ

A->>B: ①アップロード先URL取得
  B->>C: Signed URL発行
  C-->>B: Signed URL
  B-->>A: アップロードURL、受付ID（加えて、アップロードで指定したいHTTP Methodや必要なリクエストヘッダがあれば応答の項目に追加する）

A->>C: ②ファイルアップロード

A->>B: ③ファイルアップロード完了(受付ID、キー、属性)
  B-->>A: 受付完了
```

フローの ①、② はアプリケーション固有の紐づけルールにおいて Web API を設計すれば良いため、本規約で YAML の設定例は記載しない。フロー ② については Signed URL を用いたアップロードであり、アプリケーションの Web API 定義を書く必要はない。もし、監査ログなどのガバナンス上、直接オブジェクトストレージへの書き込みを許容されないケースは、B で Signed URL に相当する書き込み先を提供し、B を経由してファイルをアップロードする。

上記どちらのケースも OpenAPI 定義としてはシンプルであるため、記述例は割愛する。

## ファイルダウンロード

[Web API設計ガイドライン>ファイル連携>ファイルダウンロード](https://future-architect.github.io/arch-guidelines/documents/forWebAPI/web_api_guidelines.html#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%BF%E3%82%99%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%88%E3%82%99) で推奨された方法は、Signed URL をレスポンスの JSON 項目に渡すか、ファイル容量がごく小さい場合に限り Base64 にエンコードして JSON に埋め込んで渡すかの2つである。

どちらのケースも OpenAPI 定義としてはシンプルであるため、記述例は割愛する。

# CORS

CORS（Cross-Origin Resource Sharing）のために、options メソッドの追記は **原則不要** とする。

理由は以下である。

* サーバ側
  * options メソッド対応は、API 使用ではなく実装レベルの機能横断的な処理（Java における Servlet Filter や Spring の Interceptor、Go における Middleware など）で行うことが大半であり、コード生成が不要
* クライアント側
  * options メソッドを用いるのはクライアントがブラウザであり、クライアントのアプリケーションコードが明示的にアクセスしないため、コード生成が不要
* 使用面として
  * ` Access-Control-Allow-Origin` がどのような値を返すか、呼び出し元によって動的な値を返したい場合があり、記載が困難なケースがある

ただし、Amazon API Gateway のようなサービスを利用する場合は、options メソッドの記載が必須である場合は除く[^1]。

[^1]: https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/enable-cors-for-resource-using-swagger-importer-tool.html

# OpenTelemetry Traceparent HTTP Header

OpenOpenTelemetry で用いるられる[traceparent](https://www.w3.org/TR/trace-context/) のリクエストヘッダーは OpenAPI で **原則不要** とする。

理由は以下である。

* OpenTelemetry が定めるヘッダー類は、API 横断的に設定されるべきものであり、ミドルウェアやフレームワーク側などでの一律の制御を推奨するため
* 記載することにより、OpenOpenTelemetry に対応していることを明記し開発者に周知できるメリットより、各アプリ開発者が生成されたコードで悩んだり、誤解されることを回避したいため

# API のバージョン管理

Swagger 定義で以下の変更を行う場合は、利用するコード生成の動作によってはクライアントにとって互換性を失う破壊的変更であることがあるため、変更は調整の上で行うか、バージョンを上げることを考える。

* リクエスト項目
  * フィールドの型を変更する
  * 桁数を小さくする
  * enum の種類を減らす
  * 正規表現のチェックを厳しくする
  * 必須フィールドを後から追加する
  * デフォルト値を後から変更する
* レスポンス項目
  * フィールドの型を変更する
  * 桁数を大きくする
  * デフォルト値を後から変更する

# ファイル単位

[OpenAPI\_Specification\_3.0.3規約 > ファイル分割](https://future-architect.github.io/coding-standards/documents/forOpenAPISpecification/OpenAPI_Specification_3.0.3.html#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%88%86%E5%89%B2)に準じる。

# 推奨ツール

[本当に使ってよかった OpenAPI (Swagger) ツール ](https://future-architect.github.io/articles/20191008/) にあるように、様々なツールで開発ができる。VS Code を用いる場合は以下のプラグインを推奨する。

* [YAML](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml)
* [Swagger Viewer](https://marketplace.visualstudio.com/items?itemName=Arjun.swagger-viewer)
  * Ctrl + Shift + P (Win: Shift + Alt +P ) → Preview Swagger で現在編集中の Swagger プレビューが可能
* [spectral-cli](https://docs.stoplight.io/docs/spectral/674b27b261c3c-overview)

`editorconfig` を用いる場合は、以下の定義を推奨する。

```ini .editorconfig
root = true

[*]
charset = utf-8
insert_final_newline = true
trim_trailing_whitespace = true
end_of_line = lf

[*.{json,yaml}]
indent_size = 2
indent_style = space
```

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)

---

---
url: >-
  /coding-standards/documents/forOpenAPISpecification/OpenAPI_Specification_3.0.3.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。\
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。\
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# はじめに

本ドキュメントは [OpenAPI Specification 3.0.3](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md)に則った API ドキュメントを記述する際のコーディング規約をまとめている。
旧バージョンである[OpenAPI Specification 2.0 の規約](OpenAPI_Specification_2.0.md)も存在するため、v2 を使用している場合はそちらを参照されたい。

# 前提条件

本規約は以下の前提条件に基づいて作成されており、ToC 向けの LSUDs（Large Set of Unknown Developers）向けの Web API には適合しない場合もあるのでご留意いただきたい。

* 業務システム向けの Web API 提供
  * サードパーティ向けに広く開発する Web API ではなく、限られたクライアントやシステムと連携すること
  * いわゆる、LSUDs（Large Set of Unknown Developers）ではなく、SSKDs（Small Set of Known Developers）を対象とする
* RESTish な Web API
  * 原理的な REST を必ずしも守る必要はないが、例えば HTTP メソッドは、参照は GET、登録は POST、更新は PUT や PATCH、削除は DELETE で使い分けていたり、Web API の要求が成功すれば 200（OK）、204（No Content）を返し、リソースが無ければ 404（Not Found）、操作に失敗すれば 500 系のエラーを返すといったことを指す
  * 本規約を利用するに当たり必須条件ではないが、定義例などはそれに基づいて記載しているので注意する
* スキーマファースト
  * OpenAPI Specification の定義ファイルを駆動に、クライアント・サーバサイドのコード生成やモック時の利用に用い、高速な Web API 開発につなげることを前提とする
    * Python における、FastAPI・Django REST Framework のように、アプリケーションコードから OpenAPI document を自動生成する開発手法も存在するが、本規約はこれは想定しない
  * 定義ファイルの完成度はできるかぎり高め、コード生成やドキュメントの価値を高める
    * OAS 定義からコードを生成し、通常は記載した型・項目長・最大～最小・enum・必須定義・正規表現フォーマットでバリデーションを行い、カバーできない部分のバリデーションをアプリケーション固有ロジックとして実装する方針とする。例えば、複数項目間のチェックや DB を確認しないと行えないチェックである
    * ドキュメントとしての価値を高めるため、その API 呼び出しで発生しうる全ての HTTP ステータスコードを記載する
      * API の振る舞いを読み手に伝えるものとして、どのような異常系があるかは有用な場合が多いからである
* JavaScript/TypeScript、Java、Go のエコシステムがターゲット
  * OpenAPI Specification は広く受け入れられており、コレに対応する様々なツールやフレームワークといったエコシステムがあり、中には定義された設定がうまく認識されない場合がある。本規約では対応していないツールが多い場合、特定の記法を非推奨とすることがあり、同時にその理由も説明する
  * 全ての言語・フレームワーク・ツールの対応状況は調査しきれていないため、利用するプロダクトの対応状況は利用者側で確認をお願いする

# 免責事項

::: warning 有志で作成したドキュメントである

フューチャーアーキテクトには多様なプロジェクトが存在し、それぞれの状況に合わせた開発手法が採用されている。本規約はフューチャーアーキテクトの全ての部署／プロジェクトで利用されているわけではなく、有志が観点を持ち寄って新たに整理したものである。相容れない部分があればその領域を書き換えて利用することを想定している

:::

# API設計

Web API の設計自体は、[Web API設計ガイドライン | Future Enterprise Arch Guidelines](https://future-architect.github.io/arch-guidelines/documents/forWebAPI/web_api_guidelines.html)を参考にすること。

# YAMLファイルフォーマット

OpenAPI ドキュメントは JSON 形式、YAML 形式いずれかのフォーマットで記載できるが **YAML 形式** を利用する。理由として、JSON と比較して YAML は視覚的に見やすく、レビューや差分管理が行いやすいためである。

## ファイル名

ファイルの拡張子は `yaml` とする。通常ファイル名は `openapi.yaml` を推奨する（公式ドキュメントの推奨であり、GitLab上でSwagger UIのプレビューなどの機能も利用できるため）。

もし、複数の定義を管理したい場合は `${service}_openapi.yaml` とする。

`${service}` にはサービス名を指定する

## YAML バージョン

[YAML v1.2](https://yaml.org/spec/1.2.2/#61-indentation-spaces)を用いる。

## ファイルレイアウト

* ファイルの最終行には空行を入れる
* 文字コードは UTF-8 とする
* タブは半角スペース 2 つとする

## クォート

クォートは可読性を上げるために、できる限り利用しない。利用する場合はダブルクォートを利用する。

```yaml
# OK
description: 何かしらの説明

# NG（クォートでのラップは不要）
description: '何かしらの説明'
description: "何かしらの説明"
```

以下の場合は必須で利用する

* 文字列として認識させる必要のある数字（"0123"）
* 60 進数と認識させたくない場合（"12:34"）
* Bool として認識させたくない（"true", "false", "yes", "no", "y", "n", "on", "off"）
* `#` で始まる文字列（`#` はコメントを示す記号のためである。例: `#/definitions/Users`）

## YAML 配列スタイル

* 複数項目を指定する場合は、 **Flow style(配列スキーム)** を用いることを推奨する

  ```yaml
  # OK（推奨: 配列リテラル構文）
  required: [user_id, user_name, account_type, register_at]

  # NG（非推奨: リスト構文）
  required:
    - user_id
    - user_name
    - account_type
    - register_at
  ```

  * YAML は項目定義がネストすることで縦長な定義になりやすい。情報密度を上げるために配列リテラルを推奨する

## 改行の表現

改行を含む場合は、パイプ（ブロックスカラー） `|` を用いる

```yaml
description: |
  説明文1
  説明文2
     - 箇条書き1
     - 箇条書き2
     - 箇条書き3
```

# OpenAPI ドキュメントの構成要素

OpenAPI ドキュメントを構成する要素はオブジェクトと呼ばれ、ルートオブジェクトは以下の要素で構成される。

各種規約を理解する上で、これらの要素を大まかに把握しておくことが重要である。

各オブジェクトの詳細については[公式ドキュメント](https://spec.openapis.org/oas/v3.0.3#openapi-object)を参照されたい。

| フィールド名 | 必須 | 説明                                                        |
| ------------ | :--: | ----------------------------------------------------------- |
| openapi      |  ○   | OpenAPI ドキュメントが使用する OpenAPI 仕様のバージョン番号 |
| info         |  ○   | API に関するメタデータ                                      |
| servers      |      | API サーバへの接続情報                                      |
| paths        |  ○   | API の利用可能なパスと操作方法                              |
| components   |      | 複数の API における共通の定義                               |
| security     |      | API 全体で利用可能なセキュリティ（認証）機構                |
| tags         |      | 各種 API をグルーピングするためのタグ                       |
| externalDocs |      | 追加の外部ドキュメント                                      |

続いて各構成要素ごとに具体的なコーディング規約を記載していく。

# openapi

OpenAPI ドキュメントが使用する OpenAPI 仕様のセマンティックバージョン番号を記載する。

本規約はバージョン`3.0.3`を対象としているため、`3.0.3`とする。

良い例：

```yaml
openapi: 3.0.3
```

悪い例：

```yaml
openapi: 3.0
```

# info

`info`オブジェクトには Web API に関するメタデータを記載する。

`title`, `description`, `version` を必須項目とする。

| フィールド名   | 必須 | 記載内容                         |
| -------------- | :--: | -------------------------------- |
| title          |  ○   | Web API の総称                   |
| description    |  ○   | Web API の簡単な説明             |
| version        |  ○   | OpenAPI ドキュメントのバージョン |
| termsOfService |      | 利用規約の URL                   |
| contact        |      | 連絡先情報                       |
| license        |      | ライセンス情報                   |

## info > title

Web API の総称を記載する。

システム名やサービス名 + API のような命名を推奨する。

良い例：

```yaml
info:
  title: X System API
```

## info > description

Web API が提供する機能の概要・想定する利用者やユースケース・制約などを記載する。

## info > version

この API 仕様のドキュメントのバージョンを記載する。

アプリケーションのバージョン（git tag やリリースで管理するようなバージョン）とは別である。

* `major.minor` 形式を推奨する

  * `0.1` 固定で開発を進め、サービスのリリース時に `1.0` とし、その後の項目やオプション、パスの追加ごとにマイナーバージョンをインクリメントしていく

  良い例：

  ```yaml
  info:
    version: 1.0
  ```

* 他チームへの API ドキュメントの頻繁な共有が必要な場合は `YYYY.MM.DD` の日付形式も許容する

  良い例：

  ```yaml
  info:
    version: 2023.03.26
  ```

# servers

Web API を提供するサーバの情報を記載する。

* `url`, `description` を必須項目とする
* ステージ（local, develop, staging など）が複数ある場合は各ステージ分の情報を記載する。
* SSKDs 向けの Web API 開発においては本番環境の URL を不用意に公開したくないケースが多く、記載は避けるべきである

良い例：

```yaml
servers:
  - url: http://localhost:8001/
    description: Localhost Server
  - url: https://dev.api.example.com/v1
    description: Development Server
  - url: https://staging.api.example.com/v1
    description: Staging Server
```

悪い例：

```yaml
servers:
  - url: https://prod.api.example.com/v1
    description: Production Server
```

# paths

API の利用可能なエンドポイントと操作方法を記載する。

* API ごとに機能 ID を定義している場合、`paths` 配下の各パスは機能 ID の昇順に定義する

  良い例：

  ```yaml
  paths:
    /users:
      get:
        summary: API-101 ユーザ一覧取得
    /products:
      get:
        summary: API-201 商品一覧取得
  ```

  悪い例：

  ```yaml
  paths:
    /products:
      get:
        summary: API-201 商品一覧取得
    /users:
      get:
        summary: API-101 ユーザ一覧取得
  ```

* URL パスが複数の単語からなる場合、ケバブケースで表現する

  良い例：

  ```yaml
  paths:
    /product-owners:
      get: ...
  ```

  悪い例：

  ```yaml
  paths:
    /productOwners:
      get: ...
  ```

* HTTP メソッドは `GET`, `POST`, `PUT`, `PATCH`, `DELETE` の順に定義する

  良い例：

  ```yaml
  paths:
    /products:
      get: ...
      post: ...
  ```

  悪い例：

  ```yaml
  paths:
    /products:
      post: ...
      get: ...
  ```

* HTTP メソッドの配下に定義されるオペレーションオブジェクトは、下記の項目を必須項目とする

| フィールド名 | 必須 | 記載内容                                 |
| ------------ | :--: | ---------------------------------------- |
| tags         |  ○   | API の論理的なグループ                   |
| summary      |  ○   | API の操作概要                           |
| description  |  ○   | API の振る舞いの詳細や注意点             |
| externalDocs |      | API に関する追加の文書                   |
| operationId  |  ○   | API の利用可能なエンドポイントと操作方法 |
| parameters   |      | API のリクエストパラメータ               |
| requestBody  |      | API のリクエストボディ                   |
| responses    |  ○   | API のレスポンス                         |
| callbacks    |      |                                          |
| deprecated   |      | API が非推奨であることの宣言             |
| security     |      | API のセキュリティ機構                   |
| servers      |      | API に対応する代替サーバ                 |

## paths > {path} > {method} > tags

API の論理的なグループを指定する。

* タグオブジェクトとして事前定義したタグの中から選択する

  良い例：

  ```yaml
  paths:
    /users:
      get:
        tags:
          - users
        ...
  tags:
    - name: users
  ```

  悪い例：

  ```yaml
  paths:
    /users:
      get:
        tags:
          # タグオブジェクトとして定義されていないタグが指定されている
          - users
        ...
  tags: []
  ```

* 1 API につき 1つのタグを指定する

  良い例：

  ```yaml
  paths:
    /users:
      get:
        tags:
          - users
        ...
  ```

  悪い例：

  ```yaml
  paths:
    /users:
      get:
        # 複数のタグが指定されている
        tags:
          - users
          - admin
        ...
  ```

## paths > {path} > {method} > summary

API の操作概要を記載する。

* API ごとに機能 ID や機能名があるのであれば記載する

  良い例：

  ```yaml
  paths:
    /users:
      get:
        summary: API-001 ユーザ一覧取得
  ```

## paths > {path} > {method} > description

API の振る舞いの詳細や注意点を記載する。

別途参照させるべき設計書があるのであれば、設計書へのリンクを記載しても良い。

良い例：

```yaml
paths:
  /users:
    get:
      description: [API詳細設計書（API-001）](https://example.com/API-001.md)
```

## paths > {path} > {method} > operationId

API を識別するための一意な文字列を記載する。

* HTTP メソッドと URL パスの組み合わせをキャメルケースで表現する

  * キャメルケースの書式は、[OpenAPI 3.0ガイドのPaths and Operations](https://swagger.io/docs/specification/paths-and-operations/#:~:text=role%3Dvalue-,operationId,-operationId%20is%20an)でも利用されているため、一般的である

  良い例：

  ```yaml
  paths:
    /users:
      get:
        operationId: getUsers
        ...
    /products/{product_id}:
      put:
        operationId: putProductsProductId
        ...
  ```

  悪い例：

  ```yaml
  paths:
    /users:
      get:
        operationId: get_users
        ...
  ```

* OpenAPI ドキュメントエディタとして広く使用される Stoplight が提供する[Linter](https://docs.stoplight.io/docs/spectral/674b27b261c3c-overview)の定義としては、ケバブケースが標準になっているため、Stoplight を使用する場合はケバブケースで表現しても良い

## paths > {path} > {method} > parameters

API のリクエストパラメータを記載する。

* クエリパラメータはスネークケースで表現する

  良い例：

  ```yaml
  paths:
    /users:
      get:
        ...
        parameters:
          - name: account_type
            in: query
  ```

  悪い例：

  ```yaml
  paths:
    /users:
      get:
        ...
        parameters:
          - name: account-type
            in: query
  ```

* クエリパラメータは HTTP メソッドが `GET`, `DELETE` の場合にのみ指定する

  良い例：

  ```yaml
  paths:
    /users:
      get:
        ...
        parameters:
          - name: account_type
            in: query
  ```

  悪い例：

  ```yaml
  paths:
    /users:
      post:
        ...
        parameters:
          - name: acaccount_type
            in: query
  ```

* ヘッダはハイフンを区切り文字とするパスカルケースで表現する

  良い例：

  ```yaml
  paths:
    /users:
      post:
        ...
        parameters:
          - name: Content-Type
            in: header
  ```

  悪い例：

  ```yaml
  paths:
    /users:
      post:
        ...
        parameters:
          - name: ContentType
            in: header
  ```

## paths > {path} > {method} > requestBody

API のリクエストボディを記載する。

* 標準仕様の [describing-request-body](https://swagger.io/docs/specification/describing-request-body/) の章にも記載がある通り、リクエストボディは HTTP メソッドが `POST`, `PUT`, `PATCH` の場合のみ指定する

  良い例：

  ```yaml
  paths:
    /users:
      post:
        ...
        requestBody:
          required: true
          content:
            application/json:
              ...
  ```

  悪い例：

  ```yaml
  paths:
    /users:
      get:
        ...
        # HTTP メソッドが GET の場合にリクエストボディを指定
        requestBody:
          ...
  ```

* リクエストボディそのものは通常複数の API を跨いで再利用されるものではないため、原則 `components` オブジェクトとして共通化（コンポーネント化）を行わない

  * [openapi-generator](https://github.com/OpenAPITools/openapi-generator)を使用する場合は、コンポーネント化をせず、`title` を指定することで名称の指定が可能となる
  * [oapi-codegen](https://github.com/oapi-codegen/oapi-codegen)を使用する場合は、名称を指定するためにコンポーネント化が必要となるが、極力コンポーネント化せずデフォルトの名称を使用することを推奨する

  良い例：

  ```yaml
  paths:
    /users:
      post:
        ...
        requestBody:
          required: true
          content:
            application/json:
              ...
  ```

  悪い例：

  ```yaml
  paths:
    /users:
      get:
        ...
        requestBody:
          # コンポーネント化したリクエストボディを参照
          $ref: '#/components/requestBodies/ReqPostProductsBody'

  components:
    requestBodies:
      ReqPostProductsBody:
        content:
          application/json:
  ```

## paths > {path} > {method} > responses

API のレスポンスを記載する。

* 正常系（`2xx`）のレスポンスは通常複数の API を跨いで再利用されるものではないため、原則 `components` オブジェクトとして共通化（コンポーネント化）を行わない

  * [openapi-generator](https://github.com/OpenAPITools/openapi-generator)を使用する場合は、コンポーネント化をせず、`title` を指定することで名称の指定が可能となる
  * [oapi-codegen](https://github.com/oapi-codegen/oapi-codegen)を使用する場合は、レスポンスの構造体を出力するために `strict-server` オプションを `true` に指定する必要がある。名称を指定するためにコンポーネント化が必要となるが、極力コンポーネント化せずデフォルトの名称を使用することを推奨する

  良い例：

  ```yaml
  paths:
    /products:
      post:
        responses:
          "200":
            description: 200 OK
            content:
              application/json: ...
  ```

  悪い例：

  ```yaml
  paths:
    /products:
      post:
        responses:
          "200":
            # コンポーネント化したレスポンスオブジェクトを参照
            $ref: "#/components/responses/RespPostProductsBody"

  components:
    responses:
      RespPostProductsBody:
        description: 200 OK
        content:
          application/json: ...
  ```

* 異常系（`4xx`, `5xx`）のレスポンスは個別に定義するのではなく、事前に `components` オブジェクトとして定義を行い `$ref` で参照する

  良い例：

  ```yaml
  paths:
    /products:
      post:
        responses:
          "400":
            # コンポーネント化したレスポンスオブジェクトを参照
            $ref: "#/components/responses/BadRequest"

  components:
    responses:
      BadRequest:
        description: 400 Bad Request
        content:
          application/json: ...
  ```

  悪い例：

  ```yaml
  paths:
    /products:
      post:
        responses:
          "400":
            # レスポンスオブジェクトを個別に定義
            description: 400 Bad Request
            content:
              application/json: ...
  ```

## paths > {path} > {method} > security

API の認証方式を記載する。

* 通常はルートレベルの `security` で API 共通的な認証方式を設定し、個々の API で個別に設定は行わない
* ヘルスチェックのような認証を通す必要がない API のみ、上書きで定義する

  良い例：

  ```yaml
  paths:
    /session:
      post:
        ...
        # 認証しない場合のみ個別で定義
        security: []
  ```

# components

API 定義で利用する共通のデータモデルを定義する。定義方針は下記の通りである。

| フィールド名    | 方針                                                                                   |
| --------------- | -------------------------------------------------------------------------------------- |
| schemas         | API 共通的なリソース（例. ユーザや商品など）やエラー等のドメインオブジェクトを定義する |
| responses       | API 共通的なレスポンス（例. 異常系（`4xx`, `5xx`）のレスポンス）を定義する             |
| parameters      | API 共通的なリクエストパラメータ（HTTP ヘッダやクエリパラメータ等）を定義する          |
| examples        | 原則何も定義しない                                                                     |
| requestBodies   | 原則何も定義せず、リクエストボディは API 個別に定義する                                |
| headers         | API 共通的なレスポンスヘッダを定義する                                                 |
| securitySchemes | 標準で用いる API 認証のスキームを定義する                                              |
| links           | 原則何も定義しない                                                                     |
| callbacks       | 原則何も定義しない                                                                     |

※ リクエストボディやレスポンスボディにおいてオブジェクトがネストする場合、 API 固有のオブジェクトであっても `schemas` に定義する。
これは、定義するオブジェクトの `properties` 配下に更に `type: object` が定義される場合に、生成ツールによってはうまく型が生成されないためである。
生成ツール上問題ないのであれば、API 固有のオブジェクトを `schemas` に定義する必要はない。

## components　> schemas

API 共通的なリソースやエラー等のドメインオブジェクトを記載する。

* 名称はアッパーキャメルケースで定義する
* 名称は単数形で定義する
* `type` に複数の型を定義しない
* `type` に `null` は原則指定しない（`null` 値を用いる代わりに、キー自体を含めない）。空更新を行う場合は空文字を利用する
* `allOf`, `anyOf`, `oneOf` は利用しない

良い例：

```yaml
components:
  schemas:
    # 共通で使用するリソースを表すオブジェクト
    Product:
      type: object
      properties: ...
    User:
      type: object
      properties:
    # 共通で使用するエラーを表すオブジェクト
    ProblemDetailError:
      type: object
      properties: ...
```

## components > responses

API 共通的なレスポンスを記載する。主に異常系（`4xx`, `5xx`）のレスポンスを定義する。

* 名称はアッパーキャメルケースで定義する
* 異常系（`4xx`, `5xx`）のレスポンスの場合、名称にステータスコードの名称（例. BadRequest, Unauthorized）を用いる

良い例：

```yaml
components:
  schemas:
    ProblemDetailError:
      type: object
      properties:
        ...
  responses:
    # HTTP ステータスコード 400 のレスポンスオブジェクト
    BadRequest:
      description: 400 Bad Request
      content:
        application/json:
          schema:
            "$ref": "#/components/schemas/ProblemDetailError"
    # HTTP ステータスコード 401 のレスポンスオブジェクト
    Unauthorized:
      description: 401 Unauthorized
      content:
        application/json:
          schema:
            "$ref": "#/components/schemas/ProblemDetailError"
    ...
```

正常系のレスポンスの例としてはファイルアップロード・ダウンロードのレスポンスなどが該当する。\
個別のアプリケーション要件でブレが少なく、複数のエンドポイントで用いられる場合に定義する。オブジェクトのスキーマは、`schemas` に切り出して定義し、コード生成ツールのために型情報を付与させる。

良い例：

```yaml
components:
  schemas:
    SignedURL:
      type: object
      properties:
        signed_url:
          type: string
          format: uri
        expired_at:
          type: string
          format: date-time
  responses:
    BlobUpload:
      description: BLOB(Binary Large Object) upload using presigned url
      content:
        application/json:
          schema:
            "$ref": "#/components/schemas/SignedURL"
    BlobDownload:
      description: BLOB(Binary Large Object) download using presigned url
      content:
        application/json:
          schema:
            "$ref": "#/components/schemas/SignedURL"
    ImageBinary:
      description: An image
      content:
        image/*:
          schema:
            type: string
            format: binary
```

## components > parameters

API 共通的なリクエストパラメータ（パスパラメータ、クエリパラメータ、ヘッダ, Cookie）を記載する。

### パスパラメータ

* API 全体で利用されるパスパラメータが必要なケースが想定されないため、原則定義しない
  * 特定リソースの操作（例えば更新と削除）を行う際のリソース ID はパスパラメータとして再利用できるが、コンフリクトを避けるため原則共通化は行わない

### クエリパラメータ

* API 全体で利用可能な共通のクエリパラメータ（例: 検索数の limit, offset）を定義する
* 命名はクエリパラメータ名に `Query` というプレフィックスを付与する形式を推奨する

良い例：

```yaml
paths:
  get:
    /products:
      parameters:
        - $ref: "#/components/parameters/QueryLimit"

components:
  parameters:
    QueryLimit:
      name: limit
      in: query
      required: false
      schema:
        type: integer
      description: 検索数上限
```

### ヘッダ

* API 全体で利用可能な共通のリクエストヘッダを定義する
* 命名はヘッダ名に `Header` というプレフィックスを付与する形式を推奨する

良い例：

```yaml
paths:
  post:
    /products:
      parameters:
        - $ref: "#/components/parameters/HeaderContentType"

components:
  parameters:
    HeaderContentType:
      name: Content-Type
      in: header
      schema:
        type: string
      required: true
```

### Cookie

* API 全体で利用可能な共通の Cookie（例: CSRF 用のトークン）を定義する
* 命名は Cookie 名に `Cookie` というプレフィックスを付与する形式を推奨する
* Cookie 認証を定義する場合は、`APIKey` を利用する

良い例：

```yaml
paths:
  get:
    /products:
      parameters:
        - $ref: "#/components/parameters/CookieCSRFToken"

components:
  parameters:
    CookieCSRFToken:
      name: csrftoken
      in: cookie
      required: true
      schema:
        type: string
      description: CSRFトークン
```

## components > requestBodies

原則何も定義せず、リクエストボディは API 個別に記載する。

## components > headers

API 共通的なレスポンスヘッダを記載する。

* 命名はヘッダ名からハイフンを除去した形式を推奨する

良い例：

```yaml
paths:
  get:
    /products:
      responses:
        "200":
          headers:
            XCacheInfo:
              $ref: "#/components/headers/XCacheInfo"

components:
  headers:
    XCacheInfo:
      description: not cacheable; meta data too large
      schema:
        type: string
```

## components > securitySchemes

標準で用いる API 認証の定義を行う。

良い例：

```yaml
components:
  securitySchemes:
    # Bearer トークンによる認証
    Bearer:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: "Bearer トークン認証"
```

## components > links

[links](https://swagger.io/docs/specification/links/) は OpenAPI 3.0 の新機能の1つで、ある API レスポンスの値を用いて、別の API を呼び出す方法を明示できるセクションである。

興味深い機能であり、API のセマンティクスを伝えるのに有用であるが、本規約では記載しないことを推奨とする。

理由:

* 業務システムでは、業務フローを抑えておけば、API 操作フローの理解はそこまで難しくないことが多い
  * 逆に、API 同士の関係だけを示すだけでは業務モデリング図とのダブルメンテナンスになったり、中途半端になりうる
* [OAS 3.0 Support Backlog](https://github.com/swagger-api/swagger-ui/issues/3641) にあるように、2023/12/15時点では Swagger-UI が対応していない
  * links を書いたと言って、API ドキュメントに影響しない

## components > callbacks

[callbacks](https://swagger.io/docs/specification/callbacks/) は OpenAPI 3.0 の新機能の1つで、API サーバ側が指定されたコールバック URL を呼び出すという仕組みである。

仕様書には、EC ショップで購入のたびにマネージャーに通知を送るといった、何かしらの処理をトリガーにコールバック URL を呼び出す例が示されている。

利便性は高い仕様だが、本規約では記載しないことを推奨とする。

理由:

* コールバック URL 呼び出しの、エラーハンドリングが難しい
* 業務システムでは欠損が許されない、または将来的に許されなくなる可能性があり、その場合にこの機能に頼ると想定以上の追加作業が発生する

コールバックのような仕組みを実現するには、別途キューイングのメッセージサービスの利用などを検討する。

# security

全 API に共通で適用されるセキュリティ設定を定義する。

業務システムの Web API において認証が全く存在しないケースは考えにくいため、本規約ではルートレベルで認証を設定し、個々の API への適応漏れを無くす。

良い例：

```yaml
security:
  - Bearer: []
```

# tags

API を論理的にグループ化するためのタグを定義する。

* ドキュメントやツールにとって重要であるため **必須** で指定する
* `name`, `description` を必須項目とする
* **単数形** で、小文字かつ半角スペース区切りで記載する
  * 半角スペース区切りで記載する理由は HTML ドキュメントで参照する場合の可読性を上げるため
* コード生成で利用される（Go においてはパッケージ、 TypeScript においてはクラスに相当する）ため、シンプルな命名にする

良い例：

```yaml
tags:
  - name: product
    description: 製品
  - name: user account
    description: ユーザーアカウント
```

悪い例：

```yaml
tags:
  - name: products
    description: 製品
  - name: user_account
    description: ユーザーアカウント
```

# externalDocs

参照情報としての URL を記載できる。

ただし、`description` にて参考情報となる URL を記載する方が、複数リンクを指定可能であるなど自由度が高く使いやすいため `externalDocs` は利用せず `description` の利用を推奨する。

良い例：

```yaml
info:
  description: |-
    Some useful links:
    - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)
    - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)

# 特別な場合を除き非推奨
externalDocs:
  description: Find out more about Swagger
  url: http://swagger.io
```

# ファイル操作

OpenAPI ドキュメントを作成する上でのファイルのアップロード／ダウンロードについて設計上ポイントを記載する。

## ファイルアップロード

[Web API設計ガイドライン>ファイル連携>ファイルアップロード](https://future-architect.github.io/arch-guidelines/documents/forWebAPI/web_api_guidelines.html#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%A2%E3%83%83%E3%83%95%E3%82%9A%E3%83%AD%E3%83%BC%E3%83%88%E3%82%99) で推奨された「署名付きURL」を用いた手法を採用する場合、次のようなフローとする。

```mermaid
sequenceDiagram
participant A as クライアント
participant B as Web APIサーバ
participant C as オブジェクトストレージ

A->>B: ①アップロード先URL取得
  B->>C: Signed URL発行
  C-->>B: Signed URL
  B-->>A: アップロードURL、受付ID（加えて、アップロードで指定したいHTTP Methodや必要なリクエストヘッダがあれば応答の項目に追加する）

A->>C: ②ファイルアップロード

A->>B: ③ファイルアップロード完了(受付ID、キー、属性)
  B-->>A: 受付完了
```

フローの ①、② はアプリケーション固有の紐づけルールにおいて Web API を設計すれば良いため、本規約で YAML の設定例は記載しない。フロー ② については Signed URL を用いたアップロードであり、アプリケーションの Web API 定義を書く必要はない。もし、監査ログなどのガバナンス上、直接オブジェクトストレージへの書き込みを許容されないケースは、B で Signed URL に相当する書き込み先を提供し、B を経由してファイルをアップロードする。

上記どちらのケースも OpenAPI 定義としてはシンプルであるため、記述例は割愛する。

## ファイルダウンロード

[Web API設計ガイドライン>ファイル連携>ファイルダウンロード](https://future-architect.github.io/arch-guidelines/documents/forWebAPI/web_api_guidelines.html#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%BF%E3%82%99%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%88%E3%82%99) で推奨された方法は、Signed URL をレスポンスの JSON 項目に渡すか、ファイル容量がごく小さい場合に限り Base64 にエンコードして JSON に埋め込んで渡すかの2つである。

どちらのケースも OpenAPI 定義としてはシンプルであるため、記述例は割愛する。

# CORS

CORS（Cross-Origin Resource Sharing）のために、options メソッドの追記は **原則不要** とする。

理由:

* サーバ側
  * options メソッド対応は、API 仕様ではなく実装レベルの機能横断的な処理（Java における Servlet Filter や Spring の Interceptor、Go における Middleware など）で行うことが大半であり、コード生成が不要
* クライアント側
  * options メソッドを用いるのはクライアントがブラウザであり、クライアントのアプリケーションコードが明示的にアクセスしないため、コード生成が不要
* 仕様面として
  * `Access-Control-Allow-Origin` がどのような値を返すか、呼び出し元によって動的な値を返したい場合があり、記載が困難なケースがある

ただし、Amazon API Gateway のようなサービスを利用する場合は、options メソッドの記載が必須である場合は除く[^1]。

[^1]: https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/enable-cors-for-resource-using-swagger-importer-tool.html

# OpenTelemetry Traceparent HTTP Header

OpenOpenTelemetry で用いるられる[traceparent](https://www.w3.org/TR/trace-context/) のリクエストヘッダは OpenAPI で **原則不要** とする。

理由:

* OpenTelemetry が定めるヘッダ類は、API 横断的に設定されるべきものであり、ミドルウェアやフレームワーク側などでの一律の制御を推奨するため
* 記載することにより、OpenOpenTelemetry に対応していることを明記し開発者に周知できるメリットより、各アプリ開発者が生成されたコードで悩んだり、誤解されることを回避したいため

# バリデーション

パラメータのバリデーションをどこまで厳密に定義すべきかという議論はしばしば行われる。

リクエストパラメータの各項目に対して、必須・型・桁・区分値・日付・正規表現のチェックが行える。レスポンスで用いるモデルについても同様に設定でき、`enum`, `pattern` 以外は API の利用者（クライアント）側の DB 設計などに必要な型桁情報を渡すのに有用であるため、できる限り詳しく指定する。

## 必須

必須パラメータのみ `required: true` を定義する

## デフォルト値

パラメータにデフォルト値がある場合は`default` を定義する。

```yaml
# ex. enum
name: limit
type: number
format: integer
minimum: 1
maximum: 100
default: 20
description: 検索結果の項目数上限（1~100が指定可能）
```

【注意】API 公開後に、default 値を変更してはならない（API の互換性が崩れるため）。もし変更する場合は、API のバージョンを上げること。

## 型・フォーマット

型（`type`）は `string(文字列)`, `number（数値）`, `integer（整数値）`, `boolean（真偽値）` `array（配列）` のうちどれか指定する。

フォーマット（`format`）は以下の型の詳細情報を示すもので、可能な限り設定する。

* `integer`（整数）
  * `int32`, `int64`
* `number`（数値）
  * `float`, `double`
* `string`（バイナリ）
  * `byte`: Base64 でエンコードされた文字列
  * `binary`: バイト配列
* `string`（日付）
  * `date`: [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) full-date(例: 2023-07-21)
    * 項目名は `_on` を接尾辞につけることを推奨とする
  * `date-time`: [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) date-time(例: 2023-07-21T17:32:28Z)
    * 項目名は `_at` を接尾辞につけることを推奨とする
* `string`（その他）
  * `password`: Swagger UI で入力が隠される
  * その他、 `email`, `uuid` など Open API 仕様に存在しない任意のフォーマットを独自のドキュメント生成などのために記載しても良い

OpenAPI 3.0 では 2.0 に存在した `file` type は存在しない。もし同等の指定をしたい場合は、以下の様に指定する。

```yaml
type: string
format: binary # binary file contents
```

## 桁

データ型によって、利用できる桁を指定する項目が異なる。可能な限り設定する。

* 文字列
  * 最大桁数：`maxLength`
  * 最小桁数：`minLength`
* 数値または整数値
  * 最小値（境界値を含む）：`minimum`
  * 最大値（境界値を含む）：`maximum`
  * 境界値を含まない場合のみ`exclusiveMinimum: true`または`exclusiveMaximum: true`を定義する。minimum, maximum で代用できる場合は利用しない
* 配列:
  * 最大要素数：`maxItems`
  * 最小要素数：`minItems`
  * `required: true`の場合は原則として`minItems: 1`を定義する
  * `uniqueItems` は必須で指定する（通常は一意であるべき）

【注意】API 公開後に、レスポンスの `maxLength` を以前より大きい値に変更してはならない。レスポンスの `maxLength` など API 利用者側システムの DB の ERD 定義のインプットになる事が多いため。もし行う場合は API のバージョンを上げることや、連携先に桁数変更の旨を調整するなどの考慮を行う。

## 区分値

区分値の場合は `enum` 属性を利用し、`description`には区分値の論理名を記載する。

```yaml
name: gender
type: string
enum: ["0", "1", "2", "9"]
description: |
  性別
    0: 不明
    1: 男
    2: 女
    9: 適用不能
```

OpenAPI 3.0 では区分値の再利用ができるため、横断的に用いる区分値は components 側で定義する。

```yaml
paths:
  /products:
    get:
      parameters:
        - in: query
          name: gender
          required: true
          schema:
            $ref: "#/components/schemas/Gender"
components:
  schemas:
    Gender:
      type: string
      enum: ["0", "1", "2", "9"]
```

## 固定値

**固定値** の場合も enum を 1 つだけ指定して表現する。この場合もレスポンスで利用する場合は指定しない

```yaml
name: file_layout
type: string
enum: ["json"]
description: ファイルレイアウト
```

## その他（正規表現）

正規表現で表現できる文字列は`pattern`を利用して定義する。桁や区分値で代替できる場合は、`pattern` を用いない

例:

```yaml
remind_time:
  type: string
  description: リマインド時刻。（hh:mm）形式
  example: 23:59
  pattern: "^(2[0-3]|[01][0-9]):([0-5][0-9])$"
```

# ファイル分割

OpenAPI ドキュメントは単一のファイルで構成することも複数の分割されたファイルで構成することもできるが、**複数のファイルに分割する**ことを推奨する。

理由:

* API path ごとに担当者を分けて設計する場合などに、複数人による編集によって意図しないコンフリクトが発生することを防ぐ
* ファイルの肥大化による、可読性の低下を防ぐ

## 分割方法の選定

開発方針や OpenAPI の使用用途に合わせて、都合の良いファイルの分割方法を採用する。例えば、以下のような方法がある。

1. API path ごとに設計担当者を分けて、それぞれに OpenAPI を編集する場合は、path の単位で分割する。
2. テストツールとして [stoplightio/prism](https://github.com/stoplightio/prism)を使用する場合、テストケースごとにデータファイルを作成して、`examples` にファイルパスを指定する。

注意点:

* OpenAPI 仕様上、`$ref` は[利用できる箇所が限定されている](https://swagger.io/docs/specification/using-ref/#allowed-places)ことに注意する
  * 例えば[Path](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#path-item-object)は `$ref` が利用可能だが、[Operation](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#operation-object)（HTTPメソッドの粒度）では利用不可である

## サンプル説明

分割方法 1, 2 の両方に当てはまる場合のサンプルを用いて説明する。`openapi.yaml` とディレクトリ構成は下の通り。全量は [sample\_divided](https://github.com/future-architect/coding-standards/tree/master/documents/forOpenAPISpecification/sample_divided)を参照すること。

* リソース単位にディレクトリを作成して、path ごとに定義ファイルを格納する。

* `components` の schemas モデルの中身は別ファイルとして切り出すことが可能である。

  ```yaml
  # openapi.yaml（ファイル分割例）
  openapi: "3.0.3"
  info:
    version: 1.0.0
    title: Swagger Petstore
  security:
    - Bearer: []
  servers:
    - url: http://petstore.swagger.io/v1
  tags:
    - name: pets
      description: Everything about your Pets
  paths:
    /pets:
      $ref: "./pets/pets.yaml"
    /pets/{pet_id}:
      $ref: "./pets/pets_pet_id.yaml"

  components:
    securitySchemes:
      Bearer:
        type: http
        scheme: bearer
        bearerFormat: JWT
        description: "Authenthicaiton with bearer token"
  ```

  ```sh
  # ディレクトリ構成（ファイル分割例）

  ├─openapi.gen.yaml
  ├─openapi.yaml
  │
  ├─examples
  │  ├─pets_get
  │  │    ├─test_case_001.yaml
  │  │    └─test_case_002.yaml
  │  │
  │  ├─pets_pet_id_get
  │  │    └─test_case_003.yaml
  │  │
  │  └─pets_post
  │       └─test_case_004.yaml
  │
  └─pets
    ├─pets.yaml
    └─pets_pet_id.yaml
  ```

* `openapi.yaml` の `paths` に記載した API ファイルは以下のように作成する（例: pets-pet-id.yaml）。

* `examples` には、例えば各 API のテストケース ID をキーとして指定（`TestCase003`）し、該当するテストケースのデータファイルパスを参照させる。

  ```yaml
  # pets-pet-id.yaml（API path 別ファイルの記載例）
  get:
    summary: Get details of a pet
    description: Get details of a pet by specifying its pet ID.
    operationId: getPetsPetId
    tags:
      - pets
    parameters:
      - name: pet_id
        in: path
        description: The id of the pet to retrieve
        schema:
          type: string
        required: true
    responses:
      "200":
        description: Expected response to a valid request
        content:
          application/json:
            schema:
              type: object
              properties:
                pet_detail:
                  type: object
                  properties:
                    breeder:
                      type: string
                    date_of_birth:
                      type: string
                      format: date
                    pedigree:
                      type: object
                      properties:
                        registration_no:
                          type: integer
                          format: int64
                        date_of_registration:
                          type: string
                          format: date
                        pedigree_image:
                          type: string
                      required:
                        - registration_no
                        - date_of_registration
                        - pedigree_image
              required:
                - pet_detail
            examples:
              TestCase003:
                $ref: "../examples/pets_pet_id_get/test_case_003.yaml"
      "404":
        $ref: "../common/responses.yaml#/components/responses/NotFound"
      "500":
        $ref: "../common/responses.yaml#/components/responses/InternalServerError"
  ```

* OpenAPI の使用用途により、分割ファイルを1つのファイルにまとめる必要がある場合には、例えば[Redocly CLI](https://redocly.com/redocly-cli)を使用して以下コマンドを実行する

* まとめたファイルは、以下のようになる（例: openapi.gen.yaml）。

  ```bash
  redocly bundle openapi.yaml --output openapi.gen.yaml
  ```

  ```yaml
  # openapi.gen.yaml（ファイルBundle後）
  openapi: 3.0.3
  info:
    version: 1.0.0
    title: Swagger Petstore
  servers:
    - url: http://petstore.swagger.io/v1
  security:
    - Bearer: []
  tags:
    - name: pets
      description: Everything about your Pets
  paths:
    /pets:
      get:
        summary: Search a pet list
        description: Search a list of registered pets up to 100.
        operationId: getPets
        tags:
          - pets
        parameters:
          - name: limit
            in: query
            description: How many items to return at one time (max 100)
            schema:
              type: integer
              maximum: 100
              format: int32
            required: false
        responses:
          "200":
            description: A paged array of pets
            headers:
              x-next:
                description: A link to the next page of responses
                schema:
                  type: string
            content:
              application/json:
                schema:
                  type: object
                  properties:
                    pets:
                      type: array
                      maxItems: 100
                      items:
                        type: object
                        properties:
                          id:
                            type: integer
                            format: int64
                          name:
                            type: string
                            maxLength: 50
                          category:
                            type: string
                            maxLength: 10
                          sub_category:
                            type: string
                            maxLength: 50
                          age:
                            type: integer
                            format: int32
                          sex:
                            type: string
                            maxLength: 6
                          note:
                            type: string
                            maxLength: 200
                          tag:
                            type: string
                            maxLength: 20
                        required:
                          - id
                          - name
                          - category
                          - age
                          - sex
                examples:
                  TestCase001:
                    $ref: "#/components/examples/test_case_001"
                  TestCase002:
                    $ref: "#/components/examples/test_case_002"
          "404":
            $ref: "#/components/responses/NotFound"
          "500":
            $ref: "#/components/responses/InternalServerError"
      post:
        summary: Register a pet
        description: Reginster basic information of new pet.
        operationId: postPets
        tags:
          - pets
        requestBody:
          content:
            application/json:
              schema:
                type: object
                properties:
                  pet:
                    type: object
                    properties:
                      id:
                        type: integer
                        format: int64
                      name:
                        type: string
                        maxLength: 50
                      category:
                        type: string
                        maxLength: 10
                      sub_category:
                        type: string
                        maxLength: 50
                      age:
                        type: integer
                        format: int32
                      sex:
                        type: string
                        maxLength: 6
                      note:
                        type: string
                        maxLength: 200
                      tag:
                        type: string
                        maxLength: 20
                    required:
                      - id
                      - name
                      - category
                      - age
                      - sex
                required:
                  - pet
              examples:
                TestCase004:
                  $ref: "#/components/examples/test_case_004"
          required: true
        responses:
          "200":
            description: OK
            content:
              application/json:
                schema:
                  type: object
                  properties:
                    id:
                      type: integer
                      format: int64
                    name:
                      type: string
                      maxLength: 50
                    category:
                      type: string
                      maxLength: 10
                    sub_category:
                      type: string
                      maxLength: 50
                    age:
                      type: integer
                      format: int32
                    sex:
                      type: string
                      maxLength: 6
                    note:
                      type: string
                      maxLength: 200
                    tag:
                      type: string
                      maxLength: 20
                  required:
                    - id
                    - name
                    - category
                    - age
                    - sex
          "404":
            $ref: "#/components/responses/NotFound"
          "500":
            $ref: "#/components/responses/InternalServerError"
    /pets/{pet_id}:
      get:
        summary: Get details of a pet
        description: Get details of a pet by specifying its pet ID.
        operationId: getPetsPetId
        tags:
          - pets
        parameters:
          - name: pet_id
            in: path
            description: The id of the pet to retrieve
            schema:
              type: string
            required: true
        responses:
          "200":
            description: Expected response to a valid request
            content:
              application/json:
                schema:
                  type: object
                  properties:
                    pet_detail:
                      type: object
                      properties:
                        breeder:
                          type: string
                        date_of_birth:
                          type: string
                          format: date
                        pedigree:
                          type: object
                          properties:
                            registration_no:
                              type: integer
                              format: int64
                            date_of_registration:
                              type: string
                              format: date
                            pedigree_image:
                              type: string
                          required:
                            - registration_no
                            - date_of_registration
                            - pedigree_image
                  required:
                    - pet_detail
                examples:
                  TestCase003:
                    $ref: "#/components/examples/test_case_003"
          "404":
            $ref: "#/components/responses/NotFound"
          "500":
            $ref: "#/components/responses/InternalServerError"
  components:
    securitySchemes:
      Bearer:
        type: http
        scheme: bearer
        bearerFormat: JWT
        description: Authenthicaiton with bearer token
    examples:
      test_case_001:
        value:
          pets:
            - id: 10001
              name: ToyPoodle
              category: dog
              sub_category: ToyPoodle
              age: 1
              sex: male
              note: friendly
              tag: dog10001
            - id: 10002
              name: Chihuahua
              category: dog
              sub_category: Chihuahua
              age: 1
              sex: female
              note: friendly
              tag: dog10002
            - id: 10003
              name: Shiba
              category: dog
              sub_category: Shiba
              age: 1
              sex: male
              note: friendly
              tag: dog10003
            - id: 10004
              name: MiniatureDachshund
              category: dog
              sub_category: MiniatureDachshund
              age: 1
              sex: female
              note: friendly
              tag: dog10004
      test_case_002:
        value:
          pets: []
      test_case_004:
        value:
          pet:
            id: 10005
            name: FrenchBulldog
            category: dog
            sub_category: FrenchBulldog
            age: 1
            sex: male
            note: friendly
            tag: dog10005
      test_case_003:
        value:
          pet_detail:
            breeder: BreederName
            date_of_birth: "2023-10-31"
            pedigree:
              registration_no: 11111111
              date_of_registration: "2023-10-31"
              pedigree_image: 9j2wBDAA...8QAPxAAAQQABAMGBAYDAAEDAg
    schemas:
      ProblemDetailError:
        type: object
        properties:
          code:
            type: integer
            format: int32
          message:
            type: string
        required:
          - code
          - message
    responses:
      NotFound:
        description: Not Found
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ProblemDetailError"
      InternalServerError:
        description: Internal Server Error
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ProblemDetailError"
  ```

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)

---

---
url: /coding-standards/documents/forSQL/SQLコーディング規約（Oracle）.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。\
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。\
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# はじめに

## 前提条件

本書は、SQL コーディング規約についてまとめたものである。\
今回 RDBMS として採用する Oracle での SQL の使用を前提に記述している。

# SQL コーティング規約（可読性・管理性）

本章では可読性・管理性を高めることを目的としたコーディング規約について記載する。

## 書式全般

書式全般についてのコーディング規約を下記に示す。

* 1 行につき、1 文のみを記述する。
* SQL 中のインデントは、Java コーディング規約にあわせて半角スペースではなくタブ文字とする。
* ヘボン式ローマ字を使用する。
* 外来語に関しては、原語の綴りを使用する。
* 横は 80 文字を目安に改行する。
* 定数を条件に用いる場合やインライン・ビューで取得したいデータなど開発者の意図はコメントにて記載する。

## 予約語

予約語に対しては、大文字を使用する。(例 ： `SELECT`、`INSERT`、`UPDATE`、`DELETE` 等)

## 予約語以外

予約語以外に対しても、予約語と同様に大文字を使用する。(例 ： オブジェクト名、カラム名 等)

## 短縮名称

SQL 中に記述するエイリアス名など単語の短縮について示す。

1. 外来語に関しては、原語の短縮形を使用する。短縮形が存在しない場合には、母音を抜かして表記する。\
   例) corporation → corp / computer → cmptr

2. ローマ字の短縮は、単語の区切れの頭文字、または母音を抜かした子音字等を利用する。\
   例) nichijo → nchj

* カラムには必ずテーブルエイリアスを付与する
* テーブルのエイリアスは必ず付与すること。\
  必要ない場合（単一テーブルへの SELECT 等）も必ず付与すること\
  また、テーブルのエイリアス名は同 SQL 文の中で重複しないように命名すること。\
  （副問い合わせで利用したエイリアス名をメインの SQL 中のエイリアス名に利用しない。など）

## 文字コード

SQL ファイルの文字コード（エンコーディング）は Java ソースファイルと同じく『 Unicode UTF-8 』で保存する。

## 不要な空白文字（スペース）は除去する

不要な空白文字（スペース）は除去すること。

## SQL 文の整形

DML 文の節に対する予約語は左揃えにする。\
項目ごとに改行を入れ、項目の前にはインデントを挿入する。カンマは項目の前へ記入する。\
Java ソースファイルのようにファイルの先頭にコメント行を入れると DB 分析作業に支障があるため禁止とする。\
よって SQL ファイルの先頭は必ず`SELECT`、`UPDATE`、`INSERT`、`DELETE`、`MERGE`の何れかになる。

物理カラム名、テーブル名に対応する論理名を入れる場合、その後ろに単数行コメント（`-- `）にて記述する。\
SQL 内に挿入する単数行コメントは、`/*（半角スペース）コメント本文（半角スペース）*/` で行う。\
`,`（カンマ）と`AND`については各行の先頭に記述する。（以下の例を参照のこと）\
SQL フレームワークで実行する SQL の場合、SQL ステートメントの終わりを示す`;`（セミコロン）は記述しない。

良い例：

```sql
SELECT
/*
	処理名
*/
	TBL1.COLUMN1	AS	COLUMN1	-- カラム1
,	TBL1.COLUMN2	AS	COLUMN2	-- カラム2
FROM
	TABLE1	TBL1	-- テーブル1
```

WHERE 句の`=`、`!=`、`IS`（`IS NULL`の`IS`）の縦位置は揃える。

良い例：

```sql
WHERE
	A.TEN_NO	=	B.TEN_NO
AND	A.KAMOKU_CD	!=	'1'
AND	A.ANKEN_NO	IS	NULL
```

### SELECT 文

良い例：

```sql
SELECT
	TBL1.COLUMN1	AS	COLUMN1	-- カラム1
,	TBL1.COLUMN2	AS	COLUMN2	-- カラム2
FROM
	TABLE1	TBL1	-- テーブル1
WHERE
	TBL1.COLUMN3	=	1
ORDER BY
	TBL1.COLUMN1
,	TBL1.COLUMN2
```

### INSERT 文

良い例：

```sql
INSERT
INTO
	TABLE1	-- テーブル1
(
	COLUMN1	-- カラム1
,	COLUMN2	-- カラム2
,	COLUMN3	-- カラム3
) VALUES (
	VALUE1
,	VALUE2
,	VALUE3
)
```

### UPDATE 文

良い例：

```sql
UPDATE
	TABLE1	TBL1	-- テーブル1
SET
	TBL1.COLUMN2	=	100	-- カラム2
,	TBL1.COLUMN3	=	100	-- カラム3
WHERE
	TBL1.COLUMN1	=	10
```

### DELETE 文

良い例：

```sql
DELETE
FROM
	TABLE1	TBL1	-- テーブル1
WHERE
	TBL1.VALUE	=	1
```

### MERGE 文

DB 結合条件が一致した場合と不一致になった場合の、それぞれの SQL 文を記述する。

良い例：

```sql
MERGE
INTO
	PROFILE	P				-- PROFILEテーブル
USING
	NAME	N				-- NAMEテーブル
ON
	(
		P.NAME	= N.NAME		-- 条件
	)
WHEN MATCHED THEN			-- 条件が一致
	/*UPDATE文*/
WHEN NOT MATCHED THEN		-- 条件が不一致
	/*INSERT文*/
```

### AND（副問い合わせ）

良い例：

```sql
AND	XXX	=	(
		SELECT
			TBL1.COLUMN1
		,	TBL1.COLUMN2
		FROM
			TABLE1	TBL1
	)
```

### CASE 式

CASE 式は下記のように記載すること。

良い例：

```sql
CASE
	WHEN
		XXX.HOGE	=	YYY.FUGA
	AND	XXX.FUGA	=	YYY.FUGA
	THEN
		1
	ELSE
		0
END
```

`CASE`、`WHEN`、`THEN`、`ELSE`の後に改行を挿入すること。\
`CASE`の後、`END`の前までは 1 インデント挿入すること。

### IN 句

カンマの後にスペースを１文字入れる。

### 比較演算子

比較演算子の前後にタブ（またはスペース）を１文字入れる。

### 改行位置

SELECT 句、ORDER BY 句、GROUP BY 句等は最初に出現するカラムとカラムの区切りのカンマ前に改行を入れること。\
SELECT の FROM 句の最初に出現するテーブルと結合テーブルの区切りのカンマ前に改行を入れること。\
WHERE 句、MERGE の ON 句の各条件文の（AND や OR の）前に改行を入れること。\
命令句の後は、ヒント句が挿入できるように改行すること。

良い例：

```sql
SELECT
	T1.COLUMN1	AS	COLUMN1
,	T2.COLUMN2	AS	COLUMN2
FROM
	TABLE1	T1
,	TABLE2	T2
WHERE
	T1.COLUMN3	=	1
AND	T1.COLUMN4	=	T2.COLUMN4
ORDER BY
	T1.COLUMN1
,	T2.COLUMN2
```

### WITH 句

WITH の前後に改行を挿入すること\
また、インデントは下記のように記述すること

良い例：

```sql
-- カラムエイリアスあり
WITH
    NAME1   (
        COL_ALIAS1  -- カラム１
    ,   COL_ALIAS2  -- カラム２
    )   AS  (
        SELECT
        ・・・
    )
,   NAME2   (
        COL_ALIAS1  -- カラム１
    ,   COL_ALIAS2  -- カラム２
    )   AS  (
        SELECT
        ・・・
    )

-- カラムエイリアスなし
WITH
    NAME1   AS  (
        SELECT
        ・・・
    )
,   NAME2   AS  (
        SELECT
        ・・・
    )
```

### OFFSET 句 FETCH 句

OFFSET、FETCH の前に改行を挿入すること

良い例：

```sql
SELECT
	TBL1.COLUMN1	AS	COLUMN1
FROM
	TABLE1	TBL1
ORDER BY
	TBL1.COLUMN2	DESC
OFFSET 5 ROWS
FETCH NEXT 5 ROWS ONLY
```

### HINT 句

HINT 句は独立した行で記載すること\
HINT 内容にはインデントを付けること

良い例：

```sql
SELECT
/*+
	ここにHINTを記載
*/
	TBL1.COLUMN1	AS	COLUMN1
FROM
	TABLE1	TBL1
WHERE
	TBL1.COLUMN2	=	1
```

## コメント

* 修正コメント

  （修正コメントが必要な場合、）\
  処理追加の際、追加行の 1 行目の前と最終行の次の行にコメントを入れる。単一行の場合は、同一行の最後にコメントをつける。

  良い例：

  ```sql
  -- 2004/04/23 仕様変更管理番号 ADD(または、MOD、DEL) 変更者名 S ←　修正開始点コメント
  (追加処理)
  -- 2004/04/23仕様変更管理番号 ADD(または、MOD、DEL) 変更者名 E ←　修正終了点コメント
  ```

* 単数行コメント

  SQL 内で使用する単数行コメント（カラムコメントなど）には、「 `--` 」を使用する。

* 複数行コメント

  「 `/*` `*/` 」を使用する。下記に例を示す。\
  なお、前述で触れたとおり、SQL ファイルの先頭にコメントを記述することは禁止とする。

  良い例：

  ```sql
  /**********************************************************************/
  /*
   * コメントを始めるスラッシュとアスタリスクは、それだけを１行に置く。
   * それから、コメント・ブロック内の各行は縦にアスタリスクを置き
   * コメントがあることを強調する。
   * 最後に、アスタリスクとスラッシュは、それだけを１行に置く。
   */
  /**********************************************************************/
  ```

* 複数行コメントアウト

  複数行をコメントアウトする場合は、各行を「`--`」でコメントアウトする。\
  「 `/*` `*/` 」を使用すると、その中に「 `/*` `*/` 」が存在した場合、コメントアウトが途中で切れてしまう恐れがあるため、\
  使用しない。

* 論理名の記載

  `SELECT`・`INSERT`・`UPDATE`・`MERGE`のカラム名記述箇所には単数行コメントでカラムの論理名を記載する。\
  `SELECT`・`INSERT`・`UPDATE`・`DELETE`・`MERGE`のテーブル名記述箇所には単数行コメントでテーブルの論理名を記載する。\
  論理名は ERD 等で定義された論理名と必ず一致させること。

## 外部結合

結合方法は ANSI 形式（～`outer join` ～）ではなく Oracle 形式`(+)`を使用する。\
原則として`(+)`は条件文の右にくるカラムに付与する。

良い例：

```sql
T1.COL1	=	T2.COL2(+)
```

## 型変換

代入や WHERE 句の条件設定などでデータ・タイプが異なる場合、明示的にタイプ変換を行う。（暗黙の型変換は使用しない）

## 比較演算子

「等しくない」を示す演算子は「`!=`」を利用する。「`<>`」「`^=`」も動作するが統一の観点から利用しない。

## ORDER BY 句

`ORDER BY` 数字の構文は使用せずに、カラム名を記載する。

## GROUP BY 句

`GROUP BY` 数字の構文は使用せずに、カラム名を記載する。

集約関数を利用する場合は必ず記載すること。（省略可能であっても省略しない）

## EXISTS 句

EXISTS 句を記載する際、サブクエリになる SELECT 句の指定は定数「`1`」とする。\
「`*`」（ワイルドカード）や「`'X'`」は統一の観点から利用しない。\
また「`*`」（ワイルドカード）についてはパフォーマンスの観点からも禁止とする。

良い例：

```sql
WHERE
	EXISTS(
		SELECT
			1
		FROM
			FOO	F
		WHERE
			F.COL1	=	M.KEY
	)
```

## AS 句

トップレベルの SELECT 句には必ず`AS`句を記載し別名を付ける。\
同一の名前であっても AS 句を付与する。\
また、「`AS`」は省略可能であるが、省略はしないこと。

## WHERE 句

* 論理名の記載\
  WHERE 句でカラムと式を比較する際は左辺がカラムになるように記載すること。

  良い例：

  ```sql
  WHERE
  	TBL.COLUMN1	=	1
  AND	TBL.AMOUNT2	>	TBL.AMOUNT3	+	TBL.AMOUNT4
  ```

* 条件式の順序\
  原則として、WHERE 句で条件式を列挙する際、下記の順序を守ること。

  1. テーブル単位にまとめて順番に記述する\
     この際、テーブルの順序は FROM 句に記述した順序に準ずること。
  2. 1.のテーブル単位の中で絞り込み条件をまず記述し、その後結合条件を記述する。

  良い例：

  ```sql
  FROM
  	A_TABLE	A	-- A_TABLE
  ,	B_TABLE	B	-- B_TABLE
  ,	C_TABLE	C	-- C_TABLE
  WHERE
  -- A_TABLEの絞り込み
  	A.KEY1		=	?
  AND	A.KEY2		=	?
  -- B_TABLEの絞り込み
  AND	B.KEY1		=	?
  AND	B.KEY2		=	?
  -- B_TABLEの結合条件
  AND	B.COL1		=	A.COL1
  -- C_TABLEの絞り込み
  AND	C.KEY1		=	?
  AND	C.KEY2		=	?
  -- C_TABLEの結合条件
  AND	C.COL1		=	A.COL1
  AND	C.COL2		=	A.COL2
  AND	C.COL3		=	B.COL3
  ```

## COUNT 文

レコード数を数える COUNT 文の記述は`COUNT(*)`と記述する。\
`COUNT(1)`・`COUNT('X')` ・`COUNT(KEY1)`という記載は NG。

# SQL コーディング規約（パフォーマンス性）

本章ではパフォーマンス性を高めることを目的としたコーディング規約について記載する。

## 検索

検索処理におけるコーディング規約を下記に示す。

* 中間一致、後方一致検索はインデックスを利用できないため避ける

* 検索条件で`=`（等号）を使用できる場合は必ず使用する

  `A=1 or A=2`とする方が`A>0 and A<3`などと記述するのよりパフォーマンス上優位な場合が多い。\
  これは A にインデックスがある場合、`=`であれば、インデックスが有効に使われるためである。

* 可能な限り検索条件にパーティションキーの値を指定する

* 全列ワイルドカード「`*`」の使用はせず、カラム名を明記する

* インデックスによる検索を指定したい場合、下記の記載を行わない
  * インデックスカラムを含む演算に対して条件指定

    悪い例：

    ```sql
    TBL1.COL1	+	1	>	100 /* NGパターン 右辺で演算してください */
    ```

    良い例：

    ```sql
    TBL1.COL1	>	100	-	1
    ```

  * インデックスカラムに関数を通した値に対して条件指定

    悪い例：

    ```sql
    /* NGパターン 右辺に関数を通してください */
    TO_CHAR(TBL1.COL1, 'YYYYMMDD')	>	'20151231'
    ```

    良い例：

    ```sql
    TBL1.COL1	>=	TO_DATE('20160101', 'YYYYMMDD')
    ```

  * インデックスカラムを`OR`で条件指定（禁止ではないが原則行わない）

    悪い例：

    ```sql
    (
    	/* NGパターンINDEXが利用されない場合があります。他の方法を検討してください */
    		TBL1.COL1	=	1
    	OR	TBL1.COL1	=	2
    	)
    ```

## 挿入

挿入処理におけるコーディング規約を下記に示す。

* 全列ワイルドカード「`*`」の使用はせず、カラム名を明記する。

## 更新

更新処理におけるコーディング規約を下記に示す。

* 主キーの値の UPDATE は原則行わない。外部キーがあればエラーになる。\
  外部キーが無い場合でも、事実上、主キーの値を利用して、検索、更新する場合は、リンクが切れてしまう。
* パーティションキーの UPDATE は原則行わない。
* VIEW を使用するデータ更新は禁止。更新は実表に対して行う。

## 削除

削除処理におけるコーディング規約を下記に示す。

* 大量件数（数百万件レベル）の delete 文発行は避ける。

## WITH 句

WITH 句の誤った使い方はパフォーマンスの劣化を招くため、WITH 句を利用する場合は DBA に相談する。

## DISTINCT 句

DISTINCT は、暗黙のソート処理が行われる可能性があるため性能劣化につながる。\
EXISTS 句の使用・代替を検討すること。

悪い例：

```sql
SELECT
    DISTINCT
    D.NO    AS  DEPT_NO
,   D.NAME  AS  DEPT_NAME
FROM
    DEPARTMENT  D
,   EMPLOYEE    E
WHERE
    D.NO    =   E.DEPT_NO   -- 社員が一人以上属している部門を取得
```

良い例：

```sql
SELECT
    D.NO    AS  DEPT_NO
,   D.NAME  AS  DEPT_NAME
FROM
    DEPARTMENT  D
WHERE
    EXISTS(
        SELECT
            1
        FROM
            EMPLOYEE    E
        WHERE
            D.NO    =   E.DEPT_NO   -- 社員が一人以上属している部門を取得
    )
```

## IN 句

IN 句は最大 1000 個まで指定できるが、200 個程度でも ORA エラーが発生するケースがある。\
また IN 句の少しだけ異なる SQL が大量に発行されると CPU 高騰やメモリ枯渇を招く。\
従って 100 を超えるような長い IN 句は使用せず、一時表を利用して `IN (SELECT ・・・ FROM 一時表)`のように書き換える。

## NOT IN 句

原則`NOT IN（SELECT～）`は使用せずに、`NOT EXISTS (SELECT～)`を使用する。\
`NOT IN`句は、内部的にソートマージの結合をすることでテーブルをフルスキャンする場合があるため、性能が悪化する可能性がある。

## UNION 句

`UNION`は`DISTINCT`処理が含まれパフォーマンス上問題があるため、`UNION ALL`を使用する。

## パラレルヒント句

パラレルヒント句は DB 負荷が高いため、原則使用禁止とする。付与したい場合は DBA に相談する。

## SELECT FOR UPDATE

* `SELECT FOR UPDATE`は`NO WAIT`または「`WAIT`秒数指定」を必ず付ける。\
  `WAIT`指定なしの場合はロックが解除されてもプログラムに制御が返らないことがある。\
  ※WAIT 秒数指定を行う際の秒数は各開発者で決めるのではなくプロジェクトで決定した方針に従うこと。\
  また、SQL ライブラリを利用していて定数が記述できる場合は定数で記述すること。
* `SELECT FOR UPDATE`で複数行にロックをかける場合、同時実行されるとデットロックを起こす可能性があるため、１件のロックでない場合は`ORDER BY`を指定する。

## 分析関数

分析関数の使用は可能だが、性能悪化を招く恐れがあるため、特性を知らない方は DBA に相談する。

## インデックス

インデックスの必要性については DBA で最終判断するため、必要とする場合は DBA へ相談する。

## 外部結合

外部結合する際、内部表（駆動表）はなるべく想定件数の少ない表にする。

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)

---

---
url: /coding-standards/documents/forSQL/SQLコーディング規約（PostgreSQL）.md
---

本コーディング規約は、世の中のシステム開発プロジェクトのために無償で提供致します。\
ただし、掲載内容および利用に際して発生した問題、それに伴う損害については、フューチャー株式会社は一切の責務を負わないものとします。\
また、掲載している情報は予告なく変更することがございますので、あらかじめご了承下さい。

# はじめに

## 前提条件

本書は、SQL コーディング規約についてまとめたものである。\
今回 RDBMS として採用する PostgreSQL での SQL の使用を前提に記述している。

# SQL コーティング規約（可読性・管理性）

本章では可読性・管理性を高めることを目的としたコーディング規約について記載する。

## 書式全般

書式全般についてのコーディング規約を下記に示す。

* 1 行につき、1 文のみを記述する。
* SQL 中のインデントは、Java コーディング規約にあわせて半角スペースではなくタブ文字とする。
* ヘボン式ローマ字を使用する。
* 外来語に関しては、原語の綴りを使用する。
* 横は 80 文字を目安に改行する。
* 定数を条件に用いる場合やインライン・ビューで取得したいデータなど開発者の意図はコメントにて記載する。

## 予約語

予約語に対しては、小文字を使用する。(例 ： `select`、`insert`、`update`、`delete` 等)

## 予約語以外

予約語以外に対しても、予約語と同様に小文字を使用する。(例 ： オブジェクト名、カラム名 等)

## 短縮名称

SQL 中に記述するエイリアス名など単語の短縮について示す。

1. 外来語に関しては、原語の短縮形を使用する。短縮形が存在しない場合には、母音を抜かして表記する。\
   例) corporation → corp / computer → cmptr

2. ローマ字の短縮は、単語の区切れの頭文字、または母音を抜かした子音字等を利用する。\
   例) nichijo → nchj

* カラムには必ずテーブルエイリアスを付与する
* テーブルのエイリアスは必ず付与すること。\
  必要ない場合（単一テーブルへの SELECT 等）も必ず付与すること\
  また、テーブルのエイリアス名は同 SQL 文の中で重複しないように命名すること。\
  （副問い合わせで利用したエイリアス名をメインの SQL 中のエイリアス名に利用しない。など）

## 文字コード

SQL ファイルの文字コード（エンコーディング）は Java ソースファイルと同じく『 Unicode UTF-8 』で保存する。

## 不要な空白文字（スペース）は除去する

不要な空白文字（スペース）は除去すること。

## SQL 文の整形

DML 文の節に対する予約語は左揃えにする。\
項目ごとに改行を入れ、項目の前にはインデントを挿入する。カンマは項目の前へ記入する。\
Java ソースファイルのようにファイルの先頭にコメント行を入れると DB 分析作業に支障があるため禁止とする。\
よって SQL ファイルの先頭は必ず`select`、`update`、`insert`、`delete`の何れかになる。

物理カラム名、テーブル名に対応する論理名を入れる場合、その後ろに単数行コメント（`-- `）にて記述する。\
SQL 内に挿入する単数行コメントは、`/*（半角スペース）コメント本文（半角スペース）*/` で行う。\
`,`（カンマ）と`AND`については各行の先頭に記述する。（以下の例を参照のこと）\
SQL フレームワークで実行する SQL の場合、SQL ステートメントの終わりを示す`;`（セミコロン）は記述しない。

良い例：

```sql
select
/*
	処理名
*/
	tbl1.column1	as	column1	-- カラム1
,	tbl1.column2	as	column2	-- カラム2
from
	table1	tbl1	-- テーブル1
```

WHERE 句の`=`、`!=`、`is`（`is null`の`is`）の縦位置は揃える。

良い例：

```sql
where
	a.ten_no	=	b.ten_no
and	a.kamoku_cd	!=	'1'
and	a.anken_no	is	null
```

### SELECT 文

良い例：

```sql
select
	tbl1.column1	as	column1	-- カラム1
,	tbl1.column2	as	column2	-- カラム2
from
	table1	tbl1	-- テーブル1
where
	tbl1.column3	=	1
order by
	tbl1.column1
,	tbl1.column2
```

### INSERT 文

良い例：

```sql
insert
into
	table1	-- テーブル1
(
	column1	-- カラム1
,	column2	-- カラム2
,	column3	-- カラム3
) values (
	value1
,	value2
,	value3
)
```

### UPDATE 文

良い例：

```sql
update
	table1	tbl1	-- テーブル1
set
	tbl1.column2	=	100	-- カラム2
,	tbl1.column3	=	100	-- カラム3
where
	tbl1.column1	=	10
```

### DELETE 文

良い例：

```sql
delete
from
	table1	tbl1	-- テーブル1
where
	tbl1.value	=	1
```

### AND（副問い合わせ）

良い例：

```sql
and	xxx	=	(
		select
			tbl1.column1
		,	tbl1.column2
		from
			table1	tbl1
	)
```

### CASE 式

CASE 式は下記のように記載すること。

良い例：

```sql
case
	when
		xxx.hoge	=	yyy.fuga
	and	xxx.fuga	=	yyy.fuga
	then
		1
	else
		0
end
```

`case`、`when`、`then`、`else`の後に改行を挿入すること。\
`case`の後、`end`の前までは 1 インデント挿入すること。

### IN 句

カンマの後にスペースを１文字入れる。

### 比較演算子

比較演算子の前後にタブ（またはスペース）を１文字入れる。

### 改行位置

select 句、order by 句、group by 句等は最初に出現するカラムとカラムの区切りのカンマ前に改行を入れること。\
select の from 句の最初に出現するテーブルと結合テーブルの区切りのカンマ前に改行を入れること。\
where 句の on 句の各条件文の（and や or の）前に改行を入れること。\
命令句の後は、ヒント句が挿入できるように改行すること。

良い例：

```sql
select
	t1.column1	as	column1
,	t2.column2	as	column2
from
	table1	t1
,	table2	t2
where
	t1.column3	=	1
and	t1.column4	=	t2.column4
order by
	t1.column1
,	t2.column2
```

### WITH 句

with の前後に改行を挿入すること\
また、インデントは下記のように記述すること

良い例：

```sql
-- カラムエイリアスあり
with
    name1   (
        col_alias1  -- カラム１
    ,   col_alias2  -- カラム２
    )   as  (
        select
        ・・・
    )
,   name2   (
        col_alias1  -- カラム１
    ,   col_alias2  -- カラム２
    )   as  (
        select
        ・・・
    )

-- カラムエイリアスなし
with
    name1   as  (
        select
        ・・・
    )
,   name2   as  (
        select
        ・・・
    )
```

### LIMIT 句 OFFSET 句

LIMIT、OFFSET の前に改行を挿入すること

良い例：

```sql
select
    tbl1.column1    as  column1
from
    table1  tbl1
order by
    tbl1.column2    desc
limit 5
offset 5
```

### HINT 句

HINT 句は独立した行で記載すること\
HINT 内容にはインデントを付けること

良い例：

```sql
select
/*+
	ここにhintを記載
*/
	tbl1.column1	as	column1
from
	table1	tbl1
where
	tbl1.column2	=	1
```

## コメント

* 修正コメント

  （修正コメントが必要な場合、）\
  処理追加の際、追加行の 1 行目の前と最終行の次の行にコメントを入れる。単一行の場合は、同一行の最後にコメントをつける。

  良い例：

  ```sql
  -- 2004/04/23 仕様変更管理番号 ADD(または、MOD、DEL) 変更者名 S ←　修正開始点コメント
  (追加処理)
  -- 2004/04/23仕様変更管理番号 ADD(または、MOD、DEL) 変更者名 E ←　修正終了点コメント
  ```

* 単数行コメント

  SQL 内で使用する単数行コメント（カラムコメントなど）には、「 `--` 」を使用する。

* 複数行コメント

  「 `/*` `*/` 」を使用する。下記に例を示す。\
  なお、前述で触れたとおり、SQL ファイルの先頭にコメントを記述することは禁止とする。

  良い例：

  ```sql
  /**********************************************************************/
  /*
   * コメントを始めるスラッシュとアスタリスクは、それだけを１行に置く。
   * それから、コメント・ブロック内の各行は縦にアスタリスクを置き
   * コメントがあることを強調する。
   * 最後に、アスタリスクとスラッシュは、それだけを１行に置く。
   */
  /**********************************************************************/
  ```

* 複数行コメントアウト

  複数行をコメントアウトする場合は、各行を「`--`」でコメントアウトする。\
  「 `/*` `*/` 」を使用すると、その中に「 `/*` `*/` 」が存在した場合、コメントアウトが途中で切れてしまう恐れがあるため、\
  使用しない。

* 論理名の記載

  `select`・`insert`・`update`・`merge`のカラム名記述箇所には単数行コメントでカラムの論理名を記載する。\
  `select`・`insert`・`update`・`delete`・`merge`のテーブル名記述箇所には単数行コメントでテーブルの論理名を記載する。\
  論理名は ERD 等で定義された論理名と必ず一致させること。

## 型変換

代入や WHERE 句の条件設定などでデータ・タイプが異なる場合、明示的にタイプ変換を行う。（暗黙の型変換は使用しない）

## 比較演算子

「等しくない」を示す演算子は「`!=`」を利用する。「`<>`」も動作するが統一の観点から利用しない。

## ORDER BY 句

`order by` 数字の構文は使用せずに、カラム名を記載する。

## GROUP BY 句

`group by` 数字の構文は使用せずに、カラム名を記載する。

集約関数を利用する場合は必ず記載すること。（省略可能であっても省略しない）

## EXISTS 句

EXISTS 句を記載する際、サブクエリになる SELECT 句の指定は定数「`1`」とする。\
「`*`」（ワイルドカード）や「`'X'`」は統一の観点から利用しない。\
また「`*`」（ワイルドカード）についてはパフォーマンスの観点からも禁止とする。

良い例：

```sql
where
	exists(
		select
			1
		from
			foo	f
		where
			f.col1	=	m.key
	)
```

## AS 句

トップレベルの SELECT 句には必ず`as`句を記載し別名を付ける。\
同一の名前であっても AS 句を付与する。\
また、「`as`」は省略可能であるが、省略はしないこと。

## WHERE 句

* 論理名の記載\
  WHERE 句でカラムと式を比較する際は左辺がカラムになるように記載すること。

  良い例：

  ```sql
  where
  	tbl.column1	=	1
  and	tbl.amount2	>	tbl.amount3	+	tbl.amount4
  ```

* 条件式の順序\
  原則として、WHERE 句で条件式を列挙する際、下記の順序を守ること。

  1. テーブル単位にまとめて順番に記述する\
     この際、テーブルの順序は FROM 句に記述した順序に準ずること。
  2. 1.のテーブル単位の中で絞り込み条件をまず記述し、その後結合条件を記述する。

  良い例：

  ```sql
  from
  	a_table	a	-- a_table
  ,	b_table	b	-- b_table
  ,	c_table	c	-- c_table
  where
  -- a_tableの絞り込み
  	a.key1		=	?
  and	a.key2		=	?
  -- b_tableの絞り込み
  and	b.key1		=	?
  and	b.key2		=	?
  -- b_tableの結合条件
  and	b.col1		=	a.col1
  -- c_tableの絞り込み
  and	c.key1		=	?
  and	c.key2		=	?
  -- c_tableの結合条件
  and	c.col1		=	a.col1
  and	c.col2		=	a.col2
  and	c.col3		=	b.col3
  ```

## COUNT 文

レコード数を数える COUNT 文の記述は`count(*)`と記述する。\
`count(1)`・`count('x')` ・`count(key1)`という記載は NG。

## 文字列リテラル

### エスケープシーケンス

文字列リテラル中のシングルクォーテーションのエスケープは「 `''` 」とシングルクォーテーションを二つつなげた記述をする。\
「 `\'` 」も同様の結果が得られるが円マーク（バックスラッシュ）によるエスケープは利用しない。\
円マークをエスケープせざるを得ないときのみ円マークによるエスケープ利用して良いが、\
円マークを文字列リテラルで表現する必要のある設計自体を避けること。

※PostgreSQL は設定によって円マーク（バックスラッシュ）によるエスケープを無効にできます。（デフォルト無効）\
円マークをエスケープするときは、自プロジェクトでどちらに設定されているか確認してください。

良い例：

```sql
update
    table_a
set
    text_data   =   'that''s right'
```

悪い例：

```sql
update
    table_a
set
    text_data   =   'that\'s too bad'
```

# SQL コーディング規約（パフォーマンス性）

本章ではパフォーマンス性を高めることを目的としたコーディング規約について記載する。

## 検索

検索処理におけるコーディング規約を下記に示す。

* 中間一致、後方一致検索はインデックスを利用できないため避ける

* 検索条件で`=`（等号）を使用できる場合は必ず使用する

  `a=1 or a=2`とする方が`a>0 and a<3`などと記述するのよりパフォーマンス上優位な場合が多い。\
  これは `a` にインデックスがある場合、`=`であれば、インデックスが有効に使われるためである。

* 可能な限り検索条件にパーティションキーの値を指定する

* 全列ワイルドカード「`*`」の使用はせず、カラム名を明記する

* インデックスによる検索を指定したい場合、下記の記載を行わない
  * インデックスカラムを含む演算に対して条件指定

    悪い例：

    ```sql
    tbl1.col1	+	1	>	100 /* NGパターン 右辺で演算してください */
    ```

    良い例：

    ```sql
    tbl1.col1	>	100	-	1
    ```

  * インデックスカラムに関数を通した値に対して条件指定

    悪い例：

    ```sql
    /* NGパターン 右辺に関数を通してください */
    to_char(tbl1.col1, 'YYYYMMDD')	>	'20151231'
    ```

    良い例：

    ```sql
    tbl1.col1	>=	to_date('20160101', 'YYYYMMDD')
    ```

  * インデックスカラムを`OR`で条件指定（禁止ではないが原則行わない）

    悪い例：

    ```sql
    (
    	/* NGパターンINDEXが利用されない場合があります。他の方法を検討してください */
    		tbl1.col1	=	1
    	or	tbl1.col1	=	2
    	)
    ```

## 挿入

挿入処理におけるコーディング規約を下記に示す。

* 全列ワイルドカード「`*`」の使用はせず、カラム名を明記する。

## 更新

更新処理におけるコーディング規約を下記に示す。

* 主キーの値の UPDATE は原則行わない。外部キーがあればエラーになる。\
  外部キーが無い場合でも、事実上、主キーの値を利用して、検索、更新する場合は、リンクが切れてしまう。
* パーティションキーの UPDATE は原則行わない。
* VIEW を使用するデータ更新は禁止。更新は実表に対して行う。

## 削除

削除処理におけるコーディング規約を下記に示す。

* 大量件数（数百万件レベル）の delete 文発行は避ける。

## DISTINCT 句

DISTINCT は、暗黙のソート処理が行われる可能性があるため性能劣化につながる。\
EXISTS 句の使用・代替を検討すること。

悪い例：

```sql
select
    distinct
    d.no    as  dept_no
,   d.name  as  dept_name
from
    department  d
,   employee    e
where
    d.no    =   e.dept_no   -- 社員が一人以上属している部門を取得
```

良い例：

```sql
select
    d.no    as  dept_no
,   d.name  as  dept_name
from
    department  d
where
    exists(
        select
            1
        from
            employee    e
        where
            d.no    =   e.dept_no   -- 社員が一人以上属している部門を取得
    )
```

## IN 句

IN 句は最大 1000 個まで指定できるが、200 個程度でも ORA エラーが発生するケースがある。\
また IN 句の少しだけ異なる SQL が大量に発行されると CPU 高騰やメモリ枯渇を招く。\
従って 100 を超えるような長い IN 句は使用せず、一時表を利用して `in (select ・・・ from 一時表)`のように書き換える。

## NOT IN 句

原則`not in（select～）`は使用せずに、`not exists (select～)`を使用する。\
`NOT IN`句は、内部的にソートマージの結合をすることでテーブルをフルスキャンする場合があるため、性能が悪化する可能性がある。

## UNION 句

`union`は`distinct`処理が含まれパフォーマンス上問題があるため、`union all`を使用する。

## SELECT FOR UPDATE

* `select for update`で複数行にロックをかける場合、同時実行されるとデットロックを起こす可能性があるため、１件のロックでない場合は`order by`を指定する。

## 分析関数

分析関数の使用は可能だが、性能悪化を招く恐れがあるため、特性を知らない方は DBA に相談する。

## インデックス

インデックスの必要性については DBA で最終判断するため、必要とする場合は DBA へ相談する。

## 外部結合

外部結合する際、内部表（駆動表）はなるべく想定件数の少ない表にする。

***

# License

[![CC-By-4.0](https://licensebuttons.net/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/deed.ja)
